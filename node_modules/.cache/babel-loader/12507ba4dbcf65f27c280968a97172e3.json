{"ast":null,"code":"'use strict';\n\nvar detectSilence = require('./detectsilence');\n/**\r\n * This function attempts to workaround WebKit Bug 180748. It does so by\r\n *\r\n *   1. Calling `getUserMedia`, and\r\n *   2. Checking to see if the resulting MediaStream is silent.\r\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\r\n *\r\n * The function only repeats up to `n` times, and it only waits `timeout`\r\n * milliseconds when detecting silence. Assuming `getUserMedia` is\r\n * instantaneous, in the best case, this function returns a Promise that\r\n * resolves immediately; in the worst case, this function returns a Promise that\r\n * resolves in `n` * `timeout` milliseconds.\r\n *\r\n * @param {Log} log\r\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\r\n * @param {MediaStreamConstraints} constraints\r\n * @param {number} [n=3]\r\n * @param {number} [timeout=250]\r\n * @returns Promise<MediaStream>\r\n */\n\n\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\n  n = typeof n === 'number' ? n : 3;\n  var retry = 0; // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\n  // it exports a default instance whose constructor calls Object.assign.\n\n  var AudioContextFactory = require('./audiocontext');\n\n  var holder = {};\n  var audioContext = AudioContextFactory.getOrCreate(holder);\n  /**\r\n   * We can't use async/await yet, so I need to factor this out.\r\n   * @returns {Promise<MediaStream>}\r\n   */\n\n  function doWorkaround() {\n    return getUserMedia(constraints).then(function (stream) {\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\n        log.warn('Encountered an error while detecting silence', err);\n        return true;\n      }) : Promise.resolve(false);\n      return isSilentPromise.then(function (isSilent) {\n        if (!isSilent) {\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\n          return stream;\n        } else if (n <= 0) {\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\r\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\n          return stream;\n        }\n\n        log.warn('Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #' + ++retry + '.');\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        n--;\n        return doWorkaround();\n      });\n    });\n  }\n\n  return doWorkaround().then(function (stream) {\n    AudioContextFactory.release(holder);\n    return stream;\n  }, function (error) {\n    AudioContextFactory.release(holder);\n    throw error;\n  });\n}\n\nmodule.exports = workaround;","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilio-video/es5/webaudio/workaround180748.js"],"names":["detectSilence","require","workaround","log","getUserMedia","constraints","n","timeout","retry","AudioContextFactory","holder","audioContext","getOrCreate","doWorkaround","then","stream","isSilentPromise","audio","catch","err","warn","Promise","resolve","isSilent","info","getTracks","forEach","track","stop","release","error","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyBC,YAAzB,EAAuCC,WAAvC,EAAoDC,CAApD,EAAuDC,OAAvD,EAAgE;AAC9DD,EAAAA,CAAC,GAAG,OAAOA,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4B,CAAhC;AACA,MAAIE,KAAK,GAAG,CAAZ,CAF8D,CAI9D;AACA;;AACA,MAAIC,mBAAmB,GAAGR,OAAO,CAAC,gBAAD,CAAjC;;AACA,MAAIS,MAAM,GAAG,EAAb;AACA,MAAIC,YAAY,GAAGF,mBAAmB,CAACG,WAApB,CAAgCF,MAAhC,CAAnB;AAEA;AACF;AACA;AACA;;AACE,WAASG,YAAT,GAAwB;AACtB,WAAOT,YAAY,CAACC,WAAD,CAAZ,CAA0BS,IAA1B,CAA+B,UAAUC,MAAV,EAAkB;AACtD,UAAIC,eAAe,GAAGX,WAAW,CAACY,KAAZ,GAAoBjB,aAAa,CAACW,YAAD,EAAeI,MAAf,EAAuBR,OAAvB,CAAb,CAA6CW,KAA7C,CAAmD,UAAUC,GAAV,EAAe;AAC1GhB,QAAAA,GAAG,CAACiB,IAAJ,CAAS,8CAAT,EAAyDD,GAAzD;AACA,eAAO,IAAP;AACD,OAHyC,CAApB,GAGjBE,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAHL;AAIA,aAAON,eAAe,CAACF,IAAhB,CAAqB,UAAUS,QAAV,EAAoB;AAC9C,YAAI,CAACA,QAAL,EAAe;AACbpB,UAAAA,GAAG,CAACqB,IAAJ,CAAS,wDAAT;AACA,iBAAOT,MAAP;AACD,SAHD,MAGO,IAAIT,CAAC,IAAI,CAAT,EAAY;AACjBH,UAAAA,GAAG,CAACiB,IAAJ,CAAS;AACnB,sEADU;AAEA,iBAAOL,MAAP;AACD;;AACDZ,QAAAA,GAAG,CAACiB,IAAJ,CAAS,wHAAwH,EAAEZ,KAA1H,GAAkI,GAA3I;AACAO,QAAAA,MAAM,CAACU,SAAP,GAAmBC,OAAnB,CAA2B,UAAUC,KAAV,EAAiB;AAC1C,iBAAOA,KAAK,CAACC,IAAN,EAAP;AACD,SAFD;AAGAtB,QAAAA,CAAC;AACD,eAAOO,YAAY,EAAnB;AACD,OAfM,CAAP;AAgBD,KArBM,CAAP;AAsBD;;AAED,SAAOA,YAAY,GAAGC,IAAf,CAAoB,UAAUC,MAAV,EAAkB;AAC3CN,IAAAA,mBAAmB,CAACoB,OAApB,CAA4BnB,MAA5B;AACA,WAAOK,MAAP;AACD,GAHM,EAGJ,UAAUe,KAAV,EAAiB;AAClBrB,IAAAA,mBAAmB,CAACoB,OAApB,CAA4BnB,MAA5B;AACA,UAAMoB,KAAN;AACD,GANM,CAAP;AAOD;;AAEDC,MAAM,CAACC,OAAP,GAAiB9B,UAAjB","sourcesContent":["'use strict';\r\n\r\nvar detectSilence = require('./detectsilence');\r\n\r\n/**\r\n * This function attempts to workaround WebKit Bug 180748. It does so by\r\n *\r\n *   1. Calling `getUserMedia`, and\r\n *   2. Checking to see if the resulting MediaStream is silent.\r\n *   3. If so, repeat Step 1; otherwise, return the MediaStream.\r\n *\r\n * The function only repeats up to `n` times, and it only waits `timeout`\r\n * milliseconds when detecting silence. Assuming `getUserMedia` is\r\n * instantaneous, in the best case, this function returns a Promise that\r\n * resolves immediately; in the worst case, this function returns a Promise that\r\n * resolves in `n` * `timeout` milliseconds.\r\n *\r\n * @param {Log} log\r\n * @param {function(MediaStreamConstraints): Promise<MediaStream>} getUserMedia\r\n * @param {MediaStreamConstraints} constraints\r\n * @param {number} [n=3]\r\n * @param {number} [timeout=250]\r\n * @returns Promise<MediaStream>\r\n */\r\nfunction workaround(log, getUserMedia, constraints, n, timeout) {\r\n  n = typeof n === 'number' ? n : 3;\r\n  var retry = 0;\r\n\r\n  // NOTE(mroberts): We have to delay require-ing AudioContextFactory, because\r\n  // it exports a default instance whose constructor calls Object.assign.\r\n  var AudioContextFactory = require('./audiocontext');\r\n  var holder = {};\r\n  var audioContext = AudioContextFactory.getOrCreate(holder);\r\n\r\n  /**\r\n   * We can't use async/await yet, so I need to factor this out.\r\n   * @returns {Promise<MediaStream>}\r\n   */\r\n  function doWorkaround() {\r\n    return getUserMedia(constraints).then(function (stream) {\r\n      var isSilentPromise = constraints.audio ? detectSilence(audioContext, stream, timeout).catch(function (err) {\r\n        log.warn('Encountered an error while detecting silence', err);\r\n        return true;\r\n      }) : Promise.resolve(false);\r\n      return isSilentPromise.then(function (isSilent) {\r\n        if (!isSilent) {\r\n          log.info('Got a non-silent audio MediaStreamTrack; returning it.');\r\n          return stream;\r\n        } else if (n <= 0) {\r\n          log.warn('Got a silent audio MediaStreamTrack. Normally we would try \\\r\nto get a new one, but we\\'ve run out of retries; returning it anyway.');\r\n          return stream;\r\n        }\r\n        log.warn('Got a silent audio MediaStreamTrack. Stopping all MediaStreamTracks and calling getUserMedia again. This is retry #' + ++retry + '.');\r\n        stream.getTracks().forEach(function (track) {\r\n          return track.stop();\r\n        });\r\n        n--;\r\n        return doWorkaround();\r\n      });\r\n    });\r\n  }\r\n\r\n  return doWorkaround().then(function (stream) {\r\n    AudioContextFactory.release(holder);\r\n    return stream;\r\n  }, function (error) {\r\n    AudioContextFactory.release(holder);\r\n    throw error;\r\n  });\r\n}\r\n\r\nmodule.exports = workaround;"]},"metadata":{},"sourceType":"script"}