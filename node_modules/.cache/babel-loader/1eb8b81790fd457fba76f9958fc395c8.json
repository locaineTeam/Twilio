{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeMap = void 0;\n\nclass Node {\n  constructor(key, value) {\n    this.balanceFactor = 0;\n    this.key = key;\n    this.value = value;\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n\n  get isRoot() {\n    return this.parent === null;\n  }\n\n  get isLeaf() {\n    return this.left === null && this.right === null;\n  }\n\n  get isLeftChild() {\n    return this.parent.left === this;\n  }\n\n  update(value) {\n    this.value = value;\n  }\n\n  replace(target, replacement) {\n    if (!target) {\n      return;\n    }\n\n    if (this.left === replacement) {\n      this.left = replacement;\n    } else if (this.right === replacement) {\n      this.right = replacement;\n    }\n  }\n\n}\n/**\n * @property length\n */\n\n\nclass TreeMap {\n  constructor(less, equal) {\n    this.isLessThan = less || ((x, y) => x < y);\n\n    this.isEqual = equal || ((x, y) => x === y);\n\n    this.root = null;\n    this.count = null;\n  }\n\n  get size() {\n    return this.count;\n  }\n\n  clear() {\n    this.root = null;\n    this.count = 0;\n  }\n\n  set(key, value) {\n    let node = this.getNode(key);\n\n    if (node) {\n      node.update(value);\n    } else {\n      this.insert(key, value);\n    } // return node;\n\n  }\n\n  insert(key, value) {\n    let node = new Node(key, value);\n    this.count++;\n\n    if (!this.root) {\n      this.root = node; // return node;\n\n      return;\n    }\n\n    let currNode = this.root;\n\n    for (;;) {\n      if (this.isLessThan(key, currNode.key)) {\n        if (currNode.left) {\n          currNode = currNode.left;\n        } else {\n          currNode.left = node;\n          break;\n        }\n      } else {\n        if (currNode.right) {\n          // eslint-disable-line no-lonely-if\n          currNode = currNode.right;\n        } else {\n          currNode.right = node;\n          break;\n        }\n      }\n    }\n\n    node.parent = currNode;\n    currNode = node;\n\n    while (currNode.parent) {\n      let parent = currNode.parent;\n      let prevBalanceFactor = parent.balanceFactor;\n\n      if (currNode.isLeftChild) {\n        parent.balanceFactor++;\n      } else {\n        parent.balanceFactor--;\n      }\n\n      if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {\n        break;\n      }\n\n      if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n        this.rebalance(parent);\n        break;\n      }\n\n      currNode = parent;\n    } // return node;\n\n  }\n\n  get(key) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key)) {\n        return currentNode.value;\n      }\n\n      if (this.isLessThan(key, currentNode.key)) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    return null;\n  }\n\n  delete(key) {\n    // update this algorithm and remove any\n    let node = this.getNode(key);\n\n    if (!node || node.key !== key) {\n      return null;\n    }\n\n    let parent = node.parent;\n    let left = node.left;\n    let right = node.right;\n\n    if (!!left !== !!right) {\n      // one child\n      let child = left || right;\n\n      if (!parent && !child) {\n        this.root = null;\n      } else if (parent && !child) {\n        this.root = child;\n      } else {\n        parent.replace(node, null);\n        this.rebalance(parent);\n      }\n    } else {\n      // two children\n      let maxLeft = node.left;\n\n      while (maxLeft.right) {\n        maxLeft = maxLeft.right;\n      }\n\n      if (node.left === maxLeft) {\n        if (node.isRoot) {\n          this.root = maxLeft;\n          maxLeft.parent = null;\n        } else {\n          if (node.isLeftChild) {\n            node.parent.left = maxLeft;\n          } else {\n            node.parent.right = maxLeft;\n          }\n\n          maxLeft.parent = node.parent;\n        }\n\n        maxLeft.right = node.right;\n        maxLeft.right.parent = maxLeft;\n        maxLeft.balanceFactor = node.balanceFactor;\n        node = {\n          parent: maxLeft,\n          isLeftChild: true\n        };\n      } else {\n        let mlParent = maxLeft.parent;\n        let mlLeft = maxLeft.left;\n        mlParent.right = mlLeft;\n\n        if (mlLeft) {\n          mlLeft.parent = mlParent;\n        }\n\n        if (node.isRoot) {\n          this.root = maxLeft;\n          maxLeft.parent = null;\n        } else {\n          if (node.isLeftChild) {\n            node.parent.left = maxLeft;\n          } else {\n            node.parent.right = maxLeft;\n          }\n\n          maxLeft.parent = node.parent;\n        }\n\n        maxLeft.right = node.right;\n        maxLeft.right.parent = maxLeft;\n        maxLeft.left = node.left;\n        maxLeft.left.parent = maxLeft;\n        maxLeft.balanceFactor = node.balanceFactor;\n        node = {\n          parent: mlParent,\n          isLeftChild: false\n        };\n      }\n    }\n\n    this.count--;\n\n    while (node.parent) {\n      let parent = node.parent;\n      let prevBalanceFactor = parent.balanceFactor;\n\n      if (node.isLeftChild) {\n        parent.balanceFactor -= 1;\n      } else {\n        parent.balanceFactor += 1;\n      }\n\n      if (Math.abs(parent.balanceFactor) > Math.abs(prevBalanceFactor)) {\n        if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n          this.rebalance(parent);\n\n          if (parent.parent.balanceFactor === 0) {\n            node = parent.parent;\n          } else {\n            break;\n          }\n        } else {\n          break;\n        }\n      } else {\n        node = parent;\n      }\n    }\n\n    return null;\n  }\n\n  getNode(key) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key)) {\n        return currentNode;\n      }\n\n      if (this.isLessThan(key, currentNode.key)) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    return null;\n  }\n\n  rebalance(node) {\n    if (node.balanceFactor < 0) {\n      if (node.right.balanceFactor > 0) {\n        this.rotateRight(node.right);\n        this.rotateLeft(node);\n      } else {\n        this.rotateLeft(node);\n      }\n    } else if (node.balanceFactor > 0) {\n      if (node.left.balanceFactor < 0) {\n        this.rotateLeft(node.left);\n        this.rotateRight(node);\n      } else {\n        this.rotateRight(node);\n      }\n    }\n  }\n\n  rotateLeft(pivot) {\n    let root = pivot.right;\n    pivot.right = root.left;\n\n    if (root.left !== null) {\n      root.left.parent = pivot;\n    }\n\n    root.parent = pivot.parent;\n\n    if (root.parent === null) {\n      this.root = root;\n    } else if (pivot.isLeftChild) {\n      root.parent.left = root;\n    } else {\n      root.parent.right = root;\n    }\n\n    root.left = pivot;\n    pivot.parent = root;\n    pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);\n    root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);\n  }\n\n  rotateRight(pivot) {\n    let root = pivot.left;\n    pivot.left = root.right;\n\n    if (root.right !== null) {\n      root.right.parent = pivot;\n    }\n\n    root.parent = pivot.parent;\n\n    if (root.parent === null) {\n      this.root = root;\n    } else if (pivot.isLeftChild) {\n      root.parent.left = root;\n    } else {\n      root.parent.right = root;\n    }\n\n    root.right = pivot;\n    pivot.parent = root;\n    pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);\n    root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);\n  }\n\n  *[Symbol.iterator]() {\n    for (let iter of this.getIterator()) {\n      yield iter;\n    }\n  }\n\n  *getIterator(key = null) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key) || key === null && !currentNode.left) {\n        break;\n      }\n\n      if (this.isLessThan(key, currentNode.key) || key === null) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    let fromleft = true;\n\n    for (;;) {\n      if (fromleft) {\n        yield [currentNode.key, currentNode.value];\n        fromleft = false;\n\n        if (currentNode.right) {\n          currentNode = currentNode.right;\n\n          while (currentNode.left) {\n            currentNode = currentNode.left;\n          }\n\n          fromleft = true;\n        } else if (currentNode.parent) {\n          fromleft = currentNode.parent.left === currentNode;\n          currentNode = currentNode.parent;\n        } else {\n          break;\n        }\n      } else if (currentNode.parent) {\n        fromleft = currentNode.parent.left === currentNode;\n        currentNode = currentNode.parent;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n  *getReverseIterator(key = null) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key) || key === null && !currentNode.right) {\n        break;\n      }\n\n      if (!this.isLessThan(key, currentNode.key) || key === null) {\n        currentNode = currentNode.right;\n      } else {\n        currentNode = currentNode.left;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    let fromright = true;\n\n    for (;;) {\n      if (fromright) {\n        yield [currentNode.key, currentNode.value];\n        fromright = false;\n\n        if (currentNode.left) {\n          currentNode = currentNode.left;\n\n          while (currentNode.right) {\n            currentNode = currentNode.right;\n          }\n\n          fromright = true;\n        } else if (currentNode.parent) {\n          fromright = currentNode.parent.right === currentNode;\n          currentNode = currentNode.parent;\n        } else {\n          break;\n        }\n      } else if (currentNode.parent) {\n        fromright = currentNode.parent.right === currentNode;\n        currentNode = currentNode.parent;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nexports.TreeMap = TreeMap;","map":{"version":3,"sources":["C:/Users/Usuario/Downloads/Twilio/node_modules/twilio-sync/lib/utils/tree.js"],"names":["Object","defineProperty","exports","value","TreeMap","Node","constructor","key","balanceFactor","parent","left","right","isRoot","isLeaf","isLeftChild","update","replace","target","replacement","less","equal","isLessThan","x","y","isEqual","root","count","size","clear","set","node","getNode","insert","currNode","prevBalanceFactor","Math","abs","rebalance","get","currentNode","delete","child","maxLeft","mlParent","mlLeft","rotateRight","rotateLeft","pivot","min","max","Symbol","iterator","iter","getIterator","fromleft","getReverseIterator","fromright"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TreeMap = void 0;\nclass Node {\n    constructor(key, value) {\n        this.balanceFactor = 0;\n        this.key = key;\n        this.value = value;\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n    get isRoot() { return this.parent === null; }\n    get isLeaf() { return (this.left === null) && (this.right === null); }\n    get isLeftChild() { return this.parent.left === this; }\n    update(value) {\n        this.value = value;\n    }\n    replace(target, replacement) {\n        if (!target) {\n            return;\n        }\n        if (this.left === replacement) {\n            this.left = replacement;\n        }\n        else if (this.right === replacement) {\n            this.right = replacement;\n        }\n    }\n}\n/**\n * @property length\n */\nclass TreeMap {\n    constructor(less, equal) {\n        this.isLessThan = less || ((x, y) => x < y);\n        this.isEqual = equal || ((x, y) => x === y);\n        this.root = null;\n        this.count = null;\n    }\n    get size() { return this.count; }\n    clear() {\n        this.root = null;\n        this.count = 0;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            node.update(value);\n        }\n        else {\n            this.insert(key, value);\n        }\n        // return node;\n    }\n    insert(key, value) {\n        let node = new Node(key, value);\n        this.count++;\n        if (!this.root) {\n            this.root = node;\n            // return node;\n            return;\n        }\n        let currNode = this.root;\n        for (;;) {\n            if (this.isLessThan(key, currNode.key)) {\n                if (currNode.left) {\n                    currNode = currNode.left;\n                }\n                else {\n                    currNode.left = node;\n                    break;\n                }\n            }\n            else {\n                if (currNode.right) { // eslint-disable-line no-lonely-if\n                    currNode = currNode.right;\n                }\n                else {\n                    currNode.right = node;\n                    break;\n                }\n            }\n        }\n        node.parent = currNode;\n        currNode = node;\n        while (currNode.parent) {\n            let parent = currNode.parent;\n            let prevBalanceFactor = parent.balanceFactor;\n            if (currNode.isLeftChild) {\n                parent.balanceFactor++;\n            }\n            else {\n                parent.balanceFactor--;\n            }\n            if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {\n                break;\n            }\n            if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n                this.rebalance(parent);\n                break;\n            }\n            currNode = parent;\n        }\n        // return node;\n    }\n    get(key) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key)) {\n                return currentNode.value;\n            }\n            if (this.isLessThan(key, currentNode.key)) {\n                currentNode = currentNode.left;\n            }\n            else {\n                currentNode = currentNode.right;\n            }\n        }\n        return null;\n    }\n    delete(key) {\n        // update this algorithm and remove any\n        let node = this.getNode(key);\n        if (!node || node.key !== key) {\n            return null;\n        }\n        let parent = node.parent;\n        let left = node.left;\n        let right = node.right;\n        if (!!left !== !!right) { // one child\n            let child = left || right;\n            if (!parent && !child) {\n                this.root = null;\n            }\n            else if (parent && !child) {\n                this.root = child;\n            }\n            else {\n                parent.replace(node, null);\n                this.rebalance(parent);\n            }\n        }\n        else { // two children\n            let maxLeft = node.left;\n            while (maxLeft.right) {\n                maxLeft = maxLeft.right;\n            }\n            if (node.left === maxLeft) {\n                if (node.isRoot) {\n                    this.root = maxLeft;\n                    maxLeft.parent = null;\n                }\n                else {\n                    if (node.isLeftChild) {\n                        node.parent.left = maxLeft;\n                    }\n                    else {\n                        node.parent.right = maxLeft;\n                    }\n                    maxLeft.parent = node.parent;\n                }\n                maxLeft.right = node.right;\n                maxLeft.right.parent = maxLeft;\n                maxLeft.balanceFactor = node.balanceFactor;\n                node = {\n                    parent: maxLeft, isLeftChild: true\n                };\n            }\n            else {\n                let mlParent = maxLeft.parent;\n                let mlLeft = maxLeft.left;\n                mlParent.right = mlLeft;\n                if (mlLeft) {\n                    mlLeft.parent = mlParent;\n                }\n                if (node.isRoot) {\n                    this.root = maxLeft;\n                    maxLeft.parent = null;\n                }\n                else {\n                    if (node.isLeftChild) {\n                        node.parent.left = maxLeft;\n                    }\n                    else {\n                        node.parent.right = maxLeft;\n                    }\n                    maxLeft.parent = node.parent;\n                }\n                maxLeft.right = node.right;\n                maxLeft.right.parent = maxLeft;\n                maxLeft.left = node.left;\n                maxLeft.left.parent = maxLeft;\n                maxLeft.balanceFactor = node.balanceFactor;\n                node = {\n                    parent: mlParent, isLeftChild: false\n                };\n            }\n        }\n        this.count--;\n        while (node.parent) {\n            let parent = node.parent;\n            let prevBalanceFactor = parent.balanceFactor;\n            if (node.isLeftChild) {\n                parent.balanceFactor -= 1;\n            }\n            else {\n                parent.balanceFactor += 1;\n            }\n            if (Math.abs(parent.balanceFactor) > Math.abs(prevBalanceFactor)) {\n                if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n                    this.rebalance(parent);\n                    if (parent.parent.balanceFactor === 0) {\n                        node = parent.parent;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                node = parent;\n            }\n        }\n        return null;\n    }\n    getNode(key) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key)) {\n                return currentNode;\n            }\n            if (this.isLessThan(key, currentNode.key)) {\n                currentNode = currentNode.left;\n            }\n            else {\n                currentNode = currentNode.right;\n            }\n        }\n        return null;\n    }\n    rebalance(node) {\n        if (node.balanceFactor < 0) {\n            if (node.right.balanceFactor > 0) {\n                this.rotateRight(node.right);\n                this.rotateLeft(node);\n            }\n            else {\n                this.rotateLeft(node);\n            }\n        }\n        else if (node.balanceFactor > 0) {\n            if (node.left.balanceFactor < 0) {\n                this.rotateLeft(node.left);\n                this.rotateRight(node);\n            }\n            else {\n                this.rotateRight(node);\n            }\n        }\n    }\n    rotateLeft(pivot) {\n        let root = pivot.right;\n        pivot.right = root.left;\n        if (root.left !== null) {\n            root.left.parent = pivot;\n        }\n        root.parent = pivot.parent;\n        if (root.parent === null) {\n            this.root = root;\n        }\n        else if (pivot.isLeftChild) {\n            root.parent.left = root;\n        }\n        else {\n            root.parent.right = root;\n        }\n        root.left = pivot;\n        pivot.parent = root;\n        pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);\n        root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);\n    }\n    rotateRight(pivot) {\n        let root = pivot.left;\n        pivot.left = root.right;\n        if (root.right !== null) {\n            root.right.parent = pivot;\n        }\n        root.parent = pivot.parent;\n        if (root.parent === null) {\n            this.root = root;\n        }\n        else if (pivot.isLeftChild) {\n            root.parent.left = root;\n        }\n        else {\n            root.parent.right = root;\n        }\n        root.right = pivot;\n        pivot.parent = root;\n        pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);\n        root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);\n    }\n    *[Symbol.iterator]() {\n        for (let iter of this.getIterator()) {\n            yield iter;\n        }\n    }\n    *getIterator(key = null) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key) || ((key === null) && !currentNode.left)) {\n                break;\n            }\n            if (this.isLessThan(key, currentNode.key) || (key === null)) {\n                currentNode = currentNode.left;\n            }\n            else {\n                currentNode = currentNode.right;\n            }\n        }\n        if (!currentNode) {\n            return null;\n        }\n        let fromleft = true;\n        for (;;) {\n            if (fromleft) {\n                yield [currentNode.key, currentNode.value];\n                fromleft = false;\n                if (currentNode.right) {\n                    currentNode = currentNode.right;\n                    while (currentNode.left) {\n                        currentNode = currentNode.left;\n                    }\n                    fromleft = true;\n                }\n                else if (currentNode.parent) {\n                    fromleft = (currentNode.parent.left === currentNode);\n                    currentNode = currentNode.parent;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (currentNode.parent) {\n                fromleft = (currentNode.parent.left === currentNode);\n                currentNode = currentNode.parent;\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    }\n    *getReverseIterator(key = null) {\n        let currentNode = this.root;\n        while (currentNode) {\n            if (this.isEqual(key, currentNode.key) || ((key === null) && !currentNode.right)) {\n                break;\n            }\n            if (!this.isLessThan(key, currentNode.key) || (key === null)) {\n                currentNode = currentNode.right;\n            }\n            else {\n                currentNode = currentNode.left;\n            }\n        }\n        if (!currentNode) {\n            return null;\n        }\n        let fromright = true;\n        for (;;) {\n            if (fromright) {\n                yield [currentNode.key, currentNode.value];\n                fromright = false;\n                if (currentNode.left) {\n                    currentNode = currentNode.left;\n                    while (currentNode.right) {\n                        currentNode = currentNode.right;\n                    }\n                    fromright = true;\n                }\n                else if (currentNode.parent) {\n                    fromright = (currentNode.parent.right === currentNode);\n                    currentNode = currentNode.parent;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (currentNode.parent) {\n                fromright = (currentNode.parent.right === currentNode);\n                currentNode = currentNode.parent;\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    }\n}\nexports.TreeMap = TreeMap;\n"]},"metadata":{},"sourceType":"script"}