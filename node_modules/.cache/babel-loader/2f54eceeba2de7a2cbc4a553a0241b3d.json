{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pointer = void 0;\n/**\r\nUnescape token part of a JSON Pointer string\r\n\r\n`token` should *not* contain any '/' characters.\r\n\r\n> Evaluation of each reference token begins by decoding any escaped\r\n> character sequence.  This is performed by first transforming any\r\n> occurrence of the sequence '~1' to '/', and then transforming any\r\n> occurrence of the sequence '~0' to '~'.  By performing the\r\n> substitutions in this order, an implementation avoids the error of\r\n> turning '~01' first into '~1' and then into '/', which would be\r\n> incorrect (the string '~01' correctly becomes '~1' after\r\n> transformation).\r\n\r\nHere's my take:\r\n\r\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\r\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\r\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\r\n*/\n\nfunction unescape(token) {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Escape token part of a JSON Pointer string\r\n\r\n> '~' needs to be encoded as '~0' and '/'\r\n> needs to be encoded as '~1' when these characters appear in a\r\n> reference token.\r\n\r\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\r\n*/\n\n\nfunction escape(token) {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\r\nJSON Pointer representation\r\n*/\n\n\nvar Pointer =\n/** @class */\nfunction () {\n  function Pointer(tokens) {\n    if (tokens === void 0) {\n      tokens = [''];\n    }\n\n    this.tokens = tokens;\n  }\n  /**\r\n  `path` *must* be a properly escaped string.\r\n  */\n\n\n  Pointer.fromJSON = function (path) {\n    var tokens = path.split('/').map(unescape);\n    if (tokens[0] !== '') throw new Error(\"Invalid JSON Pointer: \" + path);\n    return new Pointer(tokens);\n  };\n\n  Pointer.prototype.toString = function () {\n    return this.tokens.map(escape).join('/');\n  };\n  /**\r\n  Returns an object with 'parent', 'key', and 'value' properties.\r\n  In the special case that this Pointer's path == \"\",\r\n  this object will be {parent: null, key: '', value: object}.\r\n  Otherwise, parent and key will have the property such that parent[key] == value.\r\n  */\n\n\n  Pointer.prototype.evaluate = function (object) {\n    var parent = null;\n    var key = '';\n    var value = object;\n\n    for (var i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value;\n      key = this.tokens[i]; // not sure if this the best way to handle non-existant paths...\n\n      value = (parent || {})[key];\n    }\n\n    return {\n      parent: parent,\n      key: key,\n      value: value\n    };\n  };\n\n  Pointer.prototype.get = function (object) {\n    return this.evaluate(object).value;\n  };\n\n  Pointer.prototype.set = function (object, value) {\n    var cursor = object;\n\n    for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token];\n    }\n\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value;\n    }\n  };\n\n  Pointer.prototype.push = function (token) {\n    // mutable\n    this.tokens.push(token);\n  };\n  /**\r\n  `token` should be a String. It'll be coerced to one anyway.\r\n      immutable (shallowly)\r\n  */\n\n\n  Pointer.prototype.add = function (token) {\n    var tokens = this.tokens.concat(String(token));\n    return new Pointer(tokens);\n  };\n\n  return Pointer;\n}();\n\nexports.Pointer = Pointer;","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/rfc6902/pointer.js"],"names":["Object","defineProperty","exports","value","Pointer","unescape","token","replace","escape","tokens","fromJSON","path","split","map","Error","prototype","toString","join","evaluate","object","parent","key","i","l","length","get","set","cursor","push","add","concat","String"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;AACrB,SAAOA,KAAK,CAACC,OAAN,CAAc,KAAd,EAAqB,GAArB,EAA0BA,OAA1B,CAAkC,KAAlC,EAAyC,GAAzC,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,MAAT,CAAgBF,KAAhB,EAAuB;AACnB,SAAOA,KAAK,CAACC,OAAN,CAAc,IAAd,EAAoB,IAApB,EAA0BA,OAA1B,CAAkC,KAAlC,EAAyC,IAAzC,CAAP;AACH;AACD;AACA;AACA;;;AACA,IAAIH,OAAO;AAAG;AAAe,YAAY;AACrC,WAASA,OAAT,CAAiBK,MAAjB,EAAyB;AACrB,QAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,CAAC,EAAD,CAAT;AAAgB;;AACzC,SAAKA,MAAL,GAAcA,MAAd;AACH;AACD;AACJ;AACA;;;AACIL,EAAAA,OAAO,CAACM,QAAR,GAAmB,UAAUC,IAAV,EAAgB;AAC/B,QAAIF,MAAM,GAAGE,IAAI,CAACC,KAAL,CAAW,GAAX,EAAgBC,GAAhB,CAAoBR,QAApB,CAAb;AACA,QAAII,MAAM,CAAC,CAAD,CAAN,KAAc,EAAlB,EACI,MAAM,IAAIK,KAAJ,CAAU,2BAA2BH,IAArC,CAAN;AACJ,WAAO,IAAIP,OAAJ,CAAYK,MAAZ,CAAP;AACH,GALD;;AAMAL,EAAAA,OAAO,CAACW,SAAR,CAAkBC,QAAlB,GAA6B,YAAY;AACrC,WAAO,KAAKP,MAAL,CAAYI,GAAZ,CAAgBL,MAAhB,EAAwBS,IAAxB,CAA6B,GAA7B,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACIb,EAAAA,OAAO,CAACW,SAAR,CAAkBG,QAAlB,GAA6B,UAAUC,MAAV,EAAkB;AAC3C,QAAIC,MAAM,GAAG,IAAb;AACA,QAAIC,GAAG,GAAG,EAAV;AACA,QAAIlB,KAAK,GAAGgB,MAAZ;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKd,MAAL,CAAYe,MAAhC,EAAwCF,CAAC,GAAGC,CAA5C,EAA+CD,CAAC,EAAhD,EAAoD;AAChDF,MAAAA,MAAM,GAAGjB,KAAT;AACAkB,MAAAA,GAAG,GAAG,KAAKZ,MAAL,CAAYa,CAAZ,CAAN,CAFgD,CAGhD;;AACAnB,MAAAA,KAAK,GAAG,CAACiB,MAAM,IAAI,EAAX,EAAeC,GAAf,CAAR;AACH;;AACD,WAAO;AAAED,MAAAA,MAAM,EAAEA,MAAV;AAAkBC,MAAAA,GAAG,EAAEA,GAAvB;AAA4BlB,MAAAA,KAAK,EAAEA;AAAnC,KAAP;AACH,GAXD;;AAYAC,EAAAA,OAAO,CAACW,SAAR,CAAkBU,GAAlB,GAAwB,UAAUN,MAAV,EAAkB;AACtC,WAAO,KAAKD,QAAL,CAAcC,MAAd,EAAsBhB,KAA7B;AACH,GAFD;;AAGAC,EAAAA,OAAO,CAACW,SAAR,CAAkBW,GAAlB,GAAwB,UAAUP,MAAV,EAAkBhB,KAAlB,EAAyB;AAC7C,QAAIwB,MAAM,GAAGR,MAAb;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKd,MAAL,CAAYe,MAAZ,GAAqB,CAApC,EAAuClB,KAAK,GAAG,KAAKG,MAAL,CAAYa,CAAZ,CAApD,EAAoEA,CAAC,GAAGC,CAAxE,EAA2ED,CAAC,EAA5E,EAAgF;AAC5E;AACAK,MAAAA,MAAM,GAAG,CAACA,MAAM,IAAI,EAAX,EAAerB,KAAf,CAAT;AACH;;AACD,QAAIqB,MAAJ,EAAY;AACRA,MAAAA,MAAM,CAAC,KAAKlB,MAAL,CAAY,KAAKA,MAAL,CAAYe,MAAZ,GAAqB,CAAjC,CAAD,CAAN,GAA8CrB,KAA9C;AACH;AACJ,GATD;;AAUAC,EAAAA,OAAO,CAACW,SAAR,CAAkBa,IAAlB,GAAyB,UAAUtB,KAAV,EAAiB;AACtC;AACA,SAAKG,MAAL,CAAYmB,IAAZ,CAAiBtB,KAAjB;AACH,GAHD;AAIA;AACJ;AACA;AACA;;;AAEIF,EAAAA,OAAO,CAACW,SAAR,CAAkBc,GAAlB,GAAwB,UAAUvB,KAAV,EAAiB;AACrC,QAAIG,MAAM,GAAG,KAAKA,MAAL,CAAYqB,MAAZ,CAAmBC,MAAM,CAACzB,KAAD,CAAzB,CAAb;AACA,WAAO,IAAIF,OAAJ,CAAYK,MAAZ,CAAP;AACH,GAHD;;AAIA,SAAOL,OAAP;AACH,CA9D4B,EAA7B;;AA+DAF,OAAO,CAACE,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Pointer = void 0;\r\n/**\r\nUnescape token part of a JSON Pointer string\r\n\r\n`token` should *not* contain any '/' characters.\r\n\r\n> Evaluation of each reference token begins by decoding any escaped\r\n> character sequence.  This is performed by first transforming any\r\n> occurrence of the sequence '~1' to '/', and then transforming any\r\n> occurrence of the sequence '~0' to '~'.  By performing the\r\n> substitutions in this order, an implementation avoids the error of\r\n> turning '~01' first into '~1' and then into '/', which would be\r\n> incorrect (the string '~01' correctly becomes '~1' after\r\n> transformation).\r\n\r\nHere's my take:\r\n\r\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\r\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\r\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\r\n*/\r\nfunction unescape(token) {\r\n    return token.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\n/** Escape token part of a JSON Pointer string\r\n\r\n> '~' needs to be encoded as '~0' and '/'\r\n> needs to be encoded as '~1' when these characters appear in a\r\n> reference token.\r\n\r\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\r\n*/\r\nfunction escape(token) {\r\n    return token.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\n/**\r\nJSON Pointer representation\r\n*/\r\nvar Pointer = /** @class */ (function () {\r\n    function Pointer(tokens) {\r\n        if (tokens === void 0) { tokens = ['']; }\r\n        this.tokens = tokens;\r\n    }\r\n    /**\r\n    `path` *must* be a properly escaped string.\r\n    */\r\n    Pointer.fromJSON = function (path) {\r\n        var tokens = path.split('/').map(unescape);\r\n        if (tokens[0] !== '')\r\n            throw new Error(\"Invalid JSON Pointer: \" + path);\r\n        return new Pointer(tokens);\r\n    };\r\n    Pointer.prototype.toString = function () {\r\n        return this.tokens.map(escape).join('/');\r\n    };\r\n    /**\r\n    Returns an object with 'parent', 'key', and 'value' properties.\r\n    In the special case that this Pointer's path == \"\",\r\n    this object will be {parent: null, key: '', value: object}.\r\n    Otherwise, parent and key will have the property such that parent[key] == value.\r\n    */\r\n    Pointer.prototype.evaluate = function (object) {\r\n        var parent = null;\r\n        var key = '';\r\n        var value = object;\r\n        for (var i = 1, l = this.tokens.length; i < l; i++) {\r\n            parent = value;\r\n            key = this.tokens[i];\r\n            // not sure if this the best way to handle non-existant paths...\r\n            value = (parent || {})[key];\r\n        }\r\n        return { parent: parent, key: key, value: value };\r\n    };\r\n    Pointer.prototype.get = function (object) {\r\n        return this.evaluate(object).value;\r\n    };\r\n    Pointer.prototype.set = function (object, value) {\r\n        var cursor = object;\r\n        for (var i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\r\n            // not sure if this the best way to handle non-existant paths...\r\n            cursor = (cursor || {})[token];\r\n        }\r\n        if (cursor) {\r\n            cursor[this.tokens[this.tokens.length - 1]] = value;\r\n        }\r\n    };\r\n    Pointer.prototype.push = function (token) {\r\n        // mutable\r\n        this.tokens.push(token);\r\n    };\r\n    /**\r\n    `token` should be a String. It'll be coerced to one anyway.\r\n  \r\n    immutable (shallowly)\r\n    */\r\n    Pointer.prototype.add = function (token) {\r\n        var tokens = this.tokens.concat(String(token));\r\n        return new Pointer(tokens);\r\n    };\r\n    return Pointer;\r\n}());\r\nexports.Pointer = Pointer;\r\n"]},"metadata":{},"sourceType":"script"}