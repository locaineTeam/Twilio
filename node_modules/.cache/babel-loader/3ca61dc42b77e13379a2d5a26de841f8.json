{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar util = require('../../');\n\nvar getMediaSections = require('../').getMediaSections; // NOTE(mroberts): OrderedTrackMatcher is meant to solve the problem identified in\n//\n//   https://bugs.webkit.org/show_bug.cgi?id=174519\n//\n// Namely that, without MIDs, we cannot \"correctly\" identify MediaStreamTracks\n// in Safari's current WebRTC implementation. So, this module tries to hack\n// around this by making a possibly dangerous assumption: \"track\" events will\n// be raised for MediaStreamTracks of a particular kind in the same order that\n// those kinds' MSIDs appear in the SDP. By calling `update` with an\n// RTCPeerConnection's `remoteDescription` and then invoking `match`, we ought\n// to be able to dequeue MediaStreamTrack IDs in the correct order to be\n// assigned to \"track\" events.\n\n/**\r\n * @interface MatchedAndUnmatched\r\n * @property {Set<Track.ID>} matched\r\n * @property {Set<Track.ID>} unmatched\r\n */\n\n/**\r\n * Create a new instance of {@link MatchedAndUnmatched}.\r\n * @returns {MatchedAndUnmatched}\r\n */\n\n\nfunction create() {\n  return {\n    matched: new Set(),\n    unmatched: new Set()\n  };\n}\n/**\r\n * Attempt to match a MediaStreamTrack ID.\r\n * @param {MatchedAndUnmatched} mAndM\r\n * @returns {?Track.ID} id\r\n */\n\n\nfunction _match(mAndM) {\n  var unmatched = Array.from(mAndM.unmatched);\n\n  if (!unmatched.length) {\n    return null;\n  }\n\n  var id = unmatched[0];\n  mAndM.matched.add(id);\n  mAndM.unmatched.delete(id);\n  return id;\n}\n/**\r\n * Update a {@link MatchedAndUnmatched}'s MediaStreamTrack IDs.\r\n * @param {MatchedAndUnmatched} mAndM\r\n * @param {Set<Track.ID>} ids\r\n * @returns {void}\r\n */\n\n\nfunction _update(mAndM, ids) {\n  ids = new Set(ids);\n  var removedMatchedIds = util.difference(mAndM.matched, ids);\n  removedMatchedIds.forEach(mAndM.matched.delete, mAndM.matched);\n  mAndM.unmatched = util.difference(ids, mAndM.matched);\n}\n/**\r\n * Parse MediaStreamTrack IDs of a particular kind from an SDP.\r\n * @param {string} kind\r\n * @param {string} sdp\r\n * @returns {Set<Track.ID>} ids\r\n */\n\n\nfunction parse(kind, sdp) {\n  var mediaSections = getMediaSections(sdp, kind);\n  var pattern = 'msid: ?(.+) +(.+) ?$';\n  return new Set(util.flatMap(mediaSections, function (mediaSection) {\n    return mediaSection.match(new RegExp(pattern, 'mg')) || [];\n  }).map(function (msid) {\n    return msid.match(new RegExp(pattern))[2];\n  }));\n}\n/**\r\n * A {@link OrderedTrackMatcher} is used to match RTCTrackEvents.\r\n * @property {MatchedAndUnmatched} audio\r\n * @property {MatchedAndUnmatched} video\r\n */\n\n\nvar OrderedTrackMatcher = function () {\n  function OrderedTrackMatcher() {\n    _classCallCheck(this, OrderedTrackMatcher);\n\n    if (!(this instanceof OrderedTrackMatcher)) {\n      return new OrderedTrackMatcher();\n    }\n\n    Object.defineProperties(this, {\n      audio: {\n        enumerable: true,\n        value: create()\n      },\n      video: {\n        enumerable: true,\n        value: create()\n      }\n    });\n  }\n  /**\r\n   * Attempt to match a new MediaStreamTrack ID.\r\n   * @param {RTCTrackEvent} event\r\n   * @returns {?Track.ID} id\r\n   */\n\n\n  _createClass(OrderedTrackMatcher, [{\n    key: 'match',\n    value: function match(event) {\n      return _match(this[event.track.kind]);\n    }\n    /**\r\n     * Update the {@link OrderedTrackMatcher} with a new SDP.\r\n     * @param {string} sdp\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(sdp) {\n      ['audio', 'video'].forEach(function (kind) {\n        _update(this[kind], parse(kind, sdp));\n      }, this);\n    }\n  }]);\n\n  return OrderedTrackMatcher;\n}();\n\nmodule.exports = OrderedTrackMatcher;","map":{"version":3,"sources":["C:/Users/Usuario/Downloads/Twilio/node_modules/twilio-video/es5/util/sdp/trackmatcher/ordered.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","util","require","getMediaSections","create","matched","Set","unmatched","_match","mAndM","Array","from","id","add","delete","_update","ids","removedMatchedIds","difference","forEach","parse","kind","sdp","mediaSections","pattern","flatMap","mediaSection","match","RegExp","map","msid","OrderedTrackMatcher","audio","value","video","event","track","update","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar util = require('../../');\r\nvar getMediaSections = require('../').getMediaSections;\r\n\r\n// NOTE(mroberts): OrderedTrackMatcher is meant to solve the problem identified in\r\n//\r\n//   https://bugs.webkit.org/show_bug.cgi?id=174519\r\n//\r\n// Namely that, without MIDs, we cannot \"correctly\" identify MediaStreamTracks\r\n// in Safari's current WebRTC implementation. So, this module tries to hack\r\n// around this by making a possibly dangerous assumption: \"track\" events will\r\n// be raised for MediaStreamTracks of a particular kind in the same order that\r\n// those kinds' MSIDs appear in the SDP. By calling `update` with an\r\n// RTCPeerConnection's `remoteDescription` and then invoking `match`, we ought\r\n// to be able to dequeue MediaStreamTrack IDs in the correct order to be\r\n// assigned to \"track\" events.\r\n\r\n/**\r\n * @interface MatchedAndUnmatched\r\n * @property {Set<Track.ID>} matched\r\n * @property {Set<Track.ID>} unmatched\r\n */\r\n\r\n/**\r\n * Create a new instance of {@link MatchedAndUnmatched}.\r\n * @returns {MatchedAndUnmatched}\r\n */\r\nfunction create() {\r\n  return {\r\n    matched: new Set(),\r\n    unmatched: new Set()\r\n  };\r\n}\r\n\r\n/**\r\n * Attempt to match a MediaStreamTrack ID.\r\n * @param {MatchedAndUnmatched} mAndM\r\n * @returns {?Track.ID} id\r\n */\r\nfunction _match(mAndM) {\r\n  var unmatched = Array.from(mAndM.unmatched);\r\n  if (!unmatched.length) {\r\n    return null;\r\n  }\r\n  var id = unmatched[0];\r\n  mAndM.matched.add(id);\r\n  mAndM.unmatched.delete(id);\r\n  return id;\r\n}\r\n\r\n/**\r\n * Update a {@link MatchedAndUnmatched}'s MediaStreamTrack IDs.\r\n * @param {MatchedAndUnmatched} mAndM\r\n * @param {Set<Track.ID>} ids\r\n * @returns {void}\r\n */\r\nfunction _update(mAndM, ids) {\r\n  ids = new Set(ids);\r\n  var removedMatchedIds = util.difference(mAndM.matched, ids);\r\n  removedMatchedIds.forEach(mAndM.matched.delete, mAndM.matched);\r\n  mAndM.unmatched = util.difference(ids, mAndM.matched);\r\n}\r\n\r\n/**\r\n * Parse MediaStreamTrack IDs of a particular kind from an SDP.\r\n * @param {string} kind\r\n * @param {string} sdp\r\n * @returns {Set<Track.ID>} ids\r\n */\r\nfunction parse(kind, sdp) {\r\n  var mediaSections = getMediaSections(sdp, kind);\r\n  var pattern = 'msid: ?(.+) +(.+) ?$';\r\n  return new Set(util.flatMap(mediaSections, function (mediaSection) {\r\n    return mediaSection.match(new RegExp(pattern, 'mg')) || [];\r\n  }).map(function (msid) {\r\n    return msid.match(new RegExp(pattern))[2];\r\n  }));\r\n}\r\n\r\n/**\r\n * A {@link OrderedTrackMatcher} is used to match RTCTrackEvents.\r\n * @property {MatchedAndUnmatched} audio\r\n * @property {MatchedAndUnmatched} video\r\n */\r\n\r\nvar OrderedTrackMatcher = function () {\r\n  function OrderedTrackMatcher() {\r\n    _classCallCheck(this, OrderedTrackMatcher);\r\n\r\n    if (!(this instanceof OrderedTrackMatcher)) {\r\n      return new OrderedTrackMatcher();\r\n    }\r\n    Object.defineProperties(this, {\r\n      audio: {\r\n        enumerable: true,\r\n        value: create()\r\n      },\r\n      video: {\r\n        enumerable: true,\r\n        value: create()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempt to match a new MediaStreamTrack ID.\r\n   * @param {RTCTrackEvent} event\r\n   * @returns {?Track.ID} id\r\n   */\r\n\r\n\r\n  _createClass(OrderedTrackMatcher, [{\r\n    key: 'match',\r\n    value: function match(event) {\r\n      return _match(this[event.track.kind]);\r\n    }\r\n\r\n    /**\r\n     * Update the {@link OrderedTrackMatcher} with a new SDP.\r\n     * @param {string} sdp\r\n     * @returns {void}\r\n     */\r\n\r\n  }, {\r\n    key: 'update',\r\n    value: function update(sdp) {\r\n      ['audio', 'video'].forEach(function (kind) {\r\n        _update(this[kind], parse(kind, sdp));\r\n      }, this);\r\n    }\r\n  }]);\r\n\r\n  return OrderedTrackMatcher;\r\n}();\r\n\r\nmodule.exports = OrderedTrackMatcher;"]},"metadata":{},"sourceType":"script"}