{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncStreamImpl = exports.SyncStream = void 0;\n\nconst entity_1 = require(\"../entity\");\n\nconst sanitize_1 = require(\"../utils/sanitize\");\n\nconst closeable_1 = require(\"../closeable\");\n\nclass SyncStreamImpl extends entity_1.SyncEntity {\n  /**\r\n   * @private\r\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n    this.descriptor = descriptor;\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  static get type() {\n    return 'stream';\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  get type() {\n    return 'stream';\n  }\n\n  get lastEventId() {\n    return null;\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  async publishMessage(value) {\n    const requestBody = {\n      data: value\n    };\n    const response = await this.services.network.post(this.links.messages, requestBody);\n    const responseBody = response.body;\n\n    const event = this._handleMessagePublished(responseBody.sid, value, false);\n\n    return event;\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl: ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async removeStream() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n  /**\r\n   * Handle event from the server\r\n   * @private\r\n   */\n\n\n  _update(update) {\n    switch (update.type) {\n      case 'stream_message_published':\n        {\n          this._handleMessagePublished(update.message_sid, update.message_data, true);\n\n          break;\n        }\n\n      case 'stream_removed':\n        {\n          this.onRemoved(false);\n          break;\n        }\n    }\n  }\n\n  _handleMessagePublished(sid, data, remote) {\n    const event = {\n      sid: sid,\n      value: data\n    };\n    this.broadcastEventToListeners('messagePublished', {\n      message: event,\n      isLocal: !remote\n    });\n    return event;\n  }\n\n  onRemoved(isLocal) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: isLocal\n    });\n  }\n\n}\n\nexports.SyncStreamImpl = SyncStreamImpl;\n/**\r\n * @class\r\n * @alias Stream\r\n * @classdesc A Sync primitive for pub-sub messaging. Stream Messages are not persisted, exist\r\n *     only in transit, and will be dropped if (due to congestion or network anomalies) they\r\n *     cannot be delivered promptly. Use the {@link Client#stream} method to obtain a reference to a Sync Message Stream.\r\n * @property {String} sid The immutable system-assigned identifier of this stream. Never null.\r\n * @property {String} [uniqueName=null] A unique identifier optionally assigned to the stream on creation.\r\n *\r\n * @fires Stream#messagePublished\r\n * @fires Stream#removed\r\n */\n\nclass SyncStream extends closeable_1.default {\n  constructor(syncStreamImpl) {\n    super();\n    this.syncStreamImpl = syncStreamImpl;\n    this.syncStreamImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncStreamImpl.uri;\n  }\n\n  get links() {\n    return this.syncStreamImpl.links;\n  }\n\n  static get type() {\n    return SyncStreamImpl.type;\n  }\n\n  get dateExpires() {\n    return this.syncStreamImpl.dateExpires;\n  }\n\n  get type() {\n    return SyncStreamImpl.type;\n  }\n\n  get lastEventId() {\n    return null;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncStreamImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncStreamImpl.uniqueName;\n  }\n  /**\r\n   * Publish a Message to the Stream. The system will attempt delivery to all online subscribers.\r\n   * @param {Object} value The body of the dispatched message. Maximum size in serialized JSON: 4KB.\r\n   * A rate limit applies to this operation, refer to the [Sync API documentation]{@link https://www.twilio.com/docs/api/sync} for details.\r\n   * @return {Promise<StreamMessage>} A promise which resolves after the message is successfully published\r\n   *   to the Sync service. Resolves irrespective of ultimate delivery to any subscribers.\r\n   * @public\r\n   * @example\r\n   * stream.publishMessage({ x: 42, y: 123 })\r\n   *   .then(function(message) {\r\n   *     console.log('Stream publishMessage() successful, message SID:' + message.sid);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Stream publishMessage() failed', error);\r\n   *   });\r\n   */\n\n\n  async publishMessage(value) {\n    this.ensureNotClosed();\n    return this.syncStreamImpl.publishMessage(value);\n  }\n  /**\r\n   * Update the time-to-live of the stream.\r\n   * @param {Number} ttl Specifies the TTL in seconds after which the stream is subject to automatic deletion. The value 0 means infinity.\r\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n   * @public\r\n   * @example\r\n   * stream.setTtl(3600)\r\n   *   .then(function() {\r\n   *     console.log('Stream setTtl() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Stream setTtl() failed', error);\r\n   *   });\r\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncStreamImpl.setTtl(ttl);\n  }\n  /**\r\n   * Permanently delete this Stream.\r\n   * @return {Promise<void>} A promise which resolves after the Stream is successfully deleted.\r\n   * @public\r\n   * @example\r\n   * stream.removeStream()\r\n   *   .then(function() {\r\n   *     console.log('Stream removeStream() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Stream removeStream() failed', error);\r\n   *   });\r\n   */\n\n\n  async removeStream() {\n    this.ensureNotClosed();\n    return this.syncStreamImpl.removeStream();\n  }\n  /**\r\n   * Conclude work with the stream instance and remove all event listeners attached to it.\r\n   * Any subsequent operation on this object will be rejected with error.\r\n   * Other local copies of this stream will continue operating and receiving events normally.\r\n   * @public\r\n   * @example\r\n   * stream.close();\r\n   */\n\n\n  close() {\n    super.close();\n    this.syncStreamImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncStream = SyncStream;\nexports.default = SyncStream;\n/**\r\n * @class StreamMessage\r\n * @classdesc Stream Message descriptor.\r\n * @property {String} sid Contains Stream Message SID.\r\n * @property {Object} value Contains Stream Message value.\r\n */\n\n/**\r\n * Fired when a Message is published to the Stream either locally or by a remote actor.\r\n * @event Stream#messagePublished\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {StreamMessage} args.message Published message.\r\n * @param {Boolean} args.isLocal Equals 'true' if message was published by local code, 'false' otherwise.\r\n * @example\r\n * stream.on('messagePublished', function(args) {\r\n *   console.log('Stream message published');\r\n *   console.log('Message SID: ' + args.message.sid);\r\n *   console.log('Message value: ', args.message.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a stream is removed entirely, whether the remover was local or remote.\r\n * @event Stream#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if stream was removed by local code, 'false' otherwise.\r\n * @example\r\n * stream.on('removed', function(args) {\r\n *   console.log('Stream ' + stream.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilio-sync/lib/streams/syncstream.js"],"names":["Object","defineProperty","exports","value","SyncStreamImpl","SyncStream","entity_1","require","sanitize_1","closeable_1","SyncEntity","constructor","services","descriptor","removalHandler","uri","url","links","type","dateExpires","date_expires","lastEventId","indexName","undefined","queryString","sid","uniqueName","unique_name","publishMessage","requestBody","data","response","network","post","messages","responseBody","body","event","_handleMessagePublished","setTtl","ttl","validateMandatoryTtl","error","status","onRemoved","removeStream","delete","_update","update","message_sid","message_data","remote","broadcastEventToListeners","message","isLocal","_unsubscribe","default","syncStreamImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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B,SAAKwD,eAAL;AACA,WAAO,KAAKF,cAAL,CAAoB7B,cAApB,CAAmCzB,KAAnC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANoC,MAAM,CAACC,GAAD,EAAM;AACd,SAAKmB,eAAL;AACA,WAAO,KAAKF,cAAL,CAAoBlB,MAApB,CAA2BC,GAA3B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACsB,QAAZK,YAAY,GAAG;AACjB,SAAKc,eAAL;AACA,WAAO,KAAKF,cAAL,CAAoBZ,YAApB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIe,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKH,cAAL,CAAoBI,MAApB,CAA2B,KAAKC,YAAhC;AACH;;AAlGwC;;AAoG7C5D,OAAO,CAACG,UAAR,GAAqBA,UAArB;AACAH,OAAO,CAACsD,OAAR,GAAkBnD,UAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SyncStreamImpl = exports.SyncStream = void 0;\r\nconst entity_1 = require(\"../entity\");\r\nconst sanitize_1 = require(\"../utils/sanitize\");\r\nconst closeable_1 = require(\"../closeable\");\r\nclass SyncStreamImpl extends entity_1.SyncEntity {\r\n    /**\r\n     * @private\r\n     */\r\n    constructor(services, descriptor, removalHandler) {\r\n        super(services, removalHandler);\r\n        this.descriptor = descriptor;\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.descriptor.url;\r\n    }\r\n    get links() {\r\n        return this.descriptor.links;\r\n    }\r\n    static get type() {\r\n        return 'stream';\r\n    }\r\n    get dateExpires() {\r\n        return this.descriptor.date_expires;\r\n    }\r\n    get type() {\r\n        return 'stream';\r\n    }\r\n    get lastEventId() {\r\n        return null;\r\n    }\r\n    // below properties are specific to Insights only\r\n    get indexName() {\r\n        return undefined;\r\n    }\r\n    get queryString() {\r\n        return undefined;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.descriptor.sid;\r\n    }\r\n    get uniqueName() {\r\n        return this.descriptor.unique_name || null;\r\n    }\r\n    async publishMessage(value) {\r\n        const requestBody = { data: value };\r\n        const response = await this.services.network.post(this.links.messages, requestBody);\r\n        const responseBody = response.body;\r\n        const event = this._handleMessagePublished(responseBody.sid, value, false);\r\n        return event;\r\n    }\r\n    async setTtl(ttl) {\r\n        sanitize_1.validateMandatoryTtl(ttl);\r\n        try {\r\n            const requestBody = { ttl: ttl };\r\n            const response = await this.services.network.post(this.uri, requestBody);\r\n            this.descriptor.date_expires = response.body.date_expires;\r\n        }\r\n        catch (error) {\r\n            if (error.status === 404) {\r\n                this.onRemoved(false);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    async removeStream() {\r\n        await this.services.network.delete(this.uri);\r\n        this.onRemoved(true);\r\n    }\r\n    /**\r\n     * Handle event from the server\r\n     * @private\r\n     */\r\n    _update(update) {\r\n        switch (update.type) {\r\n            case 'stream_message_published': {\r\n                this._handleMessagePublished(update.message_sid, update.message_data, true);\r\n                break;\r\n            }\r\n            case 'stream_removed': {\r\n                this.onRemoved(false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    _handleMessagePublished(sid, data, remote) {\r\n        const event = {\r\n            sid: sid,\r\n            value: data\r\n        };\r\n        this.broadcastEventToListeners('messagePublished', { message: event, isLocal: !remote });\r\n        return event;\r\n    }\r\n    onRemoved(isLocal) {\r\n        this._unsubscribe();\r\n        this.removalHandler(this.type, this.sid, this.uniqueName);\r\n        this.broadcastEventToListeners('removed', { isLocal: isLocal });\r\n    }\r\n}\r\nexports.SyncStreamImpl = SyncStreamImpl;\r\n/**\r\n * @class\r\n * @alias Stream\r\n * @classdesc A Sync primitive for pub-sub messaging. Stream Messages are not persisted, exist\r\n *     only in transit, and will be dropped if (due to congestion or network anomalies) they\r\n *     cannot be delivered promptly. Use the {@link Client#stream} method to obtain a reference to a Sync Message Stream.\r\n * @property {String} sid The immutable system-assigned identifier of this stream. Never null.\r\n * @property {String} [uniqueName=null] A unique identifier optionally assigned to the stream on creation.\r\n *\r\n * @fires Stream#messagePublished\r\n * @fires Stream#removed\r\n */\r\nclass SyncStream extends closeable_1.default {\r\n    constructor(syncStreamImpl) {\r\n        super();\r\n        this.syncStreamImpl = syncStreamImpl;\r\n        this.syncStreamImpl.attach(this);\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.syncStreamImpl.uri;\r\n    }\r\n    get links() {\r\n        return this.syncStreamImpl.links;\r\n    }\r\n    static get type() {\r\n        return SyncStreamImpl.type;\r\n    }\r\n    get dateExpires() {\r\n        return this.syncStreamImpl.dateExpires;\r\n    }\r\n    get type() {\r\n        return SyncStreamImpl.type;\r\n    }\r\n    get lastEventId() {\r\n        return null;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.syncStreamImpl.sid;\r\n    }\r\n    get uniqueName() {\r\n        return this.syncStreamImpl.uniqueName;\r\n    }\r\n    /**\r\n     * Publish a Message to the Stream. The system will attempt delivery to all online subscribers.\r\n     * @param {Object} value The body of the dispatched message. Maximum size in serialized JSON: 4KB.\r\n     * A rate limit applies to this operation, refer to the [Sync API documentation]{@link https://www.twilio.com/docs/api/sync} for details.\r\n     * @return {Promise<StreamMessage>} A promise which resolves after the message is successfully published\r\n     *   to the Sync service. Resolves irrespective of ultimate delivery to any subscribers.\r\n     * @public\r\n     * @example\r\n     * stream.publishMessage({ x: 42, y: 123 })\r\n     *   .then(function(message) {\r\n     *     console.log('Stream publishMessage() successful, message SID:' + message.sid);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Stream publishMessage() failed', error);\r\n     *   });\r\n     */\r\n    async publishMessage(value) {\r\n        this.ensureNotClosed();\r\n        return this.syncStreamImpl.publishMessage(value);\r\n    }\r\n    /**\r\n     * Update the time-to-live of the stream.\r\n     * @param {Number} ttl Specifies the TTL in seconds after which the stream is subject to automatic deletion. The value 0 means infinity.\r\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n     * @public\r\n     * @example\r\n     * stream.setTtl(3600)\r\n     *   .then(function() {\r\n     *     console.log('Stream setTtl() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Stream setTtl() failed', error);\r\n     *   });\r\n     */\r\n    async setTtl(ttl) {\r\n        this.ensureNotClosed();\r\n        return this.syncStreamImpl.setTtl(ttl);\r\n    }\r\n    /**\r\n     * Permanently delete this Stream.\r\n     * @return {Promise<void>} A promise which resolves after the Stream is successfully deleted.\r\n     * @public\r\n     * @example\r\n     * stream.removeStream()\r\n     *   .then(function() {\r\n     *     console.log('Stream removeStream() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Stream removeStream() failed', error);\r\n     *   });\r\n     */\r\n    async removeStream() {\r\n        this.ensureNotClosed();\r\n        return this.syncStreamImpl.removeStream();\r\n    }\r\n    /**\r\n     * Conclude work with the stream instance and remove all event listeners attached to it.\r\n     * Any subsequent operation on this object will be rejected with error.\r\n     * Other local copies of this stream will continue operating and receiving events normally.\r\n     * @public\r\n     * @example\r\n     * stream.close();\r\n     */\r\n    close() {\r\n        super.close();\r\n        this.syncStreamImpl.detach(this.listenerUuid);\r\n    }\r\n}\r\nexports.SyncStream = SyncStream;\r\nexports.default = SyncStream;\r\n/**\r\n * @class StreamMessage\r\n * @classdesc Stream Message descriptor.\r\n * @property {String} sid Contains Stream Message SID.\r\n * @property {Object} value Contains Stream Message value.\r\n */\r\n/**\r\n * Fired when a Message is published to the Stream either locally or by a remote actor.\r\n * @event Stream#messagePublished\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {StreamMessage} args.message Published message.\r\n * @param {Boolean} args.isLocal Equals 'true' if message was published by local code, 'false' otherwise.\r\n * @example\r\n * stream.on('messagePublished', function(args) {\r\n *   console.log('Stream message published');\r\n *   console.log('Message SID: ' + args.message.sid);\r\n *   console.log('Message value: ', args.message.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a stream is removed entirely, whether the remover was local or remote.\r\n * @event Stream#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if stream was removed by local code, 'false' otherwise.\r\n * @example\r\n * stream.on('removed', function(args) {\r\n *   console.log('Stream ' + stream.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n"]},"metadata":{},"sourceType":"script"}