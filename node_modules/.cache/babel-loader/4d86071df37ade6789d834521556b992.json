{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Filter = require('../../util/filter');\n/**\r\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\r\n * {@link IceBox} via {@link IceBox#update} are compared against previously\r\n * trickled candidates and only new candidates will be returned (assuming they\r\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\r\n * @property {?string} ufrag\r\n */\n\n\nvar IceBox = function () {\n  /**\r\n   * Construct an {@link IceBox}.\r\n   */\n  function IceBox() {\n    _classCallCheck(this, IceBox);\n\n    Object.defineProperties(this, {\n      _filter: {\n        value: new Filter({\n          getKey: function getKey(iceState) {\n            return iceState.ufrag;\n          },\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\n            return a.revision <= b.revision;\n          }\n        })\n      },\n      _ufrag: {\n        writable: true,\n        value: null\n      },\n      ufrag: {\n        enumerable: true,\n        get: function get() {\n          return this._ufrag;\n        }\n      }\n    });\n  }\n  /**\r\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\r\n   * ICE candidates associated with the username fragment.\r\n   * @param {string} ufrag\r\n   * @returns {Array<RTCIceCandidateInit>}\r\n   */\n\n\n  _createClass(IceBox, [{\n    key: 'setUfrag',\n    value: function setUfrag(ufrag) {\n      this._ufrag = ufrag;\n\n      var ice = this._filter.toMap().get(ufrag);\n\n      return ice ? ice.candidates : [];\n    }\n    /**\r\n     * Update the {@link IceBox}. This method returns any new ICE candidates\r\n     * associated with the current username fragment.\r\n     * @param {object} iceState\r\n     * @returns {Array<RTCIceCandidateInit>}\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(iceState) {\n      // NOTE(mroberts): The Server sometimes does not set the candidates property.\n      iceState.candidates = iceState.candidates || [];\n\n      var oldIceState = this._filter.toMap().get(iceState.ufrag);\n\n      var oldCandidates = oldIceState ? oldIceState.candidates : [];\n      return this._filter.update(iceState) && this._ufrag === iceState.ufrag ? iceState.candidates.slice(oldCandidates.length) : [];\n    }\n  }]);\n\n  return IceBox;\n}();\n\nmodule.exports = IceBox;","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilio-video/es5/signaling/v2/icebox.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Filter","require","IceBox","_filter","value","getKey","iceState","ufrag","isLessThanOrEqualTo","a","b","revision","_ufrag","get","setUfrag","ice","toMap","candidates","update","oldIceState","oldCandidates","slice","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar Filter = require('../../util/filter');\r\n\r\n/**\r\n * An {@link IceBox} stores trickled ICE candidates. Candidates added to the\r\n * {@link IceBox} via {@link IceBox#update} are compared against previously\r\n * trickled candidates and only new candidates will be returned (assuming they\r\n * match the current ICE username fragment set by {@link IceBox#setUfrag}).\r\n * @property {?string} ufrag\r\n */\r\n\r\nvar IceBox = function () {\r\n  /**\r\n   * Construct an {@link IceBox}.\r\n   */\r\n  function IceBox() {\r\n    _classCallCheck(this, IceBox);\r\n\r\n    Object.defineProperties(this, {\r\n      _filter: {\r\n        value: new Filter({\r\n          getKey: function getKey(iceState) {\r\n            return iceState.ufrag;\r\n          },\r\n          isLessThanOrEqualTo: function isLessThanOrEqualTo(a, b) {\r\n            return a.revision <= b.revision;\r\n          }\r\n        })\r\n      },\r\n      _ufrag: {\r\n        writable: true,\r\n        value: null\r\n      },\r\n      ufrag: {\r\n        enumerable: true,\r\n        get: function get() {\r\n          return this._ufrag;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the ICE username fragment on the {@link IceBox}. This method returns any\r\n   * ICE candidates associated with the username fragment.\r\n   * @param {string} ufrag\r\n   * @returns {Array<RTCIceCandidateInit>}\r\n   */\r\n\r\n\r\n  _createClass(IceBox, [{\r\n    key: 'setUfrag',\r\n    value: function setUfrag(ufrag) {\r\n      this._ufrag = ufrag;\r\n      var ice = this._filter.toMap().get(ufrag);\r\n      return ice ? ice.candidates : [];\r\n    }\r\n\r\n    /**\r\n     * Update the {@link IceBox}. This method returns any new ICE candidates\r\n     * associated with the current username fragment.\r\n     * @param {object} iceState\r\n     * @returns {Array<RTCIceCandidateInit>}\r\n     */\r\n\r\n  }, {\r\n    key: 'update',\r\n    value: function update(iceState) {\r\n      // NOTE(mroberts): The Server sometimes does not set the candidates property.\r\n      iceState.candidates = iceState.candidates || [];\r\n      var oldIceState = this._filter.toMap().get(iceState.ufrag);\r\n      var oldCandidates = oldIceState ? oldIceState.candidates : [];\r\n      return this._filter.update(iceState) && this._ufrag === iceState.ufrag ? iceState.candidates.slice(oldCandidates.length) : [];\r\n    }\r\n  }]);\r\n\r\n  return IceBox;\r\n}();\r\n\r\nmodule.exports = IceBox;"]},"metadata":{},"sourceType":"script"}