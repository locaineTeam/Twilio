{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n/**\r\n * Retrier with backoff override capability\r\n*/\n\n\nclass BackoffRetrier extends events_1.EventEmitter {\n  constructor(options) {\n    super();\n    this.options = options ? Object.assign({}, options) : {};\n  }\n\n  get inProgress() {\n    return !!this.retrier;\n  }\n  /**\r\n   * Should be called once per attempt series to start retrier.\r\n  */\n\n\n  start() {\n    if (this.inProgress) {\n      throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n    }\n\n    this.createRetrier();\n  }\n  /**\r\n   * Should be called to stop retrier entirely.\r\n  */\n\n\n  stop() {\n    this.cleanRetrier();\n    this.newBackoff = null;\n    this.usedBackoff = null;\n  }\n  /**\r\n   * Modifies backoff for next attempt.\r\n   * Expected behavior:\r\n   * - If there was no backoff passed previously reschedulling next attempt to given backoff\r\n   * - If previous backoff was longer then ignoring this one.\r\n   * - If previous backoff was shorter then reschedulling with this one.\r\n   * With or without backoff retrier will keep growing normally.\r\n   * @param delay delay of next attempts in ms.\r\n   */\n\n\n  modifyBackoff(delay) {\n    this.newBackoff = delay;\n  }\n  /**\r\n   * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\r\n  */\n\n\n  attemptFailed() {\n    if (!this.inProgress) {\n      throw new Error('No attempt is in progress');\n    }\n\n    if (this.newBackoff) {\n      const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n\n      if (shouldUseNewBackoff) {\n        this.createRetrier();\n      } else {\n        this.retrier.failed(new Error());\n      }\n    } else {\n      this.retrier.failed(new Error());\n    }\n  }\n\n  cancel() {\n    if (this.retrier) {\n      this.retrier.cancel();\n    }\n  }\n\n  cleanRetrier() {\n    if (this.retrier) {\n      this.retrier.removeAllListeners();\n      this.retrier.cancel();\n      this.retrier = null;\n    }\n  }\n\n  getRetryPolicy() {\n    const clone = Object.assign({}, this.options);\n\n    if (this.newBackoff) {\n      clone.min = this.newBackoff;\n      clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;\n    } // As we're always skipping first attempt we should add one extra if limit is present\n\n\n    clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;\n    return clone;\n  }\n\n  createRetrier() {\n    this.cleanRetrier();\n    const retryPolicy = this.getRetryPolicy();\n    this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n    this.retrier.once('attempt', () => {\n      this.retrier.on('attempt', () => this.emit('attempt'));\n      this.retrier.failed(new Error('Skipping first attempt'));\n    });\n    this.retrier.on('failed', err => this.emit('failed', err));\n    this.usedBackoff = this.newBackoff;\n    this.newBackoff = null;\n    this.retrier.start().catch(err => {});\n  }\n\n}\n\nexports.BackoffRetrier = BackoffRetrier;","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilsock/lib/backoffretrier.js"],"names":["Object","defineProperty","exports","value","events_1","require","operation_retrier_1","BackoffRetrier","EventEmitter","constructor","options","assign","inProgress","retrier","start","Error","createRetrier","stop","cleanRetrier","newBackoff","usedBackoff","modifyBackoff","delay","attemptFailed","shouldUseNewBackoff","failed","cancel","removeAllListeners","getRetryPolicy","clone","min","max","maxAttemptsCount","undefined","retryPolicy","Retrier","once","on","emit","err","catch"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"events\");\r\nconst operation_retrier_1 = require(\"operation-retrier\");\r\n/**\r\n * Retrier with backoff override capability\r\n*/\r\nclass BackoffRetrier extends events_1.EventEmitter {\r\n    constructor(options) {\r\n        super();\r\n        this.options = options ? Object.assign({}, options) : {};\r\n    }\r\n    get inProgress() { return !!this.retrier; }\r\n    /**\r\n     * Should be called once per attempt series to start retrier.\r\n    */\r\n    start() {\r\n        if (this.inProgress) {\r\n            throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\r\n        }\r\n        this.createRetrier();\r\n    }\r\n    /**\r\n     * Should be called to stop retrier entirely.\r\n    */\r\n    stop() {\r\n        this.cleanRetrier();\r\n        this.newBackoff = null;\r\n        this.usedBackoff = null;\r\n    }\r\n    /**\r\n     * Modifies backoff for next attempt.\r\n     * Expected behavior:\r\n     * - If there was no backoff passed previously reschedulling next attempt to given backoff\r\n     * - If previous backoff was longer then ignoring this one.\r\n     * - If previous backoff was shorter then reschedulling with this one.\r\n     * With or without backoff retrier will keep growing normally.\r\n     * @param delay delay of next attempts in ms.\r\n     */\r\n    modifyBackoff(delay) {\r\n        this.newBackoff = delay;\r\n    }\r\n    /**\r\n     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\r\n    */\r\n    attemptFailed() {\r\n        if (!this.inProgress) {\r\n            throw new Error('No attempt is in progress');\r\n        }\r\n        if (this.newBackoff) {\r\n            const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\r\n            if (shouldUseNewBackoff) {\r\n                this.createRetrier();\r\n            }\r\n            else {\r\n                this.retrier.failed(new Error());\r\n            }\r\n        }\r\n        else {\r\n            this.retrier.failed(new Error());\r\n        }\r\n    }\r\n    cancel() {\r\n        if (this.retrier) {\r\n            this.retrier.cancel();\r\n        }\r\n    }\r\n    cleanRetrier() {\r\n        if (this.retrier) {\r\n            this.retrier.removeAllListeners();\r\n            this.retrier.cancel();\r\n            this.retrier = null;\r\n        }\r\n    }\r\n    getRetryPolicy() {\r\n        const clone = Object.assign({}, this.options);\r\n        if (this.newBackoff) {\r\n            clone.min = this.newBackoff;\r\n            clone.max = this.options.max && this.options.max > this.newBackoff\r\n                ? this.options.max\r\n                : this.newBackoff;\r\n        }\r\n        // As we're always skipping first attempt we should add one extra if limit is present\r\n        clone.maxAttemptsCount = this.options.maxAttemptsCount\r\n            ? this.options.maxAttemptsCount + 1\r\n            : undefined;\r\n        return clone;\r\n    }\r\n    createRetrier() {\r\n        this.cleanRetrier();\r\n        const retryPolicy = this.getRetryPolicy();\r\n        this.retrier = new operation_retrier_1.Retrier(retryPolicy);\r\n        this.retrier.once('attempt', () => {\r\n            this.retrier.on('attempt', () => this.emit('attempt'));\r\n            this.retrier.failed(new Error('Skipping first attempt'));\r\n        });\r\n        this.retrier.on('failed', err => this.emit('failed', err));\r\n        this.usedBackoff = this.newBackoff;\r\n        this.newBackoff = null;\r\n        this.retrier.start()\r\n            .catch(err => { });\r\n    }\r\n}\r\nexports.BackoffRetrier = BackoffRetrier;\r\n"]},"metadata":{},"sourceType":"script"}