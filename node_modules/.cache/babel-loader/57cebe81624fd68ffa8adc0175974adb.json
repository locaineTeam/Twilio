{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"./logger\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\n\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nconst parser_1 = require(\"./parser\");\n\nconst Messages = require(\"./protocol/messages\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst REQUEST_TIMEOUT = 30000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n/**\r\n * Makes sure that body is properly stringified\r\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nclass PacketRequest {}\n\nclass PacketResponse {}\n\nexports.PacketResponse = PacketResponse;\n\nclass PacketInterface {\n  constructor(channel, config) {\n    this.config = config;\n    this.activeRequests = new Map();\n    this.channel = channel;\n    this.channel.on('reply', reply => this.processReply(reply));\n    this.channel.on('disconnected', () => {\n      this.activeRequests.forEach(descriptor => {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n      });\n      this.activeRequests.clear();\n    });\n  }\n\n  get isConnected() {\n    return this.channel.isConnected;\n  }\n\n  processReply(reply) {\n    const request = this.activeRequests.get(reply.id);\n\n    if (request) {\n      clearTimeout(request.timeout);\n      this.activeRequests.delete(reply.id);\n\n      if (!isHttpSuccess(reply.status.code)) {\n        request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n        logger_1.log.trace('message rejected');\n      } else {\n        request.resolve(reply);\n      }\n    }\n  }\n\n  storeRequest(id, resolve, reject) {\n    let requestDescriptor = {\n      resolve: resolve,\n      reject: reject,\n      timeout: setTimeout(() => {\n        logger_1.log.trace('request', id, 'is timed out');\n        reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n      }, REQUEST_TIMEOUT)\n    };\n    this.activeRequests.set(id, requestDescriptor);\n  }\n\n  shutdown() {\n    this.activeRequests.forEach(descriptor => {\n      clearTimeout(descriptor.timeout);\n      descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n    });\n    this.activeRequests.clear();\n  }\n\n  async sendInit() {\n    logger_1.log.trace('sendInit');\n    let metadata = metadata_1.Metadata.getMetadata(this.config);\n    let message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n    let response = await this.sendWithReply(message);\n    return new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info, new Set(response.header.capabilities));\n  }\n\n  sendClose() {\n    let message = new Messages.Close(); //@todo send telemetry AnyEventsIncludingUnfinished\n\n    this.send(message);\n  }\n\n  sendWithReply(header, payload) {\n    return new Promise((resolve, reject) => {\n      let id = this.send(header, payload);\n      this.storeRequest(id, resolve, reject);\n    });\n  }\n\n  send(header, payload) {\n    header.id = header.id || `TM${uuid_1.v4()}`;\n    let message = parser_1.Parser.createPacket(header, preparePayload(payload));\n\n    try {\n      this.channel.send(message);\n      return header.id;\n    } catch (e) {\n      logger_1.log.debug('failed to send ', header, e);\n      logger_1.log.trace(e.stack);\n      throw e;\n    }\n  }\n\n}\n\nexports.PacketInterface = PacketInterface;","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilsock/lib/packetinterface.js"],"names":["Object","defineProperty","exports","value","logger_1","require","uuid_1","twilsockerror_1","twilsockreplyerror_1","parser_1","Messages","metadata_1","REQUEST_TIMEOUT","isHttpSuccess","code","preparePayload","payload","JSON","stringify","PacketRequest","PacketResponse","PacketInterface","constructor","channel","config","activeRequests","Map","on","reply","processReply","forEach","descriptor","clearTimeout","timeout","reject","TwilsockError","clear","isConnected","request","get","id","delete","status","TwilsockReplyError","log","trace","resolve","storeRequest","requestDescriptor","setTimeout","set","shutdown","sendInit","metadata","Metadata","getMetadata","message","Init","token","continuationToken","initRegistrations","tweaks","response","sendWithReply","InitReply","header","continuation_token","continuation_token_status","offline_storage","init_registrations","debug_info","Set","capabilities","sendClose","Close","send","Promise","v4","Parser","createPacket","e","debug","stack"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,uBAAD,CAA/B;;AACA,MAAMG,oBAAoB,GAAGH,OAAO,CAAC,4BAAD,CAApC;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,qBAAD,CAAxB;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMO,eAAe,GAAG,KAAxB;;AACA,SAASC,aAAT,CAAuBC,IAAvB,EAA6B;AACzB,SAAQA,IAAI,IAAI,GAAR,IAAeA,IAAI,GAAG,GAA9B;AACH;AACD;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,OAAxB,EAAiC;AAC7B,UAAQ,OAAOA,OAAf;AACI,SAAK,WAAL;AACI,aAAO,EAAP;;AACJ,SAAK,QAAL;AACI,aAAOC,IAAI,CAACC,SAAL,CAAeF,OAAf,CAAP;;AACJ;AACI,aAAOA,OAAP;AANR;AAQH;;AACD,MAAMG,aAAN,CAAoB;;AAEpB,MAAMC,cAAN,CAAqB;;AAErBlB,OAAO,CAACkB,cAAR,GAAyBA,cAAzB;;AACA,MAAMC,eAAN,CAAsB;AAClBC,EAAAA,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkB;AACzB,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,cAAL,GAAsB,IAAIC,GAAJ,EAAtB;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA,SAAKA,OAAL,CAAaI,EAAb,CAAgB,OAAhB,EAAyBC,KAAK,IAAI,KAAKC,YAAL,CAAkBD,KAAlB,CAAlC;AACA,SAAKL,OAAL,CAAaI,EAAb,CAAgB,cAAhB,EAAgC,MAAM;AAClC,WAAKF,cAAL,CAAoBK,OAApB,CAA4BC,UAAU,IAAI;AACtCC,QAAAA,YAAY,CAACD,UAAU,CAACE,OAAZ,CAAZ;AACAF,QAAAA,UAAU,CAACG,MAAX,CAAkB,IAAI3B,eAAe,CAAC4B,aAApB,CAAkC,cAAlC,CAAlB;AACH,OAHD;AAIA,WAAKV,cAAL,CAAoBW,KAApB;AACH,KAND;AAOH;;AACc,MAAXC,WAAW,GAAG;AAAE,WAAO,KAAKd,OAAL,CAAac,WAApB;AAAkC;;AACtDR,EAAAA,YAAY,CAACD,KAAD,EAAQ;AAChB,UAAMU,OAAO,GAAG,KAAKb,cAAL,CAAoBc,GAApB,CAAwBX,KAAK,CAACY,EAA9B,CAAhB;;AACA,QAAIF,OAAJ,EAAa;AACTN,MAAAA,YAAY,CAACM,OAAO,CAACL,OAAT,CAAZ;AACA,WAAKR,cAAL,CAAoBgB,MAApB,CAA2Bb,KAAK,CAACY,EAAjC;;AACA,UAAI,CAAC3B,aAAa,CAACe,KAAK,CAACc,MAAN,CAAa5B,IAAd,CAAlB,EAAuC;AACnCwB,QAAAA,OAAO,CAACJ,MAAR,CAAe,IAAI1B,oBAAoB,CAACmC,kBAAzB,CAA4C,wBAAwBf,KAAK,CAACc,MAAN,CAAaA,MAAjF,EAAyFd,KAAzF,CAAf;AACAxB,QAAAA,QAAQ,CAACwC,GAAT,CAAaC,KAAb,CAAmB,kBAAnB;AACH,OAHD,MAIK;AACDP,QAAAA,OAAO,CAACQ,OAAR,CAAgBlB,KAAhB;AACH;AACJ;AACJ;;AACDmB,EAAAA,YAAY,CAACP,EAAD,EAAKM,OAAL,EAAcZ,MAAd,EAAsB;AAC9B,QAAIc,iBAAiB,GAAG;AACpBF,MAAAA,OAAO,EAAEA,OADW;AAEpBZ,MAAAA,MAAM,EAAEA,MAFY;AAGpBD,MAAAA,OAAO,EAAEgB,UAAU,CAAC,MAAM;AACtB7C,QAAAA,QAAQ,CAACwC,GAAT,CAAaC,KAAb,CAAmB,SAAnB,EAA8BL,EAA9B,EAAkC,cAAlC;AACAN,QAAAA,MAAM,CAAC,IAAI3B,eAAe,CAAC4B,aAApB,CAAkC,gCAAgCK,EAAlE,CAAD,CAAN;AACH,OAHkB,EAGhB5B,eAHgB;AAHC,KAAxB;AAQA,SAAKa,cAAL,CAAoByB,GAApB,CAAwBV,EAAxB,EAA4BQ,iBAA5B;AACH;;AACDG,EAAAA,QAAQ,GAAG;AACP,SAAK1B,cAAL,CAAoBK,OAApB,CAA6BC,UAAD,IAAgB;AACxCC,MAAAA,YAAY,CAACD,UAAU,CAACE,OAAZ,CAAZ;AACAF,MAAAA,UAAU,CAACG,MAAX,CAAkB,IAAI3B,eAAe,CAAC4B,aAApB,CAAkC,qCAAlC,CAAlB;AACH,KAHD;AAIA,SAAKV,cAAL,CAAoBW,KAApB;AACH;;AACa,QAARgB,QAAQ,GAAG;AACbhD,IAAAA,QAAQ,CAACwC,GAAT,CAAaC,KAAb,CAAmB,UAAnB;AACA,QAAIQ,QAAQ,GAAG1C,UAAU,CAAC2C,QAAX,CAAoBC,WAApB,CAAgC,KAAK/B,MAArC,CAAf;AACA,QAAIgC,OAAO,GAAG,IAAI9C,QAAQ,CAAC+C,IAAb,CAAkB,KAAKjC,MAAL,CAAYkC,KAA9B,EAAqC,KAAKlC,MAAL,CAAYmC,iBAAjD,EAAoEN,QAApE,EAA8E,KAAK7B,MAAL,CAAYoC,iBAA1F,EAA6G,KAAKpC,MAAL,CAAYqC,MAAzH,CAAd;AACA,QAAIC,QAAQ,GAAG,MAAM,KAAKC,aAAL,CAAmBP,OAAnB,CAArB;AACA,WAAO,IAAI9C,QAAQ,CAACsD,SAAb,CAAuBF,QAAQ,CAACtB,EAAhC,EAAoCsB,QAAQ,CAACG,MAAT,CAAgBC,kBAApD,EAAwEJ,QAAQ,CAACG,MAAT,CAAgBE,yBAAxF,EAAmHL,QAAQ,CAACG,MAAT,CAAgBG,eAAnI,EAAoJN,QAAQ,CAACG,MAAT,CAAgBI,kBAApK,EAAwLP,QAAQ,CAACG,MAAT,CAAgBK,UAAxM,EAAoN,IAAIC,GAAJ,CAAQT,QAAQ,CAACG,MAAT,CAAgBO,YAAxB,CAApN,CAAP;AACH;;AACDC,EAAAA,SAAS,GAAG;AACR,QAAIjB,OAAO,GAAG,IAAI9C,QAAQ,CAACgE,KAAb,EAAd,CADQ,CAER;;AACA,SAAKC,IAAL,CAAUnB,OAAV;AACH;;AACDO,EAAAA,aAAa,CAACE,MAAD,EAASjD,OAAT,EAAkB;AAC3B,WAAO,IAAI4D,OAAJ,CAAY,CAAC9B,OAAD,EAAUZ,MAAV,KAAqB;AACpC,UAAIM,EAAE,GAAG,KAAKmC,IAAL,CAAUV,MAAV,EAAkBjD,OAAlB,CAAT;AACA,WAAK+B,YAAL,CAAkBP,EAAlB,EAAsBM,OAAtB,EAA+BZ,MAA/B;AACH,KAHM,CAAP;AAIH;;AACDyC,EAAAA,IAAI,CAACV,MAAD,EAASjD,OAAT,EAAkB;AAClBiD,IAAAA,MAAM,CAACzB,EAAP,GAAYyB,MAAM,CAACzB,EAAP,IAAc,KAAIlC,MAAM,CAACuE,EAAP,EAAY,EAA1C;AACA,QAAIrB,OAAO,GAAG/C,QAAQ,CAACqE,MAAT,CAAgBC,YAAhB,CAA6Bd,MAA7B,EAAqClD,cAAc,CAACC,OAAD,CAAnD,CAAd;;AACA,QAAI;AACA,WAAKO,OAAL,CAAaoD,IAAb,CAAkBnB,OAAlB;AACA,aAAOS,MAAM,CAACzB,EAAd;AACH,KAHD,CAIA,OAAOwC,CAAP,EAAU;AACN5E,MAAAA,QAAQ,CAACwC,GAAT,CAAaqC,KAAb,CAAmB,iBAAnB,EAAsChB,MAAtC,EAA8Ce,CAA9C;AACA5E,MAAAA,QAAQ,CAACwC,GAAT,CAAaC,KAAb,CAAmBmC,CAAC,CAACE,KAArB;AACA,YAAMF,CAAN;AACH;AACJ;;AA7EiB;;AA+EtB9E,OAAO,CAACmB,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logger_1 = require(\"./logger\");\r\nconst uuid_1 = require(\"uuid\");\r\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\r\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\r\nconst parser_1 = require(\"./parser\");\r\nconst Messages = require(\"./protocol/messages\");\r\nconst metadata_1 = require(\"./metadata\");\r\nconst REQUEST_TIMEOUT = 30000;\r\nfunction isHttpSuccess(code) {\r\n    return (code >= 200 && code < 300);\r\n}\r\n/**\r\n * Makes sure that body is properly stringified\r\n */\r\nfunction preparePayload(payload) {\r\n    switch (typeof payload) {\r\n        case 'undefined':\r\n            return '';\r\n        case 'object':\r\n            return JSON.stringify(payload);\r\n        default:\r\n            return payload;\r\n    }\r\n}\r\nclass PacketRequest {\r\n}\r\nclass PacketResponse {\r\n}\r\nexports.PacketResponse = PacketResponse;\r\nclass PacketInterface {\r\n    constructor(channel, config) {\r\n        this.config = config;\r\n        this.activeRequests = new Map();\r\n        this.channel = channel;\r\n        this.channel.on('reply', reply => this.processReply(reply));\r\n        this.channel.on('disconnected', () => {\r\n            this.activeRequests.forEach(descriptor => {\r\n                clearTimeout(descriptor.timeout);\r\n                descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\r\n            });\r\n            this.activeRequests.clear();\r\n        });\r\n    }\r\n    get isConnected() { return this.channel.isConnected; }\r\n    processReply(reply) {\r\n        const request = this.activeRequests.get(reply.id);\r\n        if (request) {\r\n            clearTimeout(request.timeout);\r\n            this.activeRequests.delete(reply.id);\r\n            if (!isHttpSuccess(reply.status.code)) {\r\n                request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\r\n                logger_1.log.trace('message rejected');\r\n            }\r\n            else {\r\n                request.resolve(reply);\r\n            }\r\n        }\r\n    }\r\n    storeRequest(id, resolve, reject) {\r\n        let requestDescriptor = {\r\n            resolve: resolve,\r\n            reject: reject,\r\n            timeout: setTimeout(() => {\r\n                logger_1.log.trace('request', id, 'is timed out');\r\n                reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\r\n            }, REQUEST_TIMEOUT)\r\n        };\r\n        this.activeRequests.set(id, requestDescriptor);\r\n    }\r\n    shutdown() {\r\n        this.activeRequests.forEach((descriptor) => {\r\n            clearTimeout(descriptor.timeout);\r\n            descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\r\n        });\r\n        this.activeRequests.clear();\r\n    }\r\n    async sendInit() {\r\n        logger_1.log.trace('sendInit');\r\n        let metadata = metadata_1.Metadata.getMetadata(this.config);\r\n        let message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\r\n        let response = await this.sendWithReply(message);\r\n        return new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info, new Set(response.header.capabilities));\r\n    }\r\n    sendClose() {\r\n        let message = new Messages.Close();\r\n        //@todo send telemetry AnyEventsIncludingUnfinished\r\n        this.send(message);\r\n    }\r\n    sendWithReply(header, payload) {\r\n        return new Promise((resolve, reject) => {\r\n            let id = this.send(header, payload);\r\n            this.storeRequest(id, resolve, reject);\r\n        });\r\n    }\r\n    send(header, payload) {\r\n        header.id = header.id || `TM${uuid_1.v4()}`;\r\n        let message = parser_1.Parser.createPacket(header, preparePayload(payload));\r\n        try {\r\n            this.channel.send(message);\r\n            return header.id;\r\n        }\r\n        catch (e) {\r\n            logger_1.log.debug('failed to send ', header, e);\r\n            logger_1.log.trace(e.stack);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.PacketInterface = PacketInterface;\r\n"]},"metadata":{},"sourceType":"script"}