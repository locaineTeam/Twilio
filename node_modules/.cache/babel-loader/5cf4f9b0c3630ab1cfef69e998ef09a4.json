{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTests = exports.createPatch = exports.applyPatch = void 0;\n\nvar pointer_1 = require(\"./pointer\");\n\nvar patch_1 = require(\"./patch\");\n\nvar diff_1 = require(\"./diff\");\n/**\r\nApply a 'application/json-patch+json'-type patch to an object.\r\n\r\n`patch` *must* be an array of operations.\r\n\r\n> Operation objects MUST have exactly one \"op\" member, whose value\r\n> indicates the operation to perform.  Its value MUST be one of \"add\",\r\n> \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are\r\n> errors.\r\n\r\nThis method mutates the target object in-place.\r\n\r\n@returns list of results, one for each operation: `null` indicated success,\r\n         otherwise, the result will be an instance of one of the Error classes:\r\n         MissingError, InvalidOperationError, or TestError.\r\n*/\n\n\nfunction applyPatch(object, patch) {\n  return patch.map(function (operation) {\n    return patch_1.apply(object, operation);\n  });\n}\n\nexports.applyPatch = applyPatch;\n\nfunction wrapVoidableDiff(diff) {\n  function wrappedDiff(input, output, ptr) {\n    var custom_patch = diff(input, output, ptr); // ensure an array is always returned\n\n    return Array.isArray(custom_patch) ? custom_patch : diff_1.diffAny(input, output, ptr, wrappedDiff);\n  }\n\n  return wrappedDiff;\n}\n/**\r\nProduce a 'application/json-patch+json'-type patch to get from one object to\r\nanother.\r\n\r\nThis does not alter `input` or `output` unless they have a property getter with\r\nside-effects (which is not a good idea anyway).\r\n\r\n`diff` is called on each pair of comparable non-primitive nodes in the\r\n`input`/`output` object trees, producing nested patches. Return `undefined`\r\nto fall back to default behaviour.\r\n\r\nReturns list of operations to perform on `input` to produce `output`.\r\n*/\n\n\nfunction createPatch(input, output, diff) {\n  var ptr = new pointer_1.Pointer(); // a new Pointer gets a default path of [''] if not specified\n\n  return (diff ? wrapVoidableDiff(diff) : diff_1.diffAny)(input, output, ptr);\n}\n\nexports.createPatch = createPatch;\n/**\r\nCreate a test operation based on `input`'s current evaluation of the JSON\r\nPointer `path`; if such a pointer cannot be resolved, returns undefined.\r\n*/\n\nfunction createTest(input, path) {\n  var endpoint = pointer_1.Pointer.fromJSON(path).evaluate(input);\n\n  if (endpoint !== undefined) {\n    return {\n      op: 'test',\n      path: path,\n      value: endpoint.value\n    };\n  }\n}\n/**\r\nProduce an 'application/json-patch+json'-type list of tests, to verify that\r\nexisting values in an object are identical to the those captured at some\r\ncheckpoint (whenever this function is called).\r\n\r\nThis does not alter `input` or `output` unless they have a property getter with\r\nside-effects (which is not a good idea anyway).\r\n\r\nReturns list of test operations.\r\n*/\n\n\nfunction createTests(input, patch) {\n  var tests = new Array();\n  patch.filter(diff_1.isDestructive).forEach(function (operation) {\n    var pathTest = createTest(input, operation.path);\n    if (pathTest) tests.push(pathTest);\n\n    if ('from' in operation) {\n      var fromTest = createTest(input, operation.from);\n      if (fromTest) tests.push(fromTest);\n    }\n  });\n  return tests;\n}\n\nexports.createTests = createTests;","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/rfc6902/index.js"],"names":["Object","defineProperty","exports","value","createTests","createPatch","applyPatch","pointer_1","require","patch_1","diff_1","object","patch","map","operation","apply","wrapVoidableDiff","diff","wrappedDiff","input","output","ptr","custom_patch","Array","isArray","diffAny","Pointer","createTest","path","endpoint","fromJSON","evaluate","undefined","op","tests","filter","isDestructive","forEach","pathTest","push","fromTest","from"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createTests = exports.createPatch = exports.applyPatch = void 0;\r\nvar pointer_1 = require(\"./pointer\");\r\nvar patch_1 = require(\"./patch\");\r\nvar diff_1 = require(\"./diff\");\r\n/**\r\nApply a 'application/json-patch+json'-type patch to an object.\r\n\r\n`patch` *must* be an array of operations.\r\n\r\n> Operation objects MUST have exactly one \"op\" member, whose value\r\n> indicates the operation to perform.  Its value MUST be one of \"add\",\r\n> \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are\r\n> errors.\r\n\r\nThis method mutates the target object in-place.\r\n\r\n@returns list of results, one for each operation: `null` indicated success,\r\n         otherwise, the result will be an instance of one of the Error classes:\r\n         MissingError, InvalidOperationError, or TestError.\r\n*/\r\nfunction applyPatch(object, patch) {\r\n    return patch.map(function (operation) { return patch_1.apply(object, operation); });\r\n}\r\nexports.applyPatch = applyPatch;\r\nfunction wrapVoidableDiff(diff) {\r\n    function wrappedDiff(input, output, ptr) {\r\n        var custom_patch = diff(input, output, ptr);\r\n        // ensure an array is always returned\r\n        return Array.isArray(custom_patch) ? custom_patch : diff_1.diffAny(input, output, ptr, wrappedDiff);\r\n    }\r\n    return wrappedDiff;\r\n}\r\n/**\r\nProduce a 'application/json-patch+json'-type patch to get from one object to\r\nanother.\r\n\r\nThis does not alter `input` or `output` unless they have a property getter with\r\nside-effects (which is not a good idea anyway).\r\n\r\n`diff` is called on each pair of comparable non-primitive nodes in the\r\n`input`/`output` object trees, producing nested patches. Return `undefined`\r\nto fall back to default behaviour.\r\n\r\nReturns list of operations to perform on `input` to produce `output`.\r\n*/\r\nfunction createPatch(input, output, diff) {\r\n    var ptr = new pointer_1.Pointer();\r\n    // a new Pointer gets a default path of [''] if not specified\r\n    return (diff ? wrapVoidableDiff(diff) : diff_1.diffAny)(input, output, ptr);\r\n}\r\nexports.createPatch = createPatch;\r\n/**\r\nCreate a test operation based on `input`'s current evaluation of the JSON\r\nPointer `path`; if such a pointer cannot be resolved, returns undefined.\r\n*/\r\nfunction createTest(input, path) {\r\n    var endpoint = pointer_1.Pointer.fromJSON(path).evaluate(input);\r\n    if (endpoint !== undefined) {\r\n        return { op: 'test', path: path, value: endpoint.value };\r\n    }\r\n}\r\n/**\r\nProduce an 'application/json-patch+json'-type list of tests, to verify that\r\nexisting values in an object are identical to the those captured at some\r\ncheckpoint (whenever this function is called).\r\n\r\nThis does not alter `input` or `output` unless they have a property getter with\r\nside-effects (which is not a good idea anyway).\r\n\r\nReturns list of test operations.\r\n*/\r\nfunction createTests(input, patch) {\r\n    var tests = new Array();\r\n    patch.filter(diff_1.isDestructive).forEach(function (operation) {\r\n        var pathTest = createTest(input, operation.path);\r\n        if (pathTest)\r\n            tests.push(pathTest);\r\n        if ('from' in operation) {\r\n            var fromTest = createTest(input, operation.from);\r\n            if (fromTest)\r\n                tests.push(fromTest);\r\n        }\r\n    });\r\n    return tests;\r\n}\r\nexports.createTests = createTests;\r\n"]},"metadata":{},"sourceType":"script"}