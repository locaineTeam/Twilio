{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst telemetry_1 = require(\"../protocol/messages/telemetry\");\n\nconst logger_1 = require(\"../logger\");\n\nclass TelemetryEventDescription {\n  constructor(title, details, start, end, type, id) {\n    this.title = title;\n    this.details = details;\n    this.start = start;\n    this.type = type;\n    this.id = id;\n    this.end = end;\n  } // Prepare telemetry event right before sending it.\n  // Convert times to relative.\n\n\n  toTelemetryEvent() {\n    // Fix dates\n    const now = new Date();\n    let actualStart = this.start;\n    let actualEnd = this.end ? this.end : now;\n\n    if (actualEnd < actualStart) {\n      let tmp = actualEnd;\n      actualEnd = actualStart;\n      actualStart = tmp;\n    } // Converting dates to relative offset from current moment in ms\n\n\n    const startOffset = actualStart.getTime() - now.getTime();\n    const endOffset = actualEnd.getTime() - now.getTime();\n    const result = new telemetry_1.TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);\n    return result;\n  }\n\n}\n\nexports.TelemetryEventDescription = TelemetryEventDescription;\nvar TelemetryPoint;\n\n(function (TelemetryPoint) {\n  TelemetryPoint[TelemetryPoint[\"Start\"] = 0] = \"Start\";\n  TelemetryPoint[TelemetryPoint[\"End\"] = 1] = \"End\";\n})(TelemetryPoint || (TelemetryPoint = {}));\n\nexports.TelemetryPoint = TelemetryPoint;\nvar EventSendingLimitation;\n\n(function (EventSendingLimitation) {\n  EventSendingLimitation[EventSendingLimitation[\"MinEventsPortion\"] = 0] = \"MinEventsPortion\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEvents\"] = 1] = \"AnyEvents\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEventsIncludingUnfinished\"] = 2] = \"AnyEventsIncludingUnfinished\";\n})(EventSendingLimitation || (EventSendingLimitation = {}));\n\nexports.EventSendingLimitation = EventSendingLimitation;\n\nclass TelemetryTracker {\n  constructor(config, packetInterface) {\n    // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n    this.minEventsPortionToSend = 50; // max events batch size to be sent in a single Telemetry message\n\n    this.maxEventsPortionToSend = 100;\n    this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\n\n    this.readyEvents = []; // events ready to send\n\n    this.hasInitializationFinished = false;\n    this._canSendTelemetry = false;\n    this.config = config;\n    this.packetInterface = packetInterface;\n  } // Keeping this private prevents the type declaration from being generated properly.\n  // Ideally, this should be private.\n\n\n  get isTelemetryEnabled() {\n    return this.config.confirmedCapabilities.has('telemetry.v1');\n  }\n\n  get canSendTelemetry() {\n    return this._canSendTelemetry && this.isTelemetryEnabled;\n  }\n\n  set canSendTelemetry(enable) {\n    logger_1.log.debug(`TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`); // We want to keep telemetry events added in advance but\n    // we need to purge events from previous connection when being disconnected\n\n    if (this._canSendTelemetry && !enable) {\n      this.pendingEvents.clear();\n      this.readyEvents = [];\n    }\n\n    this._canSendTelemetry = enable;\n\n    if (enable) {\n      this.sendTelemetry(EventSendingLimitation.AnyEvents);\n    }\n\n    if (enable && !this.hasInitializationFinished) {\n      this.hasInitializationFinished = true;\n    }\n  } // Add complete event\n\n\n  addTelemetryEvent(event) {\n    // Allow adding events before initialization.\n    if (!this.canSendTelemetry && this.hasInitializationFinished) {\n      return;\n    }\n\n    this.readyEvents.push(event);\n  } // Add incomplete event (with either starting or ending time point)\n\n\n  addPartialEvent(incompleteEvent, eventKey, point) {\n    logger_1.log.debug(`Adding ${point === TelemetryPoint.Start ? 'starting' : 'ending'} timepoint for '${eventKey}' event`);\n    let exists = this.pendingEvents.has(eventKey);\n\n    if (point === TelemetryPoint.Start) {\n      if (exists) {\n        logger_1.log.debug(`Overwriting starting point for '${eventKey}' event`);\n      }\n\n      this.pendingEvents.set(eventKey, incompleteEvent);\n    } else {\n      if (!exists) {\n        logger_1.log.info(`Could not find started event for '${eventKey}' event`);\n        return;\n      }\n\n      this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));\n      this.pendingEvents.delete(eventKey);\n    }\n  }\n\n  getTelemetryToSend(sendingLimit) {\n    if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n      return []; // Events are collected but not sent until telemetry is enabled\n    }\n\n    if (sendingLimit == EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {\n      return [];\n    }\n\n    return this.getTelemetryPortion(sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished);\n  }\n\n  getTelemetryPortion(includeUnfinished) {\n    const eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);\n    let res = this.readyEvents.splice(0, eventsPortionToSend);\n\n    if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n      this.pendingEvents.forEach((value, key) => {\n        if (res.length >= this.maxEventsPortionToSend) {\n          return; // @fixme does not end the loop early\n        }\n\n        let event = this.pendingEvents.get(key);\n        this.pendingEvents.delete(key);\n        res.push(new TelemetryEventDescription(`[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock\n        event.details, event.start, null, // Not ended, on sending will be replaced with now\n        event.type, event.id));\n      });\n    }\n\n    return res;\n  } // Merging 2 partial events:\n  //   use start.startTime & end.endTime.\n  // For other fields,\n  //   if there are values in end, use them,\n  //   else use values from start.\n\n\n  merge(start, end) {\n    return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);\n  }\n\n  sendTelemetryIfMinimalPortionCollected() {\n    this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\n  } // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n  // and telemetry.v1 capability is enabled there.\n\n\n  sendTelemetry(limit) {\n    const events = this.getTelemetryToSend(limit);\n\n    if (events.length === 0) {\n      return; // not enough telemetry data collected\n    }\n\n    try {\n      this.packetInterface.send(new telemetry_1.Telemetry(events.map(e => e.toTelemetryEvent())));\n    } catch (err) {\n      logger_1.log.debug(`Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`);\n      this.readyEvents = this.readyEvents.concat(events);\n    }\n  }\n\n}\n\nexports.TelemetryTracker = TelemetryTracker;","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilsock/lib/services/telemetrytracker.js"],"names":["Object","defineProperty","exports","value","telemetry_1","require","logger_1","TelemetryEventDescription","constructor","title","details","start","end","type","id","toTelemetryEvent","now","Date","actualStart","actualEnd","tmp","startOffset","getTime","endOffset","result","TelemetryEvent","TelemetryPoint","EventSendingLimitation","TelemetryTracker","config","packetInterface","minEventsPortionToSend","maxEventsPortionToSend","pendingEvents","Map","readyEvents","hasInitializationFinished","_canSendTelemetry","isTelemetryEnabled","confirmedCapabilities","has","canSendTelemetry","enable","log","debug","clear","sendTelemetry","AnyEvents","addTelemetryEvent","event","push","addPartialEvent","incompleteEvent","eventKey","point","Start","exists","set","info","merge","get","delete","getTelemetryToSend","sendingLimit","length","MinEventsPortion","getTelemetryPortion","AnyEventsIncludingUnfinished","includeUnfinished","eventsPortionToSend","Math","min","res","splice","forEach","key","sendTelemetryIfMinimalPortionCollected","limit","events","send","Telemetry","map","e","err","concat"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst telemetry_1 = require(\"../protocol/messages/telemetry\");\r\nconst logger_1 = require(\"../logger\");\r\nclass TelemetryEventDescription {\r\n    constructor(title, details, start, end, type, id) {\r\n        this.title = title;\r\n        this.details = details;\r\n        this.start = start;\r\n        this.type = type;\r\n        this.id = id;\r\n        this.end = end;\r\n    }\r\n    // Prepare telemetry event right before sending it.\r\n    // Convert times to relative.\r\n    toTelemetryEvent() {\r\n        // Fix dates\r\n        const now = new Date();\r\n        let actualStart = this.start;\r\n        let actualEnd = this.end ? this.end : now;\r\n        if (actualEnd < actualStart) {\r\n            let tmp = actualEnd;\r\n            actualEnd = actualStart;\r\n            actualStart = tmp;\r\n        }\r\n        // Converting dates to relative offset from current moment in ms\r\n        const startOffset = actualStart.getTime() - now.getTime();\r\n        const endOffset = actualEnd.getTime() - now.getTime();\r\n        const result = new telemetry_1.TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);\r\n        return result;\r\n    }\r\n}\r\nexports.TelemetryEventDescription = TelemetryEventDescription;\r\nvar TelemetryPoint;\r\n(function (TelemetryPoint) {\r\n    TelemetryPoint[TelemetryPoint[\"Start\"] = 0] = \"Start\";\r\n    TelemetryPoint[TelemetryPoint[\"End\"] = 1] = \"End\";\r\n})(TelemetryPoint || (TelemetryPoint = {}));\r\nexports.TelemetryPoint = TelemetryPoint;\r\nvar EventSendingLimitation;\r\n(function (EventSendingLimitation) {\r\n    EventSendingLimitation[EventSendingLimitation[\"MinEventsPortion\"] = 0] = \"MinEventsPortion\";\r\n    EventSendingLimitation[EventSendingLimitation[\"AnyEvents\"] = 1] = \"AnyEvents\";\r\n    EventSendingLimitation[EventSendingLimitation[\"AnyEventsIncludingUnfinished\"] = 2] = \"AnyEventsIncludingUnfinished\";\r\n})(EventSendingLimitation || (EventSendingLimitation = {}));\r\nexports.EventSendingLimitation = EventSendingLimitation;\r\nclass TelemetryTracker {\r\n    constructor(config, packetInterface) {\r\n        // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\r\n        this.minEventsPortionToSend = 50;\r\n        // max events batch size to be sent in a single Telemetry message\r\n        this.maxEventsPortionToSend = 100;\r\n        this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\r\n        this.readyEvents = []; // events ready to send\r\n        this.hasInitializationFinished = false;\r\n        this._canSendTelemetry = false;\r\n        this.config = config;\r\n        this.packetInterface = packetInterface;\r\n    }\r\n    // Keeping this private prevents the type declaration from being generated properly.\r\n    // Ideally, this should be private.\r\n    get isTelemetryEnabled() {\r\n        return this.config.confirmedCapabilities.has('telemetry.v1');\r\n    }\r\n    get canSendTelemetry() {\r\n        return this._canSendTelemetry && this.isTelemetryEnabled;\r\n    }\r\n    set canSendTelemetry(enable) {\r\n        logger_1.log.debug(`TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`);\r\n        // We want to keep telemetry events added in advance but\r\n        // we need to purge events from previous connection when being disconnected\r\n        if (this._canSendTelemetry && !enable) {\r\n            this.pendingEvents.clear();\r\n            this.readyEvents = [];\r\n        }\r\n        this._canSendTelemetry = enable;\r\n        if (enable) {\r\n            this.sendTelemetry(EventSendingLimitation.AnyEvents);\r\n        }\r\n        if (enable && !this.hasInitializationFinished) {\r\n            this.hasInitializationFinished = true;\r\n        }\r\n    }\r\n    // Add complete event\r\n    addTelemetryEvent(event) {\r\n        // Allow adding events before initialization.\r\n        if (!this.canSendTelemetry && this.hasInitializationFinished) {\r\n            return;\r\n        }\r\n        this.readyEvents.push(event);\r\n    }\r\n    // Add incomplete event (with either starting or ending time point)\r\n    addPartialEvent(incompleteEvent, eventKey, point) {\r\n        logger_1.log.debug(`Adding ${point === TelemetryPoint.Start ? 'starting' : 'ending'} timepoint for '${eventKey}' event`);\r\n        let exists = this.pendingEvents.has(eventKey);\r\n        if (point === TelemetryPoint.Start) {\r\n            if (exists) {\r\n                logger_1.log.debug(`Overwriting starting point for '${eventKey}' event`);\r\n            }\r\n            this.pendingEvents.set(eventKey, incompleteEvent);\r\n        }\r\n        else {\r\n            if (!exists) {\r\n                logger_1.log.info(`Could not find started event for '${eventKey}' event`);\r\n                return;\r\n            }\r\n            this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));\r\n            this.pendingEvents.delete(eventKey);\r\n        }\r\n    }\r\n    getTelemetryToSend(sendingLimit) {\r\n        if (!this.canSendTelemetry || this.readyEvents.length == 0) {\r\n            return []; // Events are collected but not sent until telemetry is enabled\r\n        }\r\n        if (sendingLimit == EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {\r\n            return [];\r\n        }\r\n        return this.getTelemetryPortion(sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished);\r\n    }\r\n    getTelemetryPortion(includeUnfinished) {\r\n        const eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);\r\n        let res = this.readyEvents.splice(0, eventsPortionToSend);\r\n        if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\r\n            this.pendingEvents.forEach((value, key) => {\r\n                if (res.length >= this.maxEventsPortionToSend) {\r\n                    return; // @fixme does not end the loop early\r\n                }\r\n                let event = this.pendingEvents.get(key);\r\n                this.pendingEvents.delete(key);\r\n                res.push(new TelemetryEventDescription(`[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock\r\n                event.details, event.start, null, // Not ended, on sending will be replaced with now\r\n                event.type, event.id));\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    // Merging 2 partial events:\r\n    //   use start.startTime & end.endTime.\r\n    // For other fields,\r\n    //   if there are values in end, use them,\r\n    //   else use values from start.\r\n    merge(start, end) {\r\n        return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);\r\n    }\r\n    sendTelemetryIfMinimalPortionCollected() {\r\n        this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\r\n    }\r\n    // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\r\n    // and telemetry.v1 capability is enabled there.\r\n    sendTelemetry(limit) {\r\n        const events = this.getTelemetryToSend(limit);\r\n        if (events.length === 0) {\r\n            return; // not enough telemetry data collected\r\n        }\r\n        try {\r\n            this.packetInterface.send(new telemetry_1.Telemetry(events.map(e => e.toTelemetryEvent())));\r\n        }\r\n        catch (err) {\r\n            logger_1.log.debug(`Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`);\r\n            this.readyEvents = this.readyEvents.concat(events);\r\n        }\r\n    }\r\n}\r\nexports.TelemetryTracker = TelemetryTracker;\r\n"]},"metadata":{},"sourceType":"script"}