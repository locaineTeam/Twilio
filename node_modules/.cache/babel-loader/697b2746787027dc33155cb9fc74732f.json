{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _require = require('../'),\n    difference = _require.difference,\n    flatMap = _require.flatMap;\n\nvar setSimulcastInMediaSection = require('./simulcast');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n/**\r\n * A payload type\r\n * @typedef {number} PT\r\n */\n\n/**\r\n * An {@link AudioCodec} or {@link VideoCodec}\r\n * @typedef {AudioCodec|VideoCodec} Codec\r\n */\n// NOTE(mmalavalli): This value is derived from the IETF spec\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\n// to a 'b=AS' value in kbps.\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\n\nvar RTCP_BITRATE = 16000;\n/**\r\n * Construct a b= line string for the given max bitrate in bps. If the modifier\r\n * is 'AS', then the max bitrate will be converted to kbps using the formula\r\n * specified in the IETF spec for JSEP mentioned above.\r\n * @param {string} modifier - 'AS' | 'TIAS'\r\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\r\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\r\n *   otherwise return the constructed b= line string\r\n */\n\nfunction createBLine(modifier, maxBitrate) {\n  if (!maxBitrate) {\n    return null;\n  }\n\n  return '\\r\\nb=' + modifier + ':' + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\n}\n/**\r\n * Create a Codec Map for the given m= section.\r\n * @param {string} section - The given m= section\r\n * @returns {Map<Codec, Array<PT>>}\r\n */\n\n\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\r\n * Create a Map of MIDs to m= sections for the given SDP.\r\n * @param {string} sdp\r\n * @returns {Map<string, string>}\r\n */\n\n\nfunction createMidToMediaSectionMap(sdp) {\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\n    var mid = getMidForMediaSection(mediaSection);\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\n  }, new Map());\n}\n/**\r\n * Create a Map from PTs to codec names for the given m= section.\r\n * @param {string} mediaSection - The given m= section.\r\n * @returns {Map<PT, Codec>} ptToCodecName\r\n */\n\n\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\r\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\r\n * @param {PT} pt\r\n * @param {string} mediaSection\r\n * @returns {?object}\r\n */\n\n\nfunction getFmtpAttributesForPt(pt, mediaSection) {\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\n  // profile parameters expressed as name/value pairs separated by \";\".\n  var fmtpRegex = new RegExp('^a=fmtp:' + pt + ' (.+)$', 'm');\n  var matches = mediaSection.match(fmtpRegex);\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\n    var _nvPair$split = nvPair.split('='),\n        _nvPair$split2 = _slicedToArray(_nvPair$split, 2),\n        name = _nvPair$split2[0],\n        value = _nvPair$split2[1];\n\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\n    return attrs;\n  }, {});\n}\n/**\r\n * Get the MID for the given m= section.\r\n * @param {string} mediaSection\r\n * @return {?string}\r\n */\n\n\nfunction getMidForMediaSection(mediaSection) {\n  // In \"a=mid:<mid>\", the regex matches <mid>.\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\n  return midMatches && midMatches[1];\n}\n/**\r\n * Get the m= sections of a particular kind and direction from an sdp.\r\n * @param {string} sdp - SDP string\r\n * @param {string} [kind] - Pattern for matching kind\r\n * @param {string} [direction] - Pattern for matching direction\r\n * @returns {Array<string>} mediaSections\r\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\r\n * Get the Codec Payload Types present in the first line of the given m= section\r\n * @param {string} section - The m= section\r\n * @returns {Array<PT>} Payload Types\r\n */\n\n\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0]; // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the Payload Types.\n\n  var matches = mLine.match(/([0-9]+)/g); // This should not happen, but in case there are no Payload Types in\n  // the m= line, return an empty array.\n\n  if (!matches) {\n    return [];\n  } // Since only the Payload Types are needed, we discard the <port>.\n\n\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n/**\r\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\r\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\r\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\r\n * @returns {Array<PT>} Reordered Payload Types\r\n */\n\n\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (_ref) {\n    var codec = _ref.codec;\n    return codec.toLowerCase();\n  });\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\r\n * Set the specified max bitrate in the given m= section.\r\n * @param {string} modifier - 'AS' | 'TIAS'\r\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\r\n * @param {string} section - m= section string\r\n * @returns {string} The updated m= section\r\n */\n\n\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\n  var bLine = createBLine(modifier, maxBitrate) || '';\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\n  var bLineMatched = section.match(bLinePattern);\n\n  if (!bLineMatched) {\n    return section.replace(/(\\r\\n)?$/, bLine + '$1');\n  }\n\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\n  maxBitrate = maxBitrate || Infinity;\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\n  return section.replace(bLinePattern, bLine);\n}\n/**\r\n * Set maximum bitrates to the media sections in a given sdp.\r\n * @param {string} sdp - sdp string\r\n * @param {string} modifier - 'AS' | 'TIAS\"\r\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\r\n *   if no limit is to be applied\r\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\r\n *   if no limit is to be applied\r\n * @returns {string} - The updated sdp string\r\n */\n\n\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Bitrate parameters should not be applied to m=application sections\n    // or to m=(audio|video) sections that do not receive media.\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\n  })).join('\\r\\n');\n}\n/**\r\n * Set the given Codec Payload Types in the first line of the given m= section.\r\n * @param {Array<PT>} payloadTypes - Payload Types\r\n * @param {string} section - Given m= section\r\n * @returns {string} - Updated m= section\r\n */\n\n\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\r\n * Return a new SDP string with the re-ordered codec preferences.\r\n * @param {string} sdp\r\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\r\n *   of audio codecs is preserved\r\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\r\n *   existing order of video codecs is preserved\r\n * @returns {string} Updated SDP string\r\n */\n\n\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\r\n * Return a new SDP string with simulcast settings.\r\n * @param {string} sdp\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\r\n * @returns {string} Updated SDP string\r\n */\n\n\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getPayloadTypesInMediaSection(section);\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\n      return vp8PayloadTypes.has(payloadType);\n    });\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\n  })).concat('').join('\\r\\n');\n}\n/**\r\n * Get the matching Payload Types in a unified plan m= section for a particular peer codec.\r\n * @param {Codec} peerCodec\r\n * @param {PT} peerPt\r\n * @param {Map<Codec, PT>} codecsToPts\r\n * @param {string} section\r\n * @param {string} peerSection\r\n * @returns {Array<PT>}\r\n */\n\n\nfunction unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\n  var matchingPts = codecsToPts.get(peerCodec) || [];\n\n  if (matchingPts.length <= 1) {\n    return matchingPts;\n  } // If there are no fmtp attributes for the codec in the peer m= section, then we\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\n  // Types.\n\n\n  var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\n\n  if (!peerFmtpAttrs) {\n    return matchingPts;\n  } // Among the matched local Payload Types, find the one that matches the remote\n  // fmtp attributes.\n\n\n  var matchingPt = matchingPts.find(function (pt) {\n    var fmtpAttrs = getFmtpAttributesForPt(pt, section);\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\n    });\n  }); // If none of the matched Payload Types also have matching fmtp attributes,\n  // then retain all of them, otherwise retain only the Payload Type that\n  // matches the peer fmtp attributes.\n\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\n}\n/**\r\n * Filter codecs in a unified plan m= section based on its peer m= section.\r\n * from the other peer.\r\n * @param {string} section\r\n * @param {Map<string, string>} peerMidsToMediaSections\r\n * @param {Array<string>} codecsToRemove\r\n * @returns {string}\r\n */\n\n\nfunction unifiedPlanFilterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\n  // Do nothing if the m= section represents neither audio nor video.\n  if (!/^m=(audio|video)/.test(section)) {\n    return section;\n  } // Do nothing if the m= section does not have an equivalent remote m= section.\n\n\n  var mid = getMidForMediaSection(section);\n  var peerSection = mid && peerMidsToMediaSections.get(mid);\n\n  if (!peerSection) {\n    return section;\n  } // Construct a Map of the peer Payload Types to their codec names.\n\n\n  var peerPtToCodecs = createPtToCodecName(peerSection); // Construct a Map of the codec names to their Payload Types.\n\n  var codecsToPts = createCodecMapForMediaSection(section); // Maintain a list of non-rtx Payload Types to retain.\n\n  var pts = flatMap(Array.from(peerPtToCodecs), function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        peerPt = _ref3[0],\n        peerCodec = _ref3[1];\n\n    return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec) ? unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) : [];\n  }); // For each Payload Type that will be retained, retain their corresponding rtx\n  // Payload Type if present.\n\n  var rtxPts = codecsToPts.get('rtx') || []; // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\n\n  pts = pts.concat(rtxPts.filter(function (rtxPt) {\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\n  })); // Filter out the below mentioned attribute lines in the m= section that do not\n  // belong to one of the Payload Types that are to be retained.\n  // 1. \"a=rtpmap:<pt> <codec>\"\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\n\n  var lines = section.split('\\r\\n').filter(function (line) {\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\n    var pt = ptMatches && ptMatches[2];\n    return !ptMatches || pt && pts.includes(parseInt(pt, 10));\n  }); // Filter the list of Payload Types in the first line of the m= section.\n\n  var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) {\n    return pts.includes(pt);\n  });\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\n}\n/**\r\n * Filter local codecs based on the remote unified plan SDP.\r\n * @param {string} localSdp\r\n * @param {string} remoteSdp\r\n * @returns {string} - Updated local SDP\r\n */\n\n\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\n  var localMediaSections = getMediaSections(localSdp);\n  var localSession = localSdp.split('\\r\\nm=')[0];\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  return [localSession].concat(localMediaSections.map(function (localSection) {\n    return unifiedPlanFilterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\n  })).join('\\r\\n');\n}\n/**\r\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\r\n * @param localSdp - simulcast enabled local sdp\r\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\r\n * @param remoteSdp - remote sdp\r\n * @return {string} Updated SDP string\r\n */\n\n\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\n  var mediaSections = getMediaSections(localSdp);\n  var session = localSdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    section = section.replace(/\\r\\n$/, '');\n\n    if (!/^m=video/.test(section)) {\n      return section;\n    }\n\n    var midMatches = section.match(/^a=mid:(.+)$/m);\n    var mid = midMatches && midMatches[1];\n\n    if (!mid) {\n      return section;\n    }\n\n    var remoteSection = remoteMidToMediaSections.get(mid);\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\n  })).concat('').join('\\r\\n');\n}\n/**\r\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\r\n * corresponding local MediaStreamTrack IDs. These can be different when previously\r\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\r\n * SDPs at all once browsers implement the latest WebRTC spec).\r\n * @param {string} sdp\r\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\r\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\r\n * @returns {string}\r\n */\n\n\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\n  // present after the m= sections for the existing MediaStreamTracks, in order\n  // of addition.\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        kind = _ref5[0],\n        trackIds = _ref5[1];\n\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\n      return !activeMidsToTrackIds.has(mid);\n    });\n    newMids.forEach(function (mid, i) {\n      return midsToTrackIds.set(mid, trackIds[i]);\n    });\n    return midsToTrackIds;\n  }, new Map());\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\n}\n/**\r\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\r\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\r\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\r\n * @param {string} sdp\r\n * @param {Map<string, Track.ID>} midsToTrackIds\r\n * @returns {string}\r\n */\n\n\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section represents neither audio nor video.\n    if (!/^m=(audio|video)/.test(mediaSection)) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\n\n\n    var mid = getMidForMediaSection(mediaSection);\n\n    if (!mid) {\n      return mediaSection;\n    } // In case there is no Track ID for the given MID in the map, do nothing.\n\n\n    var trackId = midsToTrackIds.get(mid);\n\n    if (!trackId) {\n      return mediaSection;\n    } // This shouldn't happen, but in case there is no a=msid: line, do nothing.\n\n\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\n\n    if (!attributes) {\n      return mediaSection;\n    } // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\n    // otherwise append the Track ID.\n\n\n    var _attributes$split = attributes.split(' '),\n        _attributes$split2 = _slicedToArray(_attributes$split, 2),\n        msid = _attributes$split2[0],\n        trackIdToRewrite = _attributes$split2[1];\n\n    var msidRegex = new RegExp('msid:' + msid + (trackIdToRewrite ? ' ' + trackIdToRewrite : '') + '$', 'gm');\n    return mediaSection.replace(msidRegex, 'msid:' + msid + ' ' + trackId);\n  })).join('\\r\\n');\n}\n/**\r\n * removes specified ssrc attributes from given sdp\r\n * @param {string} sdp\r\n * @param {Array<string>} ssrcAttributesToRemove\r\n * @returns {string}\r\n */\n\n\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\n  return sdp.split('\\r\\n').filter(function (line) {\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\n    });\n  }).join('\\r\\n');\n}\n/**\r\n * Disable RTX in a given sdp.\r\n * @param {string} sdp\r\n * @returns {string} sdp without RTX\r\n */\n\n\nfunction disableRtx(sdp) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (mediaSection) {\n    // Do nothing if the m= section does not represent a video track.\n    if (!/^m=video/.test(mediaSection)) {\n      return mediaSection;\n    } // Create a map of codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(mediaSection); // Get the RTX payload types.\n\n    var rtxPts = codecsToPts.get('rtx'); // Do nothing if there are no RTX payload types.\n\n    if (!rtxPts) {\n      return mediaSection;\n    } // Remove the RTX payload types.\n\n\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\n    rtxPts.forEach(function (rtxPt) {\n      return pts.delete(rtxPt);\n    }); // Get the RTX SSRC.\n\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1]; // Remove the following lines associated with the RTX payload types:\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\n\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp('^a=ssrc:' + rtxSSRC + ' .+$')] : []);\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\n      return filterRegexes.every(function (regex) {\n        return !regex.test(line);\n      });\n    }).join('\\r\\n'); // Reconstruct the m= section without the RTX payload types.\n\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\n  })).join('\\r\\n');\n}\n/**\r\n * Generate an a=fmtp: line from the given payload type and attributes.\r\n * @param {PT} pt\r\n * @param {*} fmtpAttrs\r\n * @returns {string}\r\n */\n\n\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        name = _ref7[0],\n        value = _ref7[1];\n\n    return name + '=' + value;\n  }).join(';');\n  return 'a=fmtp:' + pt + ' ' + serializedFmtpAttrs;\n}\n/**\r\n * Enable DTX for opus in the m= sections for the given MIDs.`\r\n * @param {string} sdp\r\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\r\n *   audio m= lines.\r\n * @returns {string}\r\n */\n\n\nfunction enableDtxForOpus(sdp, mids) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  mids = mids || mediaSections.filter(function (section) {\n    return /^m=audio/.test(section);\n  }).map(getMidForMediaSection);\n  return [session].concat(mediaSections.map(function (section) {\n    // Do nothing if the m= section is not audio.\n    if (!/^m=audio/.test(section)) {\n      return section;\n    } // Build a map codecs to payload types.\n\n\n    var codecsToPts = createCodecMapForMediaSection(section); // Do nothing if a payload type for opus does not exist.\n\n    var opusPt = codecsToPts.get('opus');\n\n    if (!opusPt) {\n      return section;\n    } // If no fmtp attributes are found for opus, do nothing.\n\n\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\n\n    if (!opusFmtpAttrs) {\n      return section;\n    } // Add usedtx=1 to the a=fmtp: line for opus.\n\n\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine); // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\n\n    var mid = getMidForMediaSection(section);\n\n    if (mids.includes(mid)) {\n      opusFmtpAttrs.usedtx = 1;\n    } else {\n      delete opusFmtpAttrs.usedtx;\n    }\n\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\n  })).join('\\r\\n');\n}\n\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\nexports.createPtToCodecName = createPtToCodecName;\nexports.disableRtx = disableRtx;\nexports.enableDtxForOpus = enableDtxForOpus;\nexports.getMediaSections = getMediaSections;\nexports.removeSSRCAttributes = removeSSRCAttributes;\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\nexports.setBitrateParameters = setBitrateParameters;\nexports.setCodecPreferences = setCodecPreferences;\nexports.setSimulcast = setSimulcast;\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilio-video/es5/util/sdp/index.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_require","require","difference","flatMap","setSimulcastInMediaSection","ptToFixedBitrateAudioCodecName","RTCP_BITRATE","createBLine","modifier","maxBitrate","Math","round","createCodecMapForMediaSection","section","from","createPtToCodecName","reduce","codecMap","pair","pt","codecName","pts","get","set","concat","Map","createMidToMediaSectionMap","sdp","getMediaSections","midsToMediaSections","mediaSection","mid","getMidForMediaSection","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","RegExp","matches","match","toLowerCase","getFmtpAttributesForPt","fmtpRegex","split","attrs","nvPair","_nvPair$split","_nvPair$split2","name","isNaN","parseInt","midMatches","kind","direction","replace","slice","map","filter","kindPattern","directionPattern","test","mLine","getReorderedPayloadTypes","preferredCodecs","_ref","codec","preferredPayloadTypes","remainingCodecs","keys","remainingPayloadTypes","setBitrateInMediaSection","bLine","bLinePattern","bLineMatched","maxBitrateMatched","Infinity","min","setBitrateParameters","maxAudioBitrate","maxVideoBitrate","mediaSections","session","join","setPayloadTypesInMediaSection","payloadTypes","lines","otherLines","setCodecPreferences","preferredAudioCodecs","preferredVideoCodecs","newSection","pcmaPayloadTypes","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","setSimulcast","sdpFormat","trackIdsToAttributes","vp8PayloadTypes","hasVP8PayloadType","some","payloadType","unifiedPlanGetMatchingPayloadTypes","peerCodec","peerPt","codecsToPts","peerSection","matchingPts","peerFmtpAttrs","matchingPt","find","fmtpAttrs","every","attr","unifiedPlanFilterCodecsInMediaSection","peerMidsToMediaSections","codecsToRemove","peerPtToCodecs","_ref2","_ref3","includes","rtxPts","rtxPt","apt","line","ptMatches","orderedPts","unifiedPlanFilterLocalCodecs","localSdp","remoteSdp","localMediaSections","localSession","remoteMidsToMediaSections","localSection","revertSimulcastForNonVP8MediaSections","localSdpWithoutSimulcast","remoteMidToMediaSections","localMidToMediaSectionsWithoutSimulcast","remoteSection","remotePtToCodecs","remotePayloadTypes","isVP8ThePreferredCodec","unifiedPlanAddOrRewriteNewTrackIds","activeMidsToTrackIds","trackIdsByKind","newMidsToTrackIds","midsToTrackIds","_ref4","_ref5","trackIds","newMids","forEach","unifiedPlanAddOrRewriteTrackIds","trackId","attributes","_attributes$split","_attributes$split2","msid","trackIdToRewrite","msidRegex","removeSSRCAttributes","ssrcAttributesToRemove","srcAttribute","disableRtx","delete","rtxSSRCMatches","rtxSSRC","filterRegexes","regex","generateFmtpLineFromPtAndAttributes","serializedFmtpAttrs","entries","_ref6","_ref7","enableDtxForOpus","mids","opusPt","opusFmtpAttrs","origOpusFmtpLine","origOpusFmtpRegex","usedtx","opusFmtpLineWithDtx","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _require = require('../'),\r\n    difference = _require.difference,\r\n    flatMap = _require.flatMap;\r\n\r\nvar setSimulcastInMediaSection = require('./simulcast');\r\n\r\nvar ptToFixedBitrateAudioCodecName = {\r\n  0: 'PCMU',\r\n  8: 'PCMA'\r\n};\r\n\r\n/**\r\n * A payload type\r\n * @typedef {number} PT\r\n */\r\n\r\n/**\r\n * An {@link AudioCodec} or {@link VideoCodec}\r\n * @typedef {AudioCodec|VideoCodec} Codec\r\n */\r\n\r\n// NOTE(mmalavalli): This value is derived from the IETF spec\r\n// for JSEP, and it is used to convert a 'b=TIAS' value in bps\r\n// to a 'b=AS' value in kbps.\r\n// Spec: https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-21#section-5.9\r\nvar RTCP_BITRATE = 16000;\r\n\r\n/**\r\n * Construct a b= line string for the given max bitrate in bps. If the modifier\r\n * is 'AS', then the max bitrate will be converted to kbps using the formula\r\n * specified in the IETF spec for JSEP mentioned above.\r\n * @param {string} modifier - 'AS' | 'TIAS'\r\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\r\n * @returns {?string} - If \"maxBitrate\" is null, then returns null;\r\n *   otherwise return the constructed b= line string\r\n */\r\nfunction createBLine(modifier, maxBitrate) {\r\n  if (!maxBitrate) {\r\n    return null;\r\n  }\r\n  return '\\r\\nb=' + modifier + ':' + (modifier === 'AS' ? Math.round((maxBitrate + RTCP_BITRATE) / 950) : maxBitrate);\r\n}\r\n\r\n/**\r\n * Create a Codec Map for the given m= section.\r\n * @param {string} section - The given m= section\r\n * @returns {Map<Codec, Array<PT>>}\r\n */\r\nfunction createCodecMapForMediaSection(section) {\r\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\r\n    var pt = pair[0];\r\n    var codecName = pair[1];\r\n    var pts = codecMap.get(codecName) || [];\r\n    return codecMap.set(codecName, pts.concat(pt));\r\n  }, new Map());\r\n}\r\n\r\n/**\r\n * Create a Map of MIDs to m= sections for the given SDP.\r\n * @param {string} sdp\r\n * @returns {Map<string, string>}\r\n */\r\nfunction createMidToMediaSectionMap(sdp) {\r\n  return getMediaSections(sdp).reduce(function (midsToMediaSections, mediaSection) {\r\n    var mid = getMidForMediaSection(mediaSection);\r\n    return mid ? midsToMediaSections.set(mid, mediaSection) : midsToMediaSections;\r\n  }, new Map());\r\n}\r\n\r\n/**\r\n * Create a Map from PTs to codec names for the given m= section.\r\n * @param {string} mediaSection - The given m= section.\r\n * @returns {Map<PT, Codec>} ptToCodecName\r\n */\r\nfunction createPtToCodecName(mediaSection) {\r\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\r\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\r\n    var matches = mediaSection.match(rtpmapPattern);\r\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\r\n    return ptToCodecName.set(pt, codecName);\r\n  }, new Map());\r\n}\r\n\r\n/**\r\n * Get the associated fmtp attributes for the given Payload Type in an m= section.\r\n * @param {PT} pt\r\n * @param {string} mediaSection\r\n * @returns {?object}\r\n */\r\nfunction getFmtpAttributesForPt(pt, mediaSection) {\r\n  // In \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\", the regex matches the codec\r\n  // profile parameters expressed as name/value pairs separated by \";\".\r\n  var fmtpRegex = new RegExp('^a=fmtp:' + pt + ' (.+)$', 'm');\r\n  var matches = mediaSection.match(fmtpRegex);\r\n  return matches && matches[1].split(';').reduce(function (attrs, nvPair) {\r\n    var _nvPair$split = nvPair.split('='),\r\n        _nvPair$split2 = _slicedToArray(_nvPair$split, 2),\r\n        name = _nvPair$split2[0],\r\n        value = _nvPair$split2[1];\r\n\r\n    attrs[name] = isNaN(value) ? value : parseInt(value, 10);\r\n    return attrs;\r\n  }, {});\r\n}\r\n\r\n/**\r\n * Get the MID for the given m= section.\r\n * @param {string} mediaSection\r\n * @return {?string}\r\n */\r\nfunction getMidForMediaSection(mediaSection) {\r\n  // In \"a=mid:<mid>\", the regex matches <mid>.\r\n  var midMatches = mediaSection.match(/^a=mid:(.+)$/m);\r\n  return midMatches && midMatches[1];\r\n}\r\n\r\n/**\r\n * Get the m= sections of a particular kind and direction from an sdp.\r\n * @param {string} sdp - SDP string\r\n * @param {string} [kind] - Pattern for matching kind\r\n * @param {string} [direction] - Pattern for matching direction\r\n * @returns {Array<string>} mediaSections\r\n */\r\nfunction getMediaSections(sdp, kind, direction) {\r\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\r\n    return 'm=' + mediaSection;\r\n  }).filter(function (mediaSection) {\r\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\r\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\r\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\r\n  });\r\n}\r\n\r\n/**\r\n * Get the Codec Payload Types present in the first line of the given m= section\r\n * @param {string} section - The m= section\r\n * @returns {Array<PT>} Payload Types\r\n */\r\nfunction getPayloadTypesInMediaSection(section) {\r\n  var mLine = section.split('\\r\\n')[0];\r\n\r\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\r\n  // the regex matches <port> and the Payload Types.\r\n  var matches = mLine.match(/([0-9]+)/g);\r\n\r\n  // This should not happen, but in case there are no Payload Types in\r\n  // the m= line, return an empty array.\r\n  if (!matches) {\r\n    return [];\r\n  }\r\n\r\n  // Since only the Payload Types are needed, we discard the <port>.\r\n  return matches.slice(1).map(function (match) {\r\n    return parseInt(match, 10);\r\n  });\r\n}\r\n\r\n/**\r\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\r\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\r\n * @param {Array<AudioCodecSettings|VideoCodecSettings>} preferredCodecs - Preferred Codecs\r\n * @returns {Array<PT>} Reordered Payload Types\r\n */\r\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\r\n  preferredCodecs = preferredCodecs.map(function (_ref) {\r\n    var codec = _ref.codec;\r\n    return codec.toLowerCase();\r\n  });\r\n  var preferredPayloadTypes = flatMap(preferredCodecs, function (codecName) {\r\n    return codecMap.get(codecName) || [];\r\n  });\r\n  var remainingCodecs = difference(Array.from(codecMap.keys()), preferredCodecs);\r\n  var remainingPayloadTypes = flatMap(remainingCodecs, function (codecName) {\r\n    return codecMap.get(codecName);\r\n  });\r\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\r\n}\r\n\r\n/**\r\n * Set the specified max bitrate in the given m= section.\r\n * @param {string} modifier - 'AS' | 'TIAS'\r\n * @param {?number} maxBitrate - Max outgoing bitrate (bps)\r\n * @param {string} section - m= section string\r\n * @returns {string} The updated m= section\r\n */\r\nfunction setBitrateInMediaSection(modifier, maxBitrate, section) {\r\n  var bLine = createBLine(modifier, maxBitrate) || '';\r\n  var bLinePattern = /\\r\\nb=(AS|TIAS):([0-9]+)/;\r\n  var bLineMatched = section.match(bLinePattern);\r\n\r\n  if (!bLineMatched) {\r\n    return section.replace(/(\\r\\n)?$/, bLine + '$1');\r\n  }\r\n\r\n  var maxBitrateMatched = parseInt(bLineMatched[2], 10);\r\n  maxBitrate = maxBitrate || Infinity;\r\n  bLine = createBLine(modifier, Math.min(maxBitrateMatched, maxBitrate));\r\n  return section.replace(bLinePattern, bLine);\r\n}\r\n\r\n/**\r\n * Set maximum bitrates to the media sections in a given sdp.\r\n * @param {string} sdp - sdp string\r\n * @param {string} modifier - 'AS' | 'TIAS\"\r\n * @param {?number} maxAudioBitrate - Max outgoing audio bitrate (bps), null\r\n *   if no limit is to be applied\r\n * @param {?number} maxVideoBitrate - Max outgoing video bitrate (bps), null\r\n *   if no limit is to be applied\r\n * @returns {string} - The updated sdp string\r\n */\r\nfunction setBitrateParameters(sdp, modifier, maxAudioBitrate, maxVideoBitrate) {\r\n  var mediaSections = getMediaSections(sdp);\r\n  var session = sdp.split('\\r\\nm=')[0];\r\n  return [session].concat(mediaSections.map(function (section) {\r\n    // Bitrate parameters should not be applied to m=application sections\r\n    // or to m=(audio|video) sections that do not receive media.\r\n    if (!/^m=(audio|video)/.test(section) || !/a=(recvonly|sendrecv)/.test(section)) {\r\n      return section;\r\n    }\r\n    var kind = section.match(/^m=(audio|video)/)[1];\r\n    var maxBitrate = kind === 'audio' ? maxAudioBitrate : maxVideoBitrate;\r\n    return setBitrateInMediaSection(modifier, maxBitrate, section);\r\n  })).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Set the given Codec Payload Types in the first line of the given m= section.\r\n * @param {Array<PT>} payloadTypes - Payload Types\r\n * @param {string} section - Given m= section\r\n * @returns {string} - Updated m= section\r\n */\r\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\r\n  var lines = section.split('\\r\\n');\r\n  var mLine = lines[0];\r\n  var otherLines = lines.slice(1);\r\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\r\n  return [mLine].concat(otherLines).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Return a new SDP string with the re-ordered codec preferences.\r\n * @param {string} sdp\r\n * @param {Array<AudioCodec>} preferredAudioCodecs - If empty, the existing order\r\n *   of audio codecs is preserved\r\n * @param {Array<VideoCodecSettings>} preferredVideoCodecs - If empty, the\r\n *   existing order of video codecs is preserved\r\n * @returns {string} Updated SDP string\r\n */\r\nfunction setCodecPreferences(sdp, preferredAudioCodecs, preferredVideoCodecs) {\r\n  var mediaSections = getMediaSections(sdp);\r\n  var session = sdp.split('\\r\\nm=')[0];\r\n  return [session].concat(mediaSections.map(function (section) {\r\n    // Codec preferences should not be applied to m=application sections.\r\n    if (!/^m=(audio|video)/.test(section)) {\r\n      return section;\r\n    }\r\n    var kind = section.match(/^m=(audio|video)/)[1];\r\n    var codecMap = createCodecMapForMediaSection(section);\r\n    var preferredCodecs = kind === 'audio' ? preferredAudioCodecs : preferredVideoCodecs;\r\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\r\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\r\n\r\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\r\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\r\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\r\n\r\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\r\n  })).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Return a new SDP string with simulcast settings.\r\n * @param {string} sdp\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes\r\n * @returns {string} Updated SDP string\r\n */\r\nfunction setSimulcast(sdp, sdpFormat, trackIdsToAttributes) {\r\n  var mediaSections = getMediaSections(sdp);\r\n  var session = sdp.split('\\r\\nm=')[0];\r\n  return [session].concat(mediaSections.map(function (section) {\r\n    section = section.replace(/\\r\\n$/, '');\r\n    if (!/^m=video/.test(section)) {\r\n      return section;\r\n    }\r\n    var codecMap = createCodecMapForMediaSection(section);\r\n    var payloadTypes = getPayloadTypesInMediaSection(section);\r\n    var vp8PayloadTypes = new Set(codecMap.get('vp8') || []);\r\n\r\n    var hasVP8PayloadType = payloadTypes.some(function (payloadType) {\r\n      return vp8PayloadTypes.has(payloadType);\r\n    });\r\n    return hasVP8PayloadType ? setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) : section;\r\n  })).concat('').join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Get the matching Payload Types in a unified plan m= section for a particular peer codec.\r\n * @param {Codec} peerCodec\r\n * @param {PT} peerPt\r\n * @param {Map<Codec, PT>} codecsToPts\r\n * @param {string} section\r\n * @param {string} peerSection\r\n * @returns {Array<PT>}\r\n */\r\nfunction unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) {\r\n  // If there is at most one local Payload Type that matches the remote codec, retain it.\r\n  var matchingPts = codecsToPts.get(peerCodec) || [];\r\n  if (matchingPts.length <= 1) {\r\n    return matchingPts;\r\n  }\r\n\r\n  // If there are no fmtp attributes for the codec in the peer m= section, then we\r\n  // cannot get a match in the  m= section. In that case, retain all matching Payload\r\n  // Types.\r\n  var peerFmtpAttrs = getFmtpAttributesForPt(peerPt, peerSection);\r\n  if (!peerFmtpAttrs) {\r\n    return matchingPts;\r\n  }\r\n\r\n  // Among the matched local Payload Types, find the one that matches the remote\r\n  // fmtp attributes.\r\n  var matchingPt = matchingPts.find(function (pt) {\r\n    var fmtpAttrs = getFmtpAttributesForPt(pt, section);\r\n    return fmtpAttrs && Object.keys(peerFmtpAttrs).every(function (attr) {\r\n      return peerFmtpAttrs[attr] === fmtpAttrs[attr];\r\n    });\r\n  });\r\n\r\n  // If none of the matched Payload Types also have matching fmtp attributes,\r\n  // then retain all of them, otherwise retain only the Payload Type that\r\n  // matches the peer fmtp attributes.\r\n  return typeof matchingPt === 'number' ? [matchingPt] : matchingPts;\r\n}\r\n\r\n/**\r\n * Filter codecs in a unified plan m= section based on its peer m= section.\r\n * from the other peer.\r\n * @param {string} section\r\n * @param {Map<string, string>} peerMidsToMediaSections\r\n * @param {Array<string>} codecsToRemove\r\n * @returns {string}\r\n */\r\nfunction unifiedPlanFilterCodecsInMediaSection(section, peerMidsToMediaSections, codecsToRemove) {\r\n  // Do nothing if the m= section represents neither audio nor video.\r\n  if (!/^m=(audio|video)/.test(section)) {\r\n    return section;\r\n  }\r\n\r\n  // Do nothing if the m= section does not have an equivalent remote m= section.\r\n  var mid = getMidForMediaSection(section);\r\n  var peerSection = mid && peerMidsToMediaSections.get(mid);\r\n  if (!peerSection) {\r\n    return section;\r\n  }\r\n\r\n  // Construct a Map of the peer Payload Types to their codec names.\r\n  var peerPtToCodecs = createPtToCodecName(peerSection);\r\n  // Construct a Map of the codec names to their Payload Types.\r\n  var codecsToPts = createCodecMapForMediaSection(section);\r\n  // Maintain a list of non-rtx Payload Types to retain.\r\n  var pts = flatMap(Array.from(peerPtToCodecs), function (_ref2) {\r\n    var _ref3 = _slicedToArray(_ref2, 2),\r\n        peerPt = _ref3[0],\r\n        peerCodec = _ref3[1];\r\n\r\n    return peerCodec !== 'rtx' && !codecsToRemove.includes(peerCodec) ? unifiedPlanGetMatchingPayloadTypes(peerCodec, peerPt, codecsToPts, section, peerSection) : [];\r\n  });\r\n\r\n  // For each Payload Type that will be retained, retain their corresponding rtx\r\n  // Payload Type if present.\r\n  var rtxPts = codecsToPts.get('rtx') || [];\r\n  // In \"a=fmtp:<rtxPt> apt=<apt>\", extract the codec PT <apt> associated with rtxPt.\r\n  pts = pts.concat(rtxPts.filter(function (rtxPt) {\r\n    var fmtpAttrs = getFmtpAttributesForPt(rtxPt, section);\r\n    return fmtpAttrs && pts.includes(fmtpAttrs.apt);\r\n  }));\r\n\r\n  // Filter out the below mentioned attribute lines in the m= section that do not\r\n  // belong to one of the Payload Types that are to be retained.\r\n  // 1. \"a=rtpmap:<pt> <codec>\"\r\n  // 2. \"a=rtcp-fb:<pt> <attr>[ <attr>]*\"\r\n  // 3. \"a=fmtp:<pt> <name>=<value>[;<name>=<value>]*\"\r\n  var lines = section.split('\\r\\n').filter(function (line) {\r\n    var ptMatches = line.match(/^a=(rtpmap|fmtp|rtcp-fb):(.+) .+$/);\r\n    var pt = ptMatches && ptMatches[2];\r\n    return !ptMatches || pt && pts.includes(parseInt(pt, 10));\r\n  });\r\n\r\n  // Filter the list of Payload Types in the first line of the m= section.\r\n  var orderedPts = getPayloadTypesInMediaSection(section).filter(function (pt) {\r\n    return pts.includes(pt);\r\n  });\r\n  return setPayloadTypesInMediaSection(orderedPts, lines.join('\\r\\n'));\r\n}\r\n\r\n/**\r\n * Filter local codecs based on the remote unified plan SDP.\r\n * @param {string} localSdp\r\n * @param {string} remoteSdp\r\n * @returns {string} - Updated local SDP\r\n */\r\nfunction unifiedPlanFilterLocalCodecs(localSdp, remoteSdp) {\r\n  var localMediaSections = getMediaSections(localSdp);\r\n  var localSession = localSdp.split('\\r\\nm=')[0];\r\n  var remoteMidsToMediaSections = createMidToMediaSectionMap(remoteSdp);\r\n  return [localSession].concat(localMediaSections.map(function (localSection) {\r\n    return unifiedPlanFilterCodecsInMediaSection(localSection, remoteMidsToMediaSections, []);\r\n  })).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Return a new SDP string after reverting simulcast for non vp8 sections in remote sdp.\r\n * @param localSdp - simulcast enabled local sdp\r\n * @param localSdpWithoutSimulcast - local sdp before simulcast was set\r\n * @param remoteSdp - remote sdp\r\n * @return {string} Updated SDP string\r\n */\r\nfunction revertSimulcastForNonVP8MediaSections(localSdp, localSdpWithoutSimulcast, remoteSdp) {\r\n  var remoteMidToMediaSections = createMidToMediaSectionMap(remoteSdp);\r\n  var localMidToMediaSectionsWithoutSimulcast = createMidToMediaSectionMap(localSdpWithoutSimulcast);\r\n  var mediaSections = getMediaSections(localSdp);\r\n  var session = localSdp.split('\\r\\nm=')[0];\r\n  return [session].concat(mediaSections.map(function (section) {\r\n    section = section.replace(/\\r\\n$/, '');\r\n    if (!/^m=video/.test(section)) {\r\n      return section;\r\n    }\r\n    var midMatches = section.match(/^a=mid:(.+)$/m);\r\n    var mid = midMatches && midMatches[1];\r\n    if (!mid) {\r\n      return section;\r\n    }\r\n\r\n    var remoteSection = remoteMidToMediaSections.get(mid);\r\n    var remotePtToCodecs = createPtToCodecName(remoteSection);\r\n    var remotePayloadTypes = getPayloadTypesInMediaSection(remoteSection);\r\n\r\n    var isVP8ThePreferredCodec = remotePayloadTypes.length && remotePtToCodecs.get(remotePayloadTypes[0]) === 'vp8';\r\n    return isVP8ThePreferredCodec ? section : localMidToMediaSectionsWithoutSimulcast.get(mid).replace(/\\r\\n$/, '');\r\n  })).concat('').join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Add or rewrite MSIDs for new m= sections in the given Unified Plan SDP with their\r\n * corresponding local MediaStreamTrack IDs. These can be different when previously\r\n * removed MediaStreamTracks are added back (or Track IDs may not be present in the\r\n * SDPs at all once browsers implement the latest WebRTC spec).\r\n * @param {string} sdp\r\n * @param {Map<string, Track.ID>} activeMidsToTrackIds\r\n * @param {Map<Track.Kind, Array<Track.ID>>} trackIdsByKind\r\n * @returns {string}\r\n */\r\nfunction unifiedPlanAddOrRewriteNewTrackIds(sdp, activeMidsToTrackIds, trackIdsByKind) {\r\n  // NOTE(mmalavalli): The m= sections for the new MediaStreamTracks are usually\r\n  // present after the m= sections for the existing MediaStreamTracks, in order\r\n  // of addition.\r\n  var newMidsToTrackIds = Array.from(trackIdsByKind).reduce(function (midsToTrackIds, _ref4) {\r\n    var _ref5 = _slicedToArray(_ref4, 2),\r\n        kind = _ref5[0],\r\n        trackIds = _ref5[1];\r\n\r\n    var mediaSections = getMediaSections(sdp, kind, 'send(only|recv)');\r\n    var newMids = mediaSections.map(getMidForMediaSection).filter(function (mid) {\r\n      return !activeMidsToTrackIds.has(mid);\r\n    });\r\n    newMids.forEach(function (mid, i) {\r\n      return midsToTrackIds.set(mid, trackIds[i]);\r\n    });\r\n    return midsToTrackIds;\r\n  }, new Map());\r\n  return unifiedPlanAddOrRewriteTrackIds(sdp, newMidsToTrackIds);\r\n}\r\n\r\n/**\r\n * Add or rewrite MSIDs in the given Unified Plan SDP with their corresponding local\r\n * MediaStreamTrack IDs. These IDs need not be the same (or Track IDs may not be\r\n * present in the SDPs at all once browsers implement the latest WebRTC spec).\r\n * @param {string} sdp\r\n * @param {Map<string, Track.ID>} midsToTrackIds\r\n * @returns {string}\r\n */\r\nfunction unifiedPlanAddOrRewriteTrackIds(sdp, midsToTrackIds) {\r\n  var mediaSections = getMediaSections(sdp);\r\n  var session = sdp.split('\\r\\nm=')[0];\r\n  return [session].concat(mediaSections.map(function (mediaSection) {\r\n    // Do nothing if the m= section represents neither audio nor video.\r\n    if (!/^m=(audio|video)/.test(mediaSection)) {\r\n      return mediaSection;\r\n    }\r\n    // This shouldn't happen, but in case there is no MID for the m= section, do nothing.\r\n    var mid = getMidForMediaSection(mediaSection);\r\n    if (!mid) {\r\n      return mediaSection;\r\n    }\r\n    // In case there is no Track ID for the given MID in the map, do nothing.\r\n    var trackId = midsToTrackIds.get(mid);\r\n    if (!trackId) {\r\n      return mediaSection;\r\n    }\r\n    // This shouldn't happen, but in case there is no a=msid: line, do nothing.\r\n    var attributes = (mediaSection.match(/^a=msid:(.+)$/m) || [])[1];\r\n    if (!attributes) {\r\n      return mediaSection;\r\n    }\r\n    // If the a=msid: line contains the \"appdata\" field, then replace it with the Track ID,\r\n    // otherwise append the Track ID.\r\n\r\n    var _attributes$split = attributes.split(' '),\r\n        _attributes$split2 = _slicedToArray(_attributes$split, 2),\r\n        msid = _attributes$split2[0],\r\n        trackIdToRewrite = _attributes$split2[1];\r\n\r\n    var msidRegex = new RegExp('msid:' + msid + (trackIdToRewrite ? ' ' + trackIdToRewrite : '') + '$', 'gm');\r\n    return mediaSection.replace(msidRegex, 'msid:' + msid + ' ' + trackId);\r\n  })).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * removes specified ssrc attributes from given sdp\r\n * @param {string} sdp\r\n * @param {Array<string>} ssrcAttributesToRemove\r\n * @returns {string}\r\n */\r\nfunction removeSSRCAttributes(sdp, ssrcAttributesToRemove) {\r\n  return sdp.split('\\r\\n').filter(function (line) {\r\n    return !ssrcAttributesToRemove.find(function (srcAttribute) {\r\n      return new RegExp('a=ssrc:.*' + srcAttribute + ':', 'g').test(line);\r\n    });\r\n  }).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Disable RTX in a given sdp.\r\n * @param {string} sdp\r\n * @returns {string} sdp without RTX\r\n */\r\nfunction disableRtx(sdp) {\r\n  var mediaSections = getMediaSections(sdp);\r\n  var session = sdp.split('\\r\\nm=')[0];\r\n  return [session].concat(mediaSections.map(function (mediaSection) {\r\n    // Do nothing if the m= section does not represent a video track.\r\n    if (!/^m=video/.test(mediaSection)) {\r\n      return mediaSection;\r\n    }\r\n\r\n    // Create a map of codecs to payload types.\r\n    var codecsToPts = createCodecMapForMediaSection(mediaSection);\r\n    // Get the RTX payload types.\r\n    var rtxPts = codecsToPts.get('rtx');\r\n\r\n    // Do nothing if there are no RTX payload types.\r\n    if (!rtxPts) {\r\n      return mediaSection;\r\n    }\r\n\r\n    // Remove the RTX payload types.\r\n    var pts = new Set(getPayloadTypesInMediaSection(mediaSection));\r\n    rtxPts.forEach(function (rtxPt) {\r\n      return pts.delete(rtxPt);\r\n    });\r\n\r\n    // Get the RTX SSRC.\r\n    var rtxSSRCMatches = mediaSection.match(/a=ssrc-group:FID [0-9]+ ([0-9]+)/);\r\n    var rtxSSRC = rtxSSRCMatches && rtxSSRCMatches[1];\r\n\r\n    // Remove the following lines associated with the RTX payload types:\r\n    // 1. \"a=fmtp:<rtxPt> apt=<pt>\"\r\n    // 2. \"a=rtpmap:<rtxPt> rtx/...\"\r\n    // 3. \"a=ssrc:<rtxSSRC> cname:...\"\r\n    // 4. \"a=ssrc-group:FID <SSRC> <rtxSSRC>\"\r\n    var filterRegexes = [/^a=fmtp:.+ apt=.+$/, /^a=rtpmap:.+ rtx\\/.+$/, /^a=ssrc-group:.+$/].concat(rtxSSRC ? [new RegExp('^a=ssrc:' + rtxSSRC + ' .+$')] : []);\r\n\r\n    mediaSection = mediaSection.split('\\r\\n').filter(function (line) {\r\n      return filterRegexes.every(function (regex) {\r\n        return !regex.test(line);\r\n      });\r\n    }).join('\\r\\n');\r\n\r\n    // Reconstruct the m= section without the RTX payload types.\r\n    return setPayloadTypesInMediaSection(Array.from(pts), mediaSection);\r\n  })).join('\\r\\n');\r\n}\r\n\r\n/**\r\n * Generate an a=fmtp: line from the given payload type and attributes.\r\n * @param {PT} pt\r\n * @param {*} fmtpAttrs\r\n * @returns {string}\r\n */\r\nfunction generateFmtpLineFromPtAndAttributes(pt, fmtpAttrs) {\r\n  var serializedFmtpAttrs = Object.entries(fmtpAttrs).map(function (_ref6) {\r\n    var _ref7 = _slicedToArray(_ref6, 2),\r\n        name = _ref7[0],\r\n        value = _ref7[1];\r\n\r\n    return name + '=' + value;\r\n  }).join(';');\r\n  return 'a=fmtp:' + pt + ' ' + serializedFmtpAttrs;\r\n}\r\n\r\n/**\r\n * Enable DTX for opus in the m= sections for the given MIDs.`\r\n * @param {string} sdp\r\n * @param {Array<string>} [mids] - If not specified, enables opus DTX for all\r\n *   audio m= lines.\r\n * @returns {string}\r\n */\r\nfunction enableDtxForOpus(sdp, mids) {\r\n  var mediaSections = getMediaSections(sdp);\r\n  var session = sdp.split('\\r\\nm=')[0];\r\n\r\n  mids = mids || mediaSections.filter(function (section) {\r\n    return (/^m=audio/.test(section)\r\n    );\r\n  }).map(getMidForMediaSection);\r\n\r\n  return [session].concat(mediaSections.map(function (section) {\r\n    // Do nothing if the m= section is not audio.\r\n    if (!/^m=audio/.test(section)) {\r\n      return section;\r\n    }\r\n\r\n    // Build a map codecs to payload types.\r\n    var codecsToPts = createCodecMapForMediaSection(section);\r\n\r\n    // Do nothing if a payload type for opus does not exist.\r\n    var opusPt = codecsToPts.get('opus');\r\n    if (!opusPt) {\r\n      return section;\r\n    }\r\n\r\n    // If no fmtp attributes are found for opus, do nothing.\r\n    var opusFmtpAttrs = getFmtpAttributesForPt(opusPt, section);\r\n    if (!opusFmtpAttrs) {\r\n      return section;\r\n    }\r\n\r\n    // Add usedtx=1 to the a=fmtp: line for opus.\r\n    var origOpusFmtpLine = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\r\n    var origOpusFmtpRegex = new RegExp(origOpusFmtpLine);\r\n\r\n    // If the m= section's MID is in the list of MIDs, then enable dtx. Otherwise disable it.\r\n    var mid = getMidForMediaSection(section);\r\n    if (mids.includes(mid)) {\r\n      opusFmtpAttrs.usedtx = 1;\r\n    } else {\r\n      delete opusFmtpAttrs.usedtx;\r\n    }\r\n\r\n    var opusFmtpLineWithDtx = generateFmtpLineFromPtAndAttributes(opusPt, opusFmtpAttrs);\r\n    return section.replace(origOpusFmtpRegex, opusFmtpLineWithDtx);\r\n  })).join('\\r\\n');\r\n}\r\n\r\nexports.createCodecMapForMediaSection = createCodecMapForMediaSection;\r\nexports.createPtToCodecName = createPtToCodecName;\r\nexports.disableRtx = disableRtx;\r\nexports.enableDtxForOpus = enableDtxForOpus;\r\nexports.getMediaSections = getMediaSections;\r\nexports.removeSSRCAttributes = removeSSRCAttributes;\r\nexports.revertSimulcastForNonVP8MediaSections = revertSimulcastForNonVP8MediaSections;\r\nexports.setBitrateParameters = setBitrateParameters;\r\nexports.setCodecPreferences = setCodecPreferences;\r\nexports.setSimulcast = setSimulcast;\r\nexports.unifiedPlanFilterLocalCodecs = unifiedPlanFilterLocalCodecs;\r\nexports.unifiedPlanAddOrRewriteNewTrackIds = unifiedPlanAddOrRewriteNewTrackIds;\r\nexports.unifiedPlanAddOrRewriteTrackIds = unifiedPlanAddOrRewriteTrackIds;"]},"metadata":{},"sourceType":"script"}