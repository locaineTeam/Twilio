{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstantQuery = exports.LiveQuery = exports.queryItems = exports.LiveQueryImpl = exports.InsightsItem = void 0;\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst events_1 = require(\"events\");\n\nconst entity_1 = require(\"./entity\");\n\nconst closeable_1 = require(\"./closeable\");\n\nconst cache_1 = require(\"./cache\");\n\nclass InsightsItem {}\n\nexports.InsightsItem = InsightsItem;\n\nclass LiveQueryImpl extends entity_1.SyncEntity {\n  constructor(descriptor, services, removalHandler, items) {\n    super(services, removalHandler);\n    this.descriptor = descriptor;\n    this.cache = new cache_1.Cache();\n\n    if (items) {\n      items.forEach(item => {\n        this.cache.store(item.key, {\n          key: item.key,\n          value: item.data\n        }, item.revision);\n      });\n    }\n  } // public\n\n\n  get sid() {\n    return this.descriptor.sid;\n  } // private extension of SyncEntity\n\n\n  get uniqueName() {\n    return null;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  static get type() {\n    return 'live_query';\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get indexName() {\n    return this.descriptor.indexName;\n  }\n\n  get queryString() {\n    return this.descriptor.queryExpression;\n  } // custom private props\n\n\n  get queryUri() {\n    return this.descriptor.queryUri;\n  }\n\n  get liveQueryDescriptor() {\n    return this.descriptor;\n  } // dummy stub from iface\n\n\n  onRemoved() {}\n\n  getItems() {\n    const dataByKey = {};\n    this.cache.forEach((key, item) => {\n      dataByKey[key] = item.value;\n    });\n    return dataByKey;\n  }\n  /**\n   * @private\n   */\n\n\n  _update(message, isStrictlyOrdered) {\n    switch (message.type) {\n      case 'live_query_item_updated':\n        this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n        break;\n\n      case 'live_query_item_removed':\n        this.handleItemRemoved(message.item_key, message.item_revision);\n        break;\n\n      case 'live_query_updated':\n        this.handleBatchUpdate(message.items);\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(message.last_event_id);\n    }\n  }\n\n  handleItemMutated(key, value, revision) {\n    if (this.shouldIgnoreEvent(key, revision)) {\n      logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);\n    } else {\n      const newItem = {\n        key,\n        value\n      };\n      this.cache.store(key, newItem, revision);\n      this.broadcastEventToListeners('itemUpdated', newItem);\n    }\n  }\n\n  handleItemRemoved(key, revision) {\n    const force = revision === null;\n\n    if (this.shouldIgnoreEvent(key, revision)) {\n      logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);\n    } else {\n      this.cache.delete(key, revision, force);\n      this.broadcastEventToListeners('itemRemoved', {\n        key\n      });\n    }\n  }\n\n  handleBatchUpdate(items) {\n    // preprocess item set for easy key-based access (it's a one-time constant time operation)\n    let newItems = {};\n\n    if (items != null) {\n      items.forEach(item => {\n        newItems[item.key] = {\n          data: item.data,\n          revision: item.revision\n        };\n      });\n    } // go through existing items and generate update/remove events for them\n\n\n    this.cache.forEach((key, item) => {\n      const newItem = newItems[key];\n\n      if (newItem != null) {\n        this.handleItemMutated(key, newItem.data, newItem.revision);\n      } else {\n        this.handleItemRemoved(key, null); // force deletion w/o revision\n      } // once item is handled, remove it from incoming array\n\n\n      delete newItems[key];\n    }); // once we handled all the known items, handle remaining pack\n\n    for (let key in newItems) {\n      this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n    }\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return key != null && eventId != null && this.cache.isKnown(key, eventId);\n  }\n  /**\n   * @private\n   */\n\n\n  _advanceLastEventId(eventId, revision) {\n    // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n    }\n  }\n\n}\n\nexports.LiveQueryImpl = LiveQueryImpl;\n\nasync function queryItems(params) {\n  let {\n    network,\n    queryString,\n    uri,\n    type\n  } = params;\n\n  if (queryString == null) {\n    // should not be null or undefined\n    throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);\n  }\n\n  const liveQueryRequestBody = {\n    query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n\n  };\n\n  if (type === LiveQuery.type) {\n    liveQueryRequestBody.type = type;\n  }\n\n  let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n  return response.body;\n}\n\nexports.queryItems = queryItems;\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\n\nclass LiveQuery extends closeable_1.Closeable {\n  /**\n   * @private\n   */\n  constructor(liveQueryImpl) {\n    super();\n    this.liveQueryImpl = liveQueryImpl;\n    this.liveQueryImpl.attach(this);\n  } // private props\n\n\n  static get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get lastEventId() {\n    return this.liveQueryImpl.lastEventId;\n  } // public\n\n\n  get sid() {\n    return this.liveQueryImpl.sid;\n  }\n  /**\n   * Closes this query instance and unsubscribes from further service events.\n   * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n   * @public\n   */\n\n\n  close() {\n    super.close();\n    this.liveQueryImpl.detach(this.listenerUuid);\n  }\n  /**\n   * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n   * @public\n   */\n\n\n  getItems() {\n    this.ensureNotClosed();\n    return this.liveQueryImpl.getItems();\n  }\n\n}\n\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\n\nclass InstantQuery extends events_1.EventEmitter {\n  /**\n   * @private\n   */\n  constructor(params) {\n    super();\n    this.queryExpression = null;\n    this.items = {};\n    Object.assign(this, params);\n    this.updateIndexName(params.indexName);\n  } // private props\n\n\n  static get type() {\n    return 'instant_query';\n  }\n\n  get type() {\n    return InstantQuery.type;\n  }\n  /**\n   * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n   * event.\n   * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n   * on the syntax read {@link Client#liveQuery}.\n   * @returns {Promise<void>} A promise that resolves when query result has been received.\n   * @public\n   */\n\n\n  async search(queryExpression) {\n    this.items = {};\n    return queryItems({\n      network: this.network,\n      uri: this.queryUri,\n      queryString: queryExpression\n    }).then(response => {\n      this.queryExpression = queryExpression;\n\n      if (response.items) {\n        response.items.forEach(item => {\n          this.items[item.key] = item.data;\n        });\n      }\n\n      this.emit('searchResult', this.getItems());\n    }).catch(err => {\n      logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);\n      this.queryExpression = null;\n      throw err;\n    });\n  }\n  /**\n   * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n   * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n   * while current object can be still used to execute repetitive searches.\n   * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n   * @public\n   */\n\n\n  async subscribe() {\n    if (this.queryExpression == null) {\n      // should not be null or undefined\n      return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));\n    }\n\n    return this.liveQueryCreator(this.indexName, this.queryExpression);\n  }\n  /**\n   * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n   * @public\n   */\n\n\n  getItems() {\n    return this.items;\n  }\n  /**\n   * Set new index name\n   * @param {String} indexName New index name to set\n   * @returns void\n   * @public\n   */\n\n\n  updateIndexName(indexName) {\n    if (!indexName || typeof indexName !== 'string') {\n      throw new Error('Index name must contain a non-empty string value');\n    }\n\n    this.indexName = indexName;\n    this.queryUri = this.generateQueryUri(this.indexName);\n  }\n\n  generateQueryUri(indexName) {\n    return new uri_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();\n  }\n\n}\n\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */","map":{"version":3,"sources":["C:/Users/Usuario/Downloads/Twilio/node_modules/twilio-sync/lib/livequery.js"],"names":["Object","defineProperty","exports","value","InstantQuery","LiveQuery","queryItems","LiveQueryImpl","InsightsItem","uri_1","require","syncerror_1","logger_1","events_1","entity_1","closeable_1","cache_1","SyncEntity","constructor","descriptor","services","removalHandler","items","cache","Cache","forEach","item","store","key","data","revision","sid","uniqueName","type","lastEventId","last_event_id","indexName","queryString","queryExpression","queryUri","liveQueryDescriptor","onRemoved","getItems","dataByKey","_update","message","isStrictlyOrdered","handleItemMutated","item_key","item_data","item_revision","handleItemRemoved","handleBatchUpdate","_advanceLastEventId","shouldIgnoreEvent","default","trace","newItem","broadcastEventToListeners","force","delete","newItems","eventId","isKnown","params","network","uri","SyncError","liveQueryRequestBody","query_string","response","post","undefined","body","Closeable","liveQueryImpl","attach","close","detach","listenerUuid","ensureNotClosed","EventEmitter","assign","updateIndexName","search","then","emit","catch","err","error","subscribe","Promise","reject","liveQueryCreator","Error","generateQueryUri","UriBuilder","insightsUri","pathSegment","build"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InstantQuery = exports.LiveQuery = exports.queryItems = exports.LiveQueryImpl = exports.InsightsItem = void 0;\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst events_1 = require(\"events\");\nconst entity_1 = require(\"./entity\");\nconst closeable_1 = require(\"./closeable\");\nconst cache_1 = require(\"./cache\");\nclass InsightsItem {\n}\nexports.InsightsItem = InsightsItem;\nclass LiveQueryImpl extends entity_1.SyncEntity {\n    constructor(descriptor, services, removalHandler, items) {\n        super(services, removalHandler);\n        this.descriptor = descriptor;\n        this.cache = new cache_1.Cache();\n        if (items) {\n            items.forEach(item => {\n                this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);\n            });\n        }\n    }\n    // public\n    get sid() {\n        return this.descriptor.sid;\n    }\n    // private extension of SyncEntity\n    get uniqueName() {\n        return null;\n    }\n    get type() {\n        return LiveQueryImpl.type;\n    }\n    static get type() {\n        return 'live_query';\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get indexName() {\n        return this.descriptor.indexName;\n    }\n    get queryString() {\n        return this.descriptor.queryExpression;\n    }\n    // custom private props\n    get queryUri() {\n        return this.descriptor.queryUri;\n    }\n    get liveQueryDescriptor() {\n        return this.descriptor;\n    }\n    // dummy stub from iface\n    onRemoved() {\n    }\n    getItems() {\n        const dataByKey = {};\n        this.cache.forEach((key, item) => {\n            dataByKey[key] = item.value;\n        });\n        return dataByKey;\n    }\n    /**\n     * @private\n     */\n    _update(message, isStrictlyOrdered) {\n        switch (message.type) {\n            case 'live_query_item_updated':\n                this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n                break;\n            case 'live_query_item_removed':\n                this.handleItemRemoved(message.item_key, message.item_revision);\n                break;\n            case 'live_query_updated':\n                this.handleBatchUpdate(message.items);\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(message.last_event_id);\n        }\n    }\n    handleItemMutated(key, value, revision) {\n        if (this.shouldIgnoreEvent(key, revision)) {\n            logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);\n        }\n        else {\n            const newItem = { key, value };\n            this.cache.store(key, newItem, revision);\n            this.broadcastEventToListeners('itemUpdated', newItem);\n        }\n    }\n    handleItemRemoved(key, revision) {\n        const force = (revision === null);\n        if (this.shouldIgnoreEvent(key, revision)) {\n            logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);\n        }\n        else {\n            this.cache.delete(key, revision, force);\n            this.broadcastEventToListeners('itemRemoved', { key });\n        }\n    }\n    handleBatchUpdate(items) {\n        // preprocess item set for easy key-based access (it's a one-time constant time operation)\n        let newItems = {};\n        if (items != null) {\n            items.forEach(item => {\n                newItems[item.key] = {\n                    data: item.data,\n                    revision: item.revision\n                };\n            });\n        }\n        // go through existing items and generate update/remove events for them\n        this.cache.forEach((key, item) => {\n            const newItem = newItems[key];\n            if (newItem != null) {\n                this.handleItemMutated(key, newItem.data, newItem.revision);\n            }\n            else {\n                this.handleItemRemoved(key, null); // force deletion w/o revision\n            }\n            // once item is handled, remove it from incoming array\n            delete newItems[key];\n        });\n        // once we handled all the known items, handle remaining pack\n        for (let key in newItems) {\n            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n        }\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return key != null && eventId != null && this.cache.isKnown(key, eventId);\n    }\n    /**\n     * @private\n     */\n    _advanceLastEventId(eventId, revision) {\n        // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n        }\n    }\n}\nexports.LiveQueryImpl = LiveQueryImpl;\nasync function queryItems(params) {\n    let { network, queryString, uri, type } = params;\n    if (queryString == null) { // should not be null or undefined\n        throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);\n    }\n    const liveQueryRequestBody = {\n        query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n    };\n    if (type === LiveQuery.type) {\n        liveQueryRequestBody.type = type;\n    }\n    let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n    return response.body;\n}\nexports.queryItems = queryItems;\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\nclass LiveQuery extends closeable_1.Closeable {\n    /**\n     * @private\n     */\n    constructor(liveQueryImpl) {\n        super();\n        this.liveQueryImpl = liveQueryImpl;\n        this.liveQueryImpl.attach(this);\n    }\n    // private props\n    static get type() {\n        return LiveQueryImpl.type;\n    }\n    get type() {\n        return LiveQueryImpl.type;\n    }\n    get lastEventId() {\n        return this.liveQueryImpl.lastEventId;\n    }\n    // public\n    get sid() {\n        return this.liveQueryImpl.sid;\n    }\n    /**\n     * Closes this query instance and unsubscribes from further service events.\n     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n     * @public\n     */\n    close() {\n        super.close();\n        this.liveQueryImpl.detach(this.listenerUuid);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n     * @public\n     */\n    getItems() {\n        this.ensureNotClosed();\n        return this.liveQueryImpl.getItems();\n    }\n}\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\nclass InstantQuery extends events_1.EventEmitter {\n    /**\n     * @private\n     */\n    constructor(params) {\n        super();\n        this.queryExpression = null;\n        this.items = {};\n        Object.assign(this, params);\n        this.updateIndexName(params.indexName);\n    }\n    // private props\n    static get type() {\n        return 'instant_query';\n    }\n    get type() {\n        return InstantQuery.type;\n    }\n    /**\n     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n     * event.\n     * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n     * on the syntax read {@link Client#liveQuery}.\n     * @returns {Promise<void>} A promise that resolves when query result has been received.\n     * @public\n     */\n    async search(queryExpression) {\n        this.items = {};\n        return queryItems({\n            network: this.network,\n            uri: this.queryUri,\n            queryString: queryExpression\n        })\n            .then(response => {\n            this.queryExpression = queryExpression;\n            if (response.items) {\n                response.items.forEach((item) => {\n                    this.items[item.key] = item.data;\n                });\n            }\n            this.emit('searchResult', this.getItems());\n        })\n            .catch(err => {\n            logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);\n            this.queryExpression = null;\n            throw err;\n        });\n    }\n    /**\n     * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n     * while current object can be still used to execute repetitive searches.\n     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n     * @public\n     */\n    async subscribe() {\n        if (this.queryExpression == null) { // should not be null or undefined\n            return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));\n        }\n        return this.liveQueryCreator(this.indexName, this.queryExpression);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n     * @public\n     */\n    getItems() {\n        return this.items;\n    }\n    /**\n     * Set new index name\n     * @param {String} indexName New index name to set\n     * @returns void\n     * @public\n     */\n    updateIndexName(indexName) {\n        if (!indexName || typeof indexName !== 'string') {\n            throw new Error('Index name must contain a non-empty string value');\n        }\n        this.indexName = indexName;\n        this.queryUri = this.generateQueryUri(this.indexName);\n    }\n    generateQueryUri(indexName) {\n        return new uri_1.UriBuilder(this.insightsUri)\n            .pathSegment(indexName)\n            .pathSegment('Items')\n            .build();\n    }\n}\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */\n"]},"metadata":{},"sourceType":"script"}