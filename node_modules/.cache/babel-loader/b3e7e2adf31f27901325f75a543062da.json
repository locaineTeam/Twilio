{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nconst events_1 = require(\"events\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst registrar_1 = require(\"./registrar\");\n\nconst logger_1 = require(\"./logger\");\n/**\r\n * @class\r\n * @alias Notifications\r\n * @classdesc The helper library for the notification service.\r\n * Provides high level api for creating and managing notification subscriptions and receiving messages\r\n * Creates the instance of Notification helper library\r\n *\r\n * @constructor\r\n * @param {string} token - Twilio access token\r\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\r\n */\n\n\nclass Client extends events_1.EventEmitter {\n  constructor(token, options = {}) {\n    super();\n\n    if (!token || token.length === 0) {\n      throw new Error('Token is required for Notifications client');\n    }\n\n    options.logLevel = options.logLevel || 'error';\n    logger_1.log.setLevel(options.logLevel);\n    const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n    const productId = options.productId || 'notifications';\n    options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n    options.transport = options.transport || options.twilsockClient;\n    this.services = {\n      twilsock: options.twilsockClient,\n      transport: options.transport,\n      config: new configuration_1.Configuration(null, options)\n    };\n    this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);\n    this.reliableTransportState = {\n      overall: false,\n      transport: false,\n      registration: false,\n      lastEmitted: null\n    };\n\n    this._onTransportStateChange(this.services.twilsock.isConnected);\n\n    this.registrar.on('transportReady', state => {\n      this._onRegistrationStateChange(state ? 'registered' : '');\n    });\n    this.registrar.on('stateChanged', state => {\n      this._onRegistrationStateChange(state);\n    });\n    this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));\n    this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));\n    this.services.twilsock.on('connected', notificationId => {\n      this._onTransportStateChange(true);\n\n      this.registrar.setNotificationId('twilsock', notificationId);\n    });\n    this.services.twilsock.on('disconnected', () => {\n      this._onTransportStateChange(false);\n    });\n    this.services.config.updateToken(token);\n    this.registrar.updateToken(token);\n  }\n\n  get connectionState() {\n    if (this.services.twilsock.state === 'disconnected') {\n      return 'disconnected';\n    } else if (this.services.twilsock.state === 'disconnecting') {\n      return 'disconnecting';\n    } else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n      return 'connected';\n    } else if (this.services.twilsock.state === 'rejected') {\n      return 'denied';\n    }\n\n    return 'connecting';\n  }\n  /**\r\n   * Routes messages to the external subscribers\r\n   * @private\r\n   */\n\n\n  _routeMessage(type, message) {\n    logger_1.log.trace('Message arrived: ', type, message);\n    this.emit('message', type, message);\n  }\n\n  _onNeedReliableTransport(isNeeded) {\n    if (isNeeded) {\n      this.services.twilsock.connect();\n    } else {\n      this.services.twilsock.disconnect();\n    }\n  }\n\n  _onRegistrationStateChange(state) {\n    this.reliableTransportState.registration = state === 'registered';\n\n    this._updateTransportState();\n  }\n\n  _onTransportStateChange(connected) {\n    this.reliableTransportState.transport = connected;\n\n    this._updateTransportState();\n  }\n\n  _updateTransportState() {\n    const overallState = this.reliableTransportState.transport && this.reliableTransportState.registration;\n\n    if (this.reliableTransportState.overall !== overallState) {\n      this.reliableTransportState.overall = overallState;\n      logger_1.log.info('Transport ready:', overallState);\n      this.emit('transportReady', overallState);\n    }\n\n    if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n      this.reliableTransportState.lastEmitted = this.connectionState;\n      this.emit('connectionStateChanged', this.connectionState);\n    }\n  }\n  /**\r\n   * Adds the subscription for the given message type\r\n   * @param {string} messageType The type of message that you want to receive\r\n   * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\r\n   */\n\n\n  subscribe(messageType, channelType = 'twilsock') {\n    logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n    return this.registrar.subscribe(messageType, channelType);\n  }\n  /**\r\n   * Remove the subscription for the particular message type\r\n   * @param {string} messageType The type of message that you don't want to receive anymore\r\n   * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\r\n   */\n\n\n  unsubscribe(messageType, channelType = 'twilsock') {\n    logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n    return this.registrar.unsubscribe(messageType, channelType);\n  }\n  /**\r\n   * Handle incoming push notification.\r\n   * Client application should call this method when it receives push notifications and pass the received data\r\n   * @param {Object} message push message\r\n   * @return {PushNotification}\r\n   */\n\n\n  handlePushNotification(message) {\n    return {\n      messageType: message.twi_message_type,\n      payload: message.payload\n    };\n  }\n  /**\r\n   * Set APN/GCM/FCM token to enable application register for a push messages\r\n   * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\r\n   */\n\n\n  setPushRegistrationId(registrationId, channelType) {\n    logger_1.log.trace('Set push registration id', registrationId, channelType);\n    this.registrar.setNotificationId(channelType, registrationId);\n  }\n  /**\r\n   * Updates auth token for registration\r\n   * @param {string} token Authentication token for registrations\r\n   */\n\n\n  async updateToken(token) {\n    logger_1.log.info('authTokenUpdated');\n\n    if (this.services.config.token === token) {\n      return;\n    }\n\n    await this.services.twilsock.updateToken(token);\n    this.services.config.updateToken(token);\n    this.registrar.updateToken(token);\n  }\n\n}\n\nexports.Client = Client;\n/**\r\n * Fired when new message arrived.\r\n * @param {Object} message`\r\n * @event Client#message\r\n */\n\n/**\r\n * Fired when transport state has changed\r\n * @param {boolean} transport state\r\n * @event Client#transportReady\r\n */\n\n/**\r\n * Fired when transport state has been changed\r\n * @param {string} transport state\r\n * @event Client#connectionStateChanged\r\n */\n\n/**\r\n * These options can be passed to Client constructor\r\n * @typedef {Object} Notifications#ClientOptions\r\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\r\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\r\n */","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilio-notifications/lib/client.js"],"names":["Object","defineProperty","exports","value","Client","events_1","require","twilsock_1","configuration_1","registrar_1","logger_1","EventEmitter","constructor","token","options","length","Error","logLevel","log","setLevel","minTokenRefreshInterval","productId","twilsockClient","TwilsockClient","transport","services","twilsock","config","Configuration","registrar","Registrar","reliableTransportState","overall","registration","lastEmitted","_onTransportStateChange","isConnected","on","state","_onRegistrationStateChange","_onNeedReliableTransport","bind","type","message","_routeMessage","notificationId","setNotificationId","updateToken","connectionState","trace","emit","isNeeded","connect","disconnect","_updateTransportState","connected","overallState","info","subscribe","messageType","channelType","unsubscribe","handlePushNotification","twi_message_type","payload","setPushRegistrationId","registrationId"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Client = void 0;\r\nconst events_1 = require(\"events\");\r\nconst twilsock_1 = require(\"twilsock\");\r\nconst configuration_1 = require(\"./configuration\");\r\nconst registrar_1 = require(\"./registrar\");\r\nconst logger_1 = require(\"./logger\");\r\n/**\r\n * @class\r\n * @alias Notifications\r\n * @classdesc The helper library for the notification service.\r\n * Provides high level api for creating and managing notification subscriptions and receiving messages\r\n * Creates the instance of Notification helper library\r\n *\r\n * @constructor\r\n * @param {string} token - Twilio access token\r\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\r\n */\r\nclass Client extends events_1.EventEmitter {\r\n    constructor(token, options = {}) {\r\n        super();\r\n        if (!token || token.length === 0) {\r\n            throw new Error('Token is required for Notifications client');\r\n        }\r\n        options.logLevel = options.logLevel || 'error';\r\n        logger_1.log.setLevel(options.logLevel);\r\n        const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\r\n        const productId = options.productId || 'notifications';\r\n        options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\r\n        options.transport = options.transport || options.twilsockClient;\r\n        this.services = {\r\n            twilsock: options.twilsockClient,\r\n            transport: options.transport,\r\n            config: new configuration_1.Configuration(null, options)\r\n        };\r\n        this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);\r\n        this.reliableTransportState = {\r\n            overall: false,\r\n            transport: false,\r\n            registration: false,\r\n            lastEmitted: null\r\n        };\r\n        this._onTransportStateChange(this.services.twilsock.isConnected);\r\n        this.registrar.on('transportReady', state => {\r\n            this._onRegistrationStateChange(state ? 'registered' : '');\r\n        });\r\n        this.registrar.on('stateChanged', (state) => {\r\n            this._onRegistrationStateChange(state);\r\n        });\r\n        this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));\r\n        this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));\r\n        this.services.twilsock.on('connected', (notificationId) => {\r\n            this._onTransportStateChange(true);\r\n            this.registrar.setNotificationId('twilsock', notificationId);\r\n        });\r\n        this.services.twilsock.on('disconnected', () => {\r\n            this._onTransportStateChange(false);\r\n        });\r\n        this.services.config.updateToken(token);\r\n        this.registrar.updateToken(token);\r\n    }\r\n    get connectionState() {\r\n        if (this.services.twilsock.state === 'disconnected') {\r\n            return 'disconnected';\r\n        }\r\n        else if (this.services.twilsock.state === 'disconnecting') {\r\n            return 'disconnecting';\r\n        }\r\n        else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\r\n            return 'connected';\r\n        }\r\n        else if (this.services.twilsock.state === 'rejected') {\r\n            return 'denied';\r\n        }\r\n        return 'connecting';\r\n    }\r\n    /**\r\n     * Routes messages to the external subscribers\r\n     * @private\r\n     */\r\n    _routeMessage(type, message) {\r\n        logger_1.log.trace('Message arrived: ', type, message);\r\n        this.emit('message', type, message);\r\n    }\r\n    _onNeedReliableTransport(isNeeded) {\r\n        if (isNeeded) {\r\n            this.services.twilsock.connect();\r\n        }\r\n        else {\r\n            this.services.twilsock.disconnect();\r\n        }\r\n    }\r\n    _onRegistrationStateChange(state) {\r\n        this.reliableTransportState.registration = (state === 'registered');\r\n        this._updateTransportState();\r\n    }\r\n    _onTransportStateChange(connected) {\r\n        this.reliableTransportState.transport = connected;\r\n        this._updateTransportState();\r\n    }\r\n    _updateTransportState() {\r\n        const overallState = this.reliableTransportState.transport\r\n            && this.reliableTransportState.registration;\r\n        if (this.reliableTransportState.overall !== overallState) {\r\n            this.reliableTransportState.overall = overallState;\r\n            logger_1.log.info('Transport ready:', overallState);\r\n            this.emit('transportReady', overallState);\r\n        }\r\n        if (this.reliableTransportState.lastEmitted !== this.connectionState) {\r\n            this.reliableTransportState.lastEmitted = this.connectionState;\r\n            this.emit('connectionStateChanged', this.connectionState);\r\n        }\r\n    }\r\n    /**\r\n     * Adds the subscription for the given message type\r\n     * @param {string} messageType The type of message that you want to receive\r\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\r\n     */\r\n    subscribe(messageType, channelType = 'twilsock') {\r\n        logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\r\n        return this.registrar.subscribe(messageType, channelType);\r\n    }\r\n    /**\r\n     * Remove the subscription for the particular message type\r\n     * @param {string} messageType The type of message that you don't want to receive anymore\r\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\r\n     */\r\n    unsubscribe(messageType, channelType = 'twilsock') {\r\n        logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\r\n        return this.registrar.unsubscribe(messageType, channelType);\r\n    }\r\n    /**\r\n     * Handle incoming push notification.\r\n     * Client application should call this method when it receives push notifications and pass the received data\r\n     * @param {Object} message push message\r\n     * @return {PushNotification}\r\n     */\r\n    handlePushNotification(message) {\r\n        return {\r\n            messageType: message.twi_message_type,\r\n            payload: message.payload\r\n        };\r\n    }\r\n    /**\r\n     * Set APN/GCM/FCM token to enable application register for a push messages\r\n     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\r\n     */\r\n    setPushRegistrationId(registrationId, channelType) {\r\n        logger_1.log.trace('Set push registration id', registrationId, channelType);\r\n        this.registrar.setNotificationId(channelType, registrationId);\r\n    }\r\n    /**\r\n     * Updates auth token for registration\r\n     * @param {string} token Authentication token for registrations\r\n     */\r\n    async updateToken(token) {\r\n        logger_1.log.info('authTokenUpdated');\r\n        if (this.services.config.token === token) {\r\n            return;\r\n        }\r\n        await this.services.twilsock.updateToken(token);\r\n        this.services.config.updateToken(token);\r\n        this.registrar.updateToken(token);\r\n    }\r\n}\r\nexports.Client = Client;\r\n/**\r\n * Fired when new message arrived.\r\n * @param {Object} message`\r\n * @event Client#message\r\n */\r\n/**\r\n * Fired when transport state has changed\r\n * @param {boolean} transport state\r\n * @event Client#transportReady\r\n */\r\n/**\r\n * Fired when transport state has been changed\r\n * @param {string} transport state\r\n * @event Client#connectionStateChanged\r\n */\r\n/**\r\n * These options can be passed to Client constructor\r\n * @typedef {Object} Notifications#ClientOptions\r\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\r\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\r\n */\r\n"]},"metadata":{},"sourceType":"script"}