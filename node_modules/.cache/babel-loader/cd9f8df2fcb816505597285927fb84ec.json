{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"../logger\");\n\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\n\nconst twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\n\nconst Messages = require(\"../protocol/messages\");\n\nconst transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\n\nconst REQUEST_TIMEOUT = 20000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n\nfunction isHttpReply(packet) {\n  return packet && packet.header && packet.header.http_status;\n}\n\nclass Request {}\n\nfunction parseUri(uri) {\n  const match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n\n  if (match) {\n    let uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: null\n    };\n\n    if (uriStruct.search.length > 0) {\n      let paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString.split('&').map(el => el.split('=')).reduce((prev, curr) => {\n        if (!prev.hasOwnProperty(curr[0])) {\n          prev[curr[0]] = curr[1];\n        } else if (Array.isArray(prev[curr[0]])) {\n          prev[curr[0]].push(curr[1]);\n        } else {\n          prev[curr[0]] = [prev[curr[0]], curr[1]];\n        }\n\n        return prev;\n      }, {});\n    }\n\n    return uriStruct;\n  }\n\n  throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\n\nfunction twilsockAddress(method, uri) {\n  const parsedUri = parseUri(uri);\n  let to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname\n  };\n\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n\n  return to;\n}\n\nfunction twilsockParams(method, uri, headers, body, grant) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body,\n    grant: grant\n  };\n}\n\nclass Upstream {\n  constructor(transport, twilsock, config) {\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n\n  saveMessage(message) {\n    return new Promise((resolve, reject) => {\n      let requestDescriptor = {\n        message,\n        resolve: resolve,\n        reject: reject,\n        alreadyRejected: false,\n        timeout: setTimeout(() => {\n          logger_1.log.debug('request is timed out');\n          reject(new twilsockerror_1.TwilsockError(`request '${message.to.method}' to '${message.to.host}' timed out`));\n          requestDescriptor.alreadyRejected = true;\n        }, REQUEST_TIMEOUT)\n      };\n      this.pendingMessages.push(requestDescriptor);\n    });\n  }\n\n  sendPendingMessages() {\n    while (this.pendingMessages.length) {\n      let request = this.pendingMessages[0]; // Do not send message if we've rejected its promise already\n\n      if (!request.alreadyRejected) {\n        try {\n          let message = request.message;\n          this.actualSend(message).then(response => request.resolve(response)).catch(e => request.reject(e));\n          clearTimeout(request.timeout);\n        } catch (e) {\n          logger_1.log.debug('Failed to send pending message', e);\n          break;\n        }\n      }\n\n      this.pendingMessages.splice(0, 1);\n    }\n  }\n\n  rejectPendingMessages() {\n    this.pendingMessages.forEach(message => {\n      message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n      clearTimeout(message.timeout);\n    });\n    this.pendingMessages.splice(0, this.pendingMessages.length);\n  }\n\n  async actualSend(message) {\n    let address = message.to;\n    let headers = message.headers;\n    let body = message.body;\n    let grant = message.grant ? message.grant : this.config.activeGrant;\n    let httpRequest = {\n      host: address.host,\n      path: address.path,\n      method: address.method,\n      params: address.params,\n      headers: headers\n    };\n    let upstreamMessage = new Messages.Message(grant, headers['Content-Type'] || 'application/json', httpRequest);\n    let reply = await this.transport.sendWithReply(upstreamMessage, body);\n\n    if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\n      throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n    }\n\n    return {\n      status: reply.header.http_status,\n      headers: reply.header.http_headers,\n      body: reply.body\n    };\n  }\n  /**\r\n   * Send an upstream message\r\n   * @param {string} method The upstream method\r\n   * @param {string} url URL to send the message to\r\n   * @param {object} [headers] The message headers\r\n   * @param {any} [body] The message body\r\n   * @param {string} [grant] The product grant\r\n   * @returns {Promise<Result>} Result from remote side\r\n   */\n\n\n  send(method, url, headers = {}, body, grant) {\n    if (this.twilsock.isTerminalState) {\n      return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n    }\n\n    let twilsockMessage = twilsockParams(method, url, headers, body, grant);\n\n    if (!this.twilsock.isConnected) {\n      return this.saveMessage(twilsockMessage);\n    }\n\n    return this.actualSend(twilsockMessage);\n  }\n\n}\n\nexports.Upstream = Upstream;","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilsock/lib/services/upstream.js"],"names":["Object","defineProperty","exports","value","logger_1","require","twilsockerror_1","twilsockupstreamerror_1","Messages","transportunavailableerror_1","REQUEST_TIMEOUT","isHttpSuccess","code","isHttpReply","packet","header","http_status","Request","parseUri","uri","match","uriStruct","protocol","host","hostname","port","pathname","search","hash","params","length","paramsString","substring","split","map","el","reduce","prev","curr","hasOwnProperty","Array","isArray","push","TwilsockError","twilsockAddress","method","parsedUri","to","path","twilsockParams","headers","body","grant","Upstream","constructor","transport","twilsock","config","pendingMessages","saveMessage","message","Promise","resolve","reject","requestDescriptor","alreadyRejected","timeout","setTimeout","log","debug","sendPendingMessages","request","actualSend","then","response","catch","e","clearTimeout","splice","rejectPendingMessages","forEach","TransportUnavailableError","getTerminationReason","address","activeGrant","httpRequest","upstreamMessage","Message","reply","sendWithReply","TwilsockUpstreamError","status","http_headers","send","url","isTerminalState","twilsockMessage","isConnected"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logger_1 = require(\"../logger\");\r\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\r\nconst twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\r\nconst Messages = require(\"../protocol/messages\");\r\nconst transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\r\nconst REQUEST_TIMEOUT = 20000;\r\nfunction isHttpSuccess(code) {\r\n    return (code >= 200 && code < 300);\r\n}\r\nfunction isHttpReply(packet) {\r\n    return packet && packet.header && packet.header.http_status;\r\n}\r\nclass Request {\r\n}\r\nfunction parseUri(uri) {\r\n    const match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\r\n    if (match) {\r\n        let uriStruct = {\r\n            protocol: match[1],\r\n            host: match[2],\r\n            hostname: match[3],\r\n            port: match[4],\r\n            pathname: match[5],\r\n            search: match[6],\r\n            hash: match[7],\r\n            params: null\r\n        };\r\n        if (uriStruct.search.length > 0) {\r\n            let paramsString = uriStruct.search.substring(1);\r\n            uriStruct.params = paramsString.split('&')\r\n                .map(el => el.split('='))\r\n                .reduce((prev, curr) => {\r\n                if (!prev.hasOwnProperty(curr[0])) {\r\n                    prev[curr[0]] = curr[1];\r\n                }\r\n                else if (Array.isArray(prev[curr[0]])) {\r\n                    prev[curr[0]].push(curr[1]);\r\n                }\r\n                else {\r\n                    prev[curr[0]] = [prev[curr[0]], curr[1]];\r\n                }\r\n                return prev;\r\n            }, {});\r\n        }\r\n        return uriStruct;\r\n    }\r\n    throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\r\n}\r\nfunction twilsockAddress(method, uri) {\r\n    const parsedUri = parseUri(uri);\r\n    let to = {\r\n        method: method,\r\n        host: parsedUri.host,\r\n        path: parsedUri.pathname\r\n    };\r\n    if (parsedUri.params) {\r\n        to.params = parsedUri.params;\r\n    }\r\n    return to;\r\n}\r\nfunction twilsockParams(method, uri, headers, body, grant) {\r\n    return {\r\n        to: twilsockAddress(method, uri),\r\n        headers: headers,\r\n        body: body,\r\n        grant: grant\r\n    };\r\n}\r\nclass Upstream {\r\n    constructor(transport, twilsock, config) {\r\n        this.config = config;\r\n        this.transport = transport;\r\n        this.pendingMessages = [];\r\n        this.twilsock = twilsock;\r\n    }\r\n    saveMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            let requestDescriptor = {\r\n                message,\r\n                resolve: resolve,\r\n                reject: reject,\r\n                alreadyRejected: false,\r\n                timeout: setTimeout(() => {\r\n                    logger_1.log.debug('request is timed out');\r\n                    reject(new twilsockerror_1.TwilsockError(`request '${message.to.method}' to '${message.to.host}' timed out`));\r\n                    requestDescriptor.alreadyRejected = true;\r\n                }, REQUEST_TIMEOUT)\r\n            };\r\n            this.pendingMessages.push(requestDescriptor);\r\n        });\r\n    }\r\n    sendPendingMessages() {\r\n        while (this.pendingMessages.length) {\r\n            let request = this.pendingMessages[0];\r\n            // Do not send message if we've rejected its promise already\r\n            if (!request.alreadyRejected) {\r\n                try {\r\n                    let message = request.message;\r\n                    this.actualSend(message)\r\n                        .then(response => request.resolve(response))\r\n                        .catch(e => request.reject(e));\r\n                    clearTimeout(request.timeout);\r\n                }\r\n                catch (e) {\r\n                    logger_1.log.debug('Failed to send pending message', e);\r\n                    break;\r\n                }\r\n            }\r\n            this.pendingMessages.splice(0, 1);\r\n        }\r\n    }\r\n    rejectPendingMessages() {\r\n        this.pendingMessages.forEach(message => {\r\n            message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\r\n            clearTimeout(message.timeout);\r\n        });\r\n        this.pendingMessages.splice(0, this.pendingMessages.length);\r\n    }\r\n    async actualSend(message) {\r\n        let address = message.to;\r\n        let headers = message.headers;\r\n        let body = message.body;\r\n        let grant = message.grant ? message.grant : this.config.activeGrant;\r\n        let httpRequest = {\r\n            host: address.host,\r\n            path: address.path,\r\n            method: address.method,\r\n            params: address.params,\r\n            headers: headers\r\n        };\r\n        let upstreamMessage = new Messages.Message(grant, headers['Content-Type'] || 'application/json', httpRequest);\r\n        let reply = await this.transport.sendWithReply(upstreamMessage, body);\r\n        if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\r\n            throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\r\n        }\r\n        return {\r\n            status: reply.header.http_status,\r\n            headers: reply.header.http_headers,\r\n            body: reply.body\r\n        };\r\n    }\r\n    /**\r\n     * Send an upstream message\r\n     * @param {string} method The upstream method\r\n     * @param {string} url URL to send the message to\r\n     * @param {object} [headers] The message headers\r\n     * @param {any} [body] The message body\r\n     * @param {string} [grant] The product grant\r\n     * @returns {Promise<Result>} Result from remote side\r\n     */\r\n    send(method, url, headers = {}, body, grant) {\r\n        if (this.twilsock.isTerminalState) {\r\n            return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\r\n        }\r\n        let twilsockMessage = twilsockParams(method, url, headers, body, grant);\r\n        if (!this.twilsock.isConnected) {\r\n            return this.saveMessage(twilsockMessage);\r\n        }\r\n        return this.actualSend(twilsockMessage);\r\n    }\r\n}\r\nexports.Upstream = Upstream;\r\n"]},"metadata":{},"sourceType":"script"}