{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncDocumentImpl = exports.SyncDocument = void 0;\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n  /**\r\n   * @private\r\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n    this.isDeleted = false;\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n    this.descriptor = descriptor;\n    this.descriptor.data = this.descriptor.data || {};\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'document';\n  }\n\n  get type() {\n    return 'document';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get value() {\n    return this.descriptor.data;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n  /**\r\n   * Update data entity with new data\r\n   * @private\r\n   */\n\n\n  _update(update) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'document_updated':\n        if (update.id > this.lastEventId) {\n          this.descriptor.last_event_id = update.id;\n          this.descriptor.revision = update.document_revision;\n          this.descriptor.date_updated = update.date_created;\n          this.descriptor.data = update.document_data;\n          this.broadcastEventToListeners('updated', {\n            value: update.document_data,\n            isLocal: false\n          });\n          this.services.storage.update(this.type, this.sid, this.uniqueName, {\n            last_event_id: update.id,\n            revision: update.document_revision,\n            date_updated: update.date_created,\n            data: update.document_data\n          });\n        } else {\n          logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n        }\n\n        break;\n\n      case 'document_removed':\n        this.onRemoved(false);\n        break;\n    }\n  }\n\n  async set(value, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n  }\n\n  async mutate(mutator, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n  }\n\n  async update(obj, metadataUpdates) {\n    return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    const response = await this._postUpdateToServer({\n      ttl\n    });\n    this.descriptor.date_expires = response.date_expires;\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  async _setUnconditionally(value, ttl) {\n    let result = await this._postUpdateToServer({\n      data: value,\n      revision: undefined,\n      ttl\n    });\n\n    this._handleSuccessfulUpdateResult(result);\n\n    return this.value;\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  async _setWithIfMatch(mutatorFunction, ttl) {\n    let data = mutatorFunction(sanitize_1.deepClone(this.value));\n\n    if (data) {\n      let revision = this.revision;\n\n      try {\n        let result = await this._postUpdateToServer({\n          data,\n          revision,\n          ttl\n        });\n\n        this._handleSuccessfulUpdateResult(result);\n\n        return this.value;\n      } catch (error) {\n        if (error.status === 412) {\n          await this._softSync();\n          return this._setWithIfMatch(mutatorFunction);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return this.value;\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _handleSuccessfulUpdateResult(result) {\n    if (result.last_event_id > this.descriptor.last_event_id) {\n      // Ignore returned value if we already got a newer one\n      this.descriptor.revision = result.revision;\n      this.descriptor.data = result.data;\n      this.descriptor.last_event_id = result.last_event_id;\n      this.descriptor.date_expires = result.date_expires;\n      this.descriptor.date_updated = new Date(result.date_updated);\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        last_event_id: result.last_event_id,\n        revision: result.revision,\n        date_updated: result.date_updated,\n        data: result.data\n      });\n      this.broadcastEventToListeners('updated', {\n        value: this.value,\n        isLocal: true\n      });\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  async _postUpdateToServer(request) {\n    if (!this.isDeleted) {\n      const requestBody = {\n        data: request.data\n      };\n\n      if (request.ttl !== undefined) {\n        requestBody.ttl = request.ttl;\n      }\n\n      const ifMatch = request.revision;\n\n      try {\n        const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n        return {\n          revision: response.body.revision,\n          data: request.data,\n          last_event_id: response.body.last_event_id,\n          date_updated: response.body.date_updated,\n          date_expires: response.body.date_expires\n        };\n      } catch (error) {\n        if (error.status === 404) {\n          this.onRemoved(false);\n        }\n\n        throw error;\n      }\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n  /**\r\n   * Get new data from server\r\n   * @private\r\n   */\n\n\n  async _softSync() {\n    return this.services.network.get(this.uri).then(response => {\n      const event = {\n        type: 'document_updated',\n        id: response.body.last_event_id,\n        document_revision: response.body.revision,\n        document_data: response.body.data,\n        date_created: response.body.date_updated\n      };\n\n      this._update(event);\n\n      return this;\n    }).catch(err => {\n      if (err.status === 404) {\n        this.onRemoved(false);\n      } else {\n        logger_1.default.error(`Can't get updates for ${this.sid}:`, err);\n      }\n    });\n  }\n\n  onRemoved(locally) {\n    if (this.isDeleted) {\n      return;\n    } else {\n      this.isDeleted = true;\n\n      this._unsubscribe();\n\n      this.removalHandler(this.type, this.sid, this.uniqueName);\n      this.broadcastEventToListeners('removed', {\n        isLocal: locally\n      });\n    }\n  }\n\n  async removeDocument() {\n    if (!this.isDeleted) {\n      await this.services.network.delete(this.uri);\n      this.onRemoved(true);\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n\n}\n\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\r\n * @class\r\n * @alias Document\r\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\r\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\r\n * @property {String} sid The immutable identifier of this document, assigned by the system.\r\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\r\n * to this document during creation. Globally unique among other Documents.\r\n * @property {Date} dateUpdated Date when the Document was last updated.\r\n * @property {Object} value The contents of this document.\r\n *\r\n * @fires Document#removed\r\n * @fires Document#updated\r\n */\n\nclass SyncDocument extends closeable_1.default {\n  constructor(syncDocumentImpl) {\n    super();\n    this.syncDocumentImpl = syncDocumentImpl;\n    this.syncDocumentImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncDocumentImpl.uri;\n  }\n\n  get revision() {\n    return this.syncDocumentImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncDocumentImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncDocumentImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncDocumentImpl.type;\n  }\n\n  get type() {\n    return SyncDocumentImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncDocumentImpl.sid;\n  }\n\n  get value() {\n    return this.syncDocumentImpl.value;\n  }\n\n  get dateUpdated() {\n    return this.syncDocumentImpl.dateUpdated;\n  }\n\n  get uniqueName() {\n    return this.syncDocumentImpl.uniqueName;\n  }\n  /**\r\n   * Assign new contents to this document. The current value will be overwritten.\r\n   * @param {Object} value The new contents to assign.\r\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\r\n   * @returns {Promise<Object>} A promise resolving to the new value of the document.\r\n   * @public\r\n   * @example\r\n   * // Say, the Document value is { name: 'John Smith', age: 34 }\r\n   * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\r\n   *   .then(function(newValue) {\r\n   *     // Now the Document value is { name: 'Barbara Oaks' }\r\n   *     console.log('Document set() successful, new value:', newValue);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Document set() failed', error);\r\n   *   });\r\n   */\n\n\n  async set(value, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.set(value, metadataUpdates);\n  }\n  /**\r\n   * Schedules a modification to this document that will apply a mutation function.\r\n   * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\r\n   * May be called multiple times, particularly if this Document is modified concurrently by remote code.\r\n   * If the mutation ultimately succeeds, the Document will have made the particular transition described\r\n   * by this function.\r\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\r\n   * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\r\n   *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\r\n   * @public\r\n   * @example\r\n   * var mutatorFunction = function(currentValue) {\r\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\r\n   *     return currentValue;\r\n   * };\r\n   * document.mutate(mutatorFunction, { ttl: 86400 }))\r\n   *   .then(function(newValue) {\r\n   *     console.log('Document mutate() successful, new value:', newValue);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Document mutate() failed', error);\r\n   *   });\r\n   */\n\n\n  async mutate(mutator, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n  }\n  /**\r\n   * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\r\n   * This is equivalent to\r\n   * <pre>\r\n   * document.mutate(function(currentValue) {\r\n   *   return Object.assign(currentValue, obj));\r\n   * });\r\n   * </pre>\r\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\r\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\r\n   * @return {Promise<Object>} A promise resolving to the new value of the document.\r\n   * @public\r\n   * @example\r\n   * // Say, the Document value is { name: 'John Smith' }\r\n   * document.update({ age: 34 }, { ttl: 86400 })\r\n   *   .then(function(newValue) {\r\n   *     // Now the Document value is { name: 'John Smith', age: 34 }\r\n   *     console.log('Document update() successful, new value:', newValue);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Document update() failed', error);\r\n   *   });\r\n   */\n\n\n  async update(obj, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.update(obj, metadataUpdates);\n  }\n  /**\r\n   * Update the time-to-live of the document.\r\n   * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\r\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n   * @public\r\n   * @example\r\n   * document.setTtl(3600)\r\n   *   .then(function() {\r\n   *     console.log('Document setTtl() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Document setTtl() failed', error);\r\n   *   });\r\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.setTtl(ttl);\n  }\n  /**\r\n   * Delete a document.\r\n   * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\r\n   * @public\r\n   * @example\r\n   * document.removeDocument()\r\n   *   .then(function() {\r\n   *     console.log('Document removeDocument() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Document removeDocument() failed', error);\r\n   *   });\r\n   */\n\n\n  async removeDocument() {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.removeDocument();\n  }\n  /**\r\n   * Conclude work with the document instance and remove all event listeners attached to it.\r\n   * Any subsequent operation on this object will be rejected with error.\r\n   * Other local copies of this document will continue operating and receiving events normally.\r\n   * @public\r\n   * @example\r\n   * document.close();\r\n   */\n\n\n  close() {\n    super.close();\n    this.syncDocumentImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\r\n * Contains Document metadata.\r\n * @typedef {Object} Document#Metadata\r\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\r\n * The value 0 means infinity.\r\n */\n\n/**\r\n * Applies a transformation to the document value.\r\n * @callback Document~Mutator\r\n * @param {Object} currentValue The current value of the document in the cloud.\r\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\r\n */\n\n/**\r\n * Fired when the document is removed, whether the remover was local or remote.\r\n * @event Document#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\r\n * @example\r\n * document.on('removed', function(args) {\r\n *   console.log('Document ' + document.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when the document's contents have changed, whether the updater was local or remote.\r\n * @event Document#updated\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Object} args.value A snapshot of the document's new contents.\r\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\r\n * @example\r\n * document.on('updated', function(args) {\r\n *   console.log('Document ' + document.sid + ' was updated');\r\n *   console.log('args.value: ', args.value);\r\n *   console.log('args.isLocal: ', args.isLocal);\r\n * });\r\n */","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilio-sync/lib/syncdocument.js"],"names":["Object","defineProperty","exports","value","SyncDocumentImpl","SyncDocument","syncerror_1","require","sanitize_1","logger_1","entity_1","mergingqueue_1","closeable_1","SyncEntity","constructor","services","descriptor","removalHandler","isDeleted","updateRequestReducer","acc","input","ttl","updateMergingQueue","MergingQueue","data","date_updated","Date","uri","url","revision","lastEventId","last_event_id","dateExpires","date_expires","type","indexName","undefined","queryString","sid","dateUpdated","uniqueName","unique_name","_update","update","date_created","id","document_revision","document_data","broadcastEventToListeners","isLocal","storage","default","trace","onRemoved","set","metadataUpdates","validateOptionalTtl","squashAndAdd","_setUnconditionally","mutate","mutator","add","_setWithIfMatch","obj","remote","assign","setTtl","validateMandatoryTtl","response","_postUpdateToServer","result","_handleSuccessfulUpdateResult","mutatorFunction","deepClone","error","status","_softSync","request","requestBody","ifMatch","network","post","body","Promise","reject","SyncError","get","then","event","catch","err","locally","_unsubscribe","removeDocument","delete","syncDocumentImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gBAAR,GAA2BF,OAAO,CAACG,YAAR,GAAuB,KAAK,CAAvD;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMI,cAAc,GAAGJ,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMH,gBAAN,SAA+BM,QAAQ,CAACG,UAAxC,CAAmD;AAC/C;AACJ;AACA;AACIC,EAAAA,WAAW,CAACC,QAAD,EAAWC,UAAX,EAAuBC,cAAvB,EAAuC;AAC9C,UAAMF,QAAN,EAAgBE,cAAhB;AACA,SAAKC,SAAL,GAAiB,KAAjB;;AACA,UAAMC,oBAAoB,GAAG,CAACC,GAAD,EAAMC,KAAN,KAAiB,OAAOA,KAAK,CAACC,GAAb,KAAqB,QAAtB,GAAkC;AAAEA,MAAAA,GAAG,EAAED,KAAK,CAACC;AAAb,KAAlC,GACvCF,GADN;;AAEA,SAAKG,kBAAL,GAA0B,IAAIZ,cAAc,CAACa,YAAnB,CAAgCL,oBAAhC,CAA1B;AACA,SAAKH,UAAL,GAAkBA,UAAlB;AACA,SAAKA,UAAL,CAAgBS,IAAhB,GAAuB,KAAKT,UAAL,CAAgBS,IAAhB,IAAwB,EAA/C;AACA,SAAKT,UAAL,CAAgBU,YAAhB,GAA+B,IAAIC,IAAJ,CAAS,KAAKX,UAAL,CAAgBU,YAAzB,CAA/B;AACH,GAb8C,CAc/C;;;AACO,MAAHE,GAAG,GAAG;AACN,WAAO,KAAKZ,UAAL,CAAgBa,GAAvB;AACH;;AACW,MAARC,QAAQ,GAAG;AACX,WAAO,KAAKd,UAAL,CAAgBc,QAAvB;AACH;;AACc,MAAXC,WAAW,GAAG;AACd,WAAO,KAAKf,UAAL,CAAgBgB,aAAvB;AACH;;AACc,MAAXC,WAAW,GAAG;AACd,WAAO,KAAKjB,UAAL,CAAgBkB,YAAvB;AACH;;AACc,aAAJC,IAAI,GAAG;AACd,WAAO,UAAP;AACH;;AACO,MAAJA,IAAI,GAAG;AACP,WAAO,UAAP;AACH,GAhC8C,CAiC/C;;;AACa,MAATC,SAAS,GAAG;AACZ,WAAOC,SAAP;AACH;;AACc,MAAXC,WAAW,GAAG;AACd,WAAOD,SAAP;AACH,GAvC8C,CAwC/C;;;AACO,MAAHE,GAAG,GAAG;AACN,WAAO,KAAKvB,UAAL,CAAgBuB,GAAvB;AACH;;AACQ,MAALpC,KAAK,GAAG;AACR,WAAO,KAAKa,UAAL,CAAgBS,IAAvB;AACH;;AACc,MAAXe,WAAW,GAAG;AACd,WAAO,KAAKxB,UAAL,CAAgBU,YAAvB;AACH;;AACa,MAAVe,UAAU,GAAG;AACb,WAAO,KAAKzB,UAAL,CAAgB0B,WAAhB,IAA+B,IAAtC;AACH;AACD;AACJ;AACA;AACA;;;AACIC,EAAAA,OAAO,CAACC,MAAD,EAAS;AACZA,IAAAA,MAAM,CAACC,YAAP,GAAsB,IAAIlB,IAAJ,CAASiB,MAAM,CAACC,YAAhB,CAAtB;;AACA,YAAQD,MAAM,CAACT,IAAf;AACI,WAAK,kBAAL;AACI,YAAIS,MAAM,CAACE,EAAP,GAAY,KAAKf,WAArB,EAAkC;AAC9B,eAAKf,UAAL,CAAgBgB,aAAhB,GAAgCY,MAAM,CAACE,EAAvC;AACA,eAAK9B,UAAL,CAAgBc,QAAhB,GAA2Bc,MAAM,CAACG,iBAAlC;AACA,eAAK/B,UAAL,CAAgBU,YAAhB,GAA+BkB,MAAM,CAACC,YAAtC;AACA,eAAK7B,UAAL,CAAgBS,IAAhB,GAAuBmB,MAAM,CAACI,aAA9B;AACA,eAAKC,yBAAL,CAA+B,SAA/B,EAA0C;AAAE9C,YAAAA,KAAK,EAAEyC,MAAM,CAACI,aAAhB;AAA+BE,YAAAA,OAAO,EAAE;AAAxC,WAA1C;AACA,eAAKnC,QAAL,CAAcoC,OAAd,CAAsBP,MAAtB,CAA6B,KAAKT,IAAlC,EAAwC,KAAKI,GAA7C,EAAkD,KAAKE,UAAvD,EAAmE;AAC/DT,YAAAA,aAAa,EAAEY,MAAM,CAACE,EADyC;AAE/DhB,YAAAA,QAAQ,EAAEc,MAAM,CAACG,iBAF8C;AAG/DrB,YAAAA,YAAY,EAAEkB,MAAM,CAACC,YAH0C;AAI/DpB,YAAAA,IAAI,EAAEmB,MAAM,CAACI;AAJkD,WAAnE;AAMH,SAZD,MAaK;AACDvC,UAAAA,QAAQ,CAAC2C,OAAT,CAAiBC,KAAjB,CAAuB,mCAAvB,EAA4D,KAAKtB,WAAjE,EAA8E,WAA9E,EAA2Fa,MAAM,CAACE,EAAlG;AACH;;AACD;;AACJ,WAAK,kBAAL;AACI,aAAKQ,SAAL,CAAe,KAAf;AACA;AArBR;AAuBH;;AACQ,QAAHC,GAAG,CAACpD,KAAD,EAAQqD,eAAR,EAAyB;AAC9B,UAAMnC,KAAK,GAAGmC,eAAe,IAAI,EAAjC;AACAhD,IAAAA,UAAU,CAACiD,mBAAX,CAA+BpC,KAAK,CAACC,GAArC;AACA,WAAO,KAAKC,kBAAL,CAAwBmC,YAAxB,CAAqCrC,KAArC,EAA4CA,KAAK,IAAI,KAAKsC,mBAAL,CAAyBxD,KAAzB,EAAgCkB,KAAK,CAACC,GAAtC,CAArD,CAAP;AACH;;AACW,QAANsC,MAAM,CAACC,OAAD,EAAUL,eAAV,EAA2B;AACnC,UAAMnC,KAAK,GAAGmC,eAAe,IAAI,EAAjC;AACAhD,IAAAA,UAAU,CAACiD,mBAAX,CAA+BpC,KAAK,CAACC,GAArC;AACA,WAAO,KAAKC,kBAAL,CAAwBuC,GAAxB,CAA4BzC,KAA5B,EAAmCA,KAAK,IAAI,KAAK0C,eAAL,CAAqBF,OAArB,EAA8BxC,KAAK,CAACC,GAApC,CAA5C,CAAP;AACH;;AACW,QAANsB,MAAM,CAACoB,GAAD,EAAMR,eAAN,EAAuB;AAC/B,WAAO,KAAKI,MAAL,CAAYK,MAAM,IAAIjE,MAAM,CAACkE,MAAP,CAAcD,MAAd,EAAsBD,GAAtB,CAAtB,EAAkDR,eAAlD,CAAP;AACH;;AACW,QAANW,MAAM,CAAC7C,GAAD,EAAM;AACdd,IAAAA,UAAU,CAAC4D,oBAAX,CAAgC9C,GAAhC;AACA,UAAM+C,QAAQ,GAAG,MAAM,KAAKC,mBAAL,CAAyB;AAAEhD,MAAAA;AAAF,KAAzB,CAAvB;AACA,SAAKN,UAAL,CAAgBkB,YAAhB,GAA+BmC,QAAQ,CAACnC,YAAxC;AACH;AACD;AACJ;AACA;;;AAC6B,QAAnByB,mBAAmB,CAACxD,KAAD,EAAQmB,GAAR,EAAa;AAClC,QAAIiD,MAAM,GAAG,MAAM,KAAKD,mBAAL,CAAyB;AAAE7C,MAAAA,IAAI,EAAEtB,KAAR;AAAe2B,MAAAA,QAAQ,EAAEO,SAAzB;AAAoCf,MAAAA;AAApC,KAAzB,CAAnB;;AACA,SAAKkD,6BAAL,CAAmCD,MAAnC;;AACA,WAAO,KAAKpE,KAAZ;AACH;AACD;AACJ;AACA;;;AACyB,QAAf4D,eAAe,CAACU,eAAD,EAAkBnD,GAAlB,EAAuB;AACxC,QAAIG,IAAI,GAAGgD,eAAe,CAACjE,UAAU,CAACkE,SAAX,CAAqB,KAAKvE,KAA1B,CAAD,CAA1B;;AACA,QAAIsB,IAAJ,EAAU;AACN,UAAIK,QAAQ,GAAG,KAAKA,QAApB;;AACA,UAAI;AACA,YAAIyC,MAAM,GAAG,MAAM,KAAKD,mBAAL,CAAyB;AAAE7C,UAAAA,IAAF;AAAQK,UAAAA,QAAR;AAAkBR,UAAAA;AAAlB,SAAzB,CAAnB;;AACA,aAAKkD,6BAAL,CAAmCD,MAAnC;;AACA,eAAO,KAAKpE,KAAZ;AACH,OAJD,CAKA,OAAOwE,KAAP,EAAc;AACV,YAAIA,KAAK,CAACC,MAAN,KAAiB,GAArB,EAA0B;AACtB,gBAAM,KAAKC,SAAL,EAAN;AACA,iBAAO,KAAKd,eAAL,CAAqBU,eAArB,CAAP;AACH,SAHD,MAIK;AACD,gBAAME,KAAN;AACH;AACJ;AACJ,KAhBD,MAiBK;AACD,aAAO,KAAKxE,KAAZ;AACH;AACJ;AACD;AACJ;AACA;;;AACIqE,EAAAA,6BAA6B,CAACD,MAAD,EAAS;AAClC,QAAIA,MAAM,CAACvC,aAAP,GAAuB,KAAKhB,UAAL,CAAgBgB,aAA3C,EAA0D;AACtD;AACA,WAAKhB,UAAL,CAAgBc,QAAhB,GAA2ByC,MAAM,CAACzC,QAAlC;AACA,WAAKd,UAAL,CAAgBS,IAAhB,GAAuB8C,MAAM,CAAC9C,IAA9B;AACA,WAAKT,UAAL,CAAgBgB,aAAhB,GAAgCuC,MAAM,CAACvC,aAAvC;AACA,WAAKhB,UAAL,CAAgBkB,YAAhB,GAA+BqC,MAAM,CAACrC,YAAtC;AACA,WAAKlB,UAAL,CAAgBU,YAAhB,GAA+B,IAAIC,IAAJ,CAAS4C,MAAM,CAAC7C,YAAhB,CAA/B;AACA,WAAKX,QAAL,CAAcoC,OAAd,CAAsBP,MAAtB,CAA6B,KAAKT,IAAlC,EAAwC,KAAKI,GAA7C,EAAkD,KAAKE,UAAvD,EAAmE;AAC/DT,QAAAA,aAAa,EAAEuC,MAAM,CAACvC,aADyC;AAE/DF,QAAAA,QAAQ,EAAEyC,MAAM,CAACzC,QAF8C;AAG/DJ,QAAAA,YAAY,EAAE6C,MAAM,CAAC7C,YAH0C;AAI/DD,QAAAA,IAAI,EAAE8C,MAAM,CAAC9C;AAJkD,OAAnE;AAMA,WAAKwB,yBAAL,CAA+B,SAA/B,EAA0C;AAAE9C,QAAAA,KAAK,EAAE,KAAKA,KAAd;AAAqB+C,QAAAA,OAAO,EAAE;AAA9B,OAA1C;AACH;AACJ;AACD;AACJ;AACA;;;AAC6B,QAAnBoB,mBAAmB,CAACQ,OAAD,EAAU;AAC/B,QAAI,CAAC,KAAK5D,SAAV,EAAqB;AACjB,YAAM6D,WAAW,GAAG;AAChBtD,QAAAA,IAAI,EAAEqD,OAAO,CAACrD;AADE,OAApB;;AAGA,UAAIqD,OAAO,CAACxD,GAAR,KAAgBe,SAApB,EAA+B;AAC3B0C,QAAAA,WAAW,CAACzD,GAAZ,GAAkBwD,OAAO,CAACxD,GAA1B;AACH;;AACD,YAAM0D,OAAO,GAAGF,OAAO,CAAChD,QAAxB;;AACA,UAAI;AACA,cAAMuC,QAAQ,GAAG,MAAM,KAAKtD,QAAL,CAAckE,OAAd,CAAsBC,IAAtB,CAA2B,KAAKtD,GAAhC,EAAqCmD,WAArC,EAAkDC,OAAlD,CAAvB;AACA,eAAO;AACHlD,UAAAA,QAAQ,EAAEuC,QAAQ,CAACc,IAAT,CAAcrD,QADrB;AAEHL,UAAAA,IAAI,EAAEqD,OAAO,CAACrD,IAFX;AAGHO,UAAAA,aAAa,EAAEqC,QAAQ,CAACc,IAAT,CAAcnD,aAH1B;AAIHN,UAAAA,YAAY,EAAE2C,QAAQ,CAACc,IAAT,CAAczD,YAJzB;AAKHQ,UAAAA,YAAY,EAAEmC,QAAQ,CAACc,IAAT,CAAcjD;AALzB,SAAP;AAOH,OATD,CAUA,OAAOyC,KAAP,EAAc;AACV,YAAIA,KAAK,CAACC,MAAN,KAAiB,GAArB,EAA0B;AACtB,eAAKtB,SAAL,CAAe,KAAf;AACH;;AACD,cAAMqB,KAAN;AACH;AACJ,KAxBD,MAyBK;AACD,aAAOS,OAAO,CAACC,MAAR,CAAe,IAAI/E,WAAW,CAACgF,SAAhB,CAA0B,+BAA1B,EAA2D,GAA3D,EAAgE,KAAhE,CAAf,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACmB,QAATT,SAAS,GAAG;AACd,WAAO,KAAK9D,QAAL,CAAckE,OAAd,CAAsBM,GAAtB,CAA0B,KAAK3D,GAA/B,EACF4D,IADE,CACGnB,QAAQ,IAAI;AAClB,YAAMoB,KAAK,GAAG;AACVtD,QAAAA,IAAI,EAAE,kBADI;AAEVW,QAAAA,EAAE,EAAEuB,QAAQ,CAACc,IAAT,CAAcnD,aAFR;AAGVe,QAAAA,iBAAiB,EAAEsB,QAAQ,CAACc,IAAT,CAAcrD,QAHvB;AAIVkB,QAAAA,aAAa,EAAEqB,QAAQ,CAACc,IAAT,CAAc1D,IAJnB;AAKVoB,QAAAA,YAAY,EAAEwB,QAAQ,CAACc,IAAT,CAAczD;AALlB,OAAd;;AAOA,WAAKiB,OAAL,CAAa8C,KAAb;;AACA,aAAO,IAAP;AACH,KAXM,EAYFC,KAZE,CAYIC,GAAG,IAAI;AACd,UAAIA,GAAG,CAACf,MAAJ,KAAe,GAAnB,EAAwB;AACpB,aAAKtB,SAAL,CAAe,KAAf;AACH,OAFD,MAGK;AACD7C,QAAAA,QAAQ,CAAC2C,OAAT,CAAiBuB,KAAjB,CAAwB,yBAAwB,KAAKpC,GAAI,GAAzD,EAA6DoD,GAA7D;AACH;AACJ,KAnBM,CAAP;AAoBH;;AACDrC,EAAAA,SAAS,CAACsC,OAAD,EAAU;AACf,QAAI,KAAK1E,SAAT,EAAoB;AAChB;AACH,KAFD,MAGK;AACD,WAAKA,SAAL,GAAiB,IAAjB;;AACA,WAAK2E,YAAL;;AACA,WAAK5E,cAAL,CAAoB,KAAKkB,IAAzB,EAA+B,KAAKI,GAApC,EAAyC,KAAKE,UAA9C;AACA,WAAKQ,yBAAL,CAA+B,SAA/B,EAA0C;AAAEC,QAAAA,OAAO,EAAE0C;AAAX,OAA1C;AACH;AACJ;;AACmB,QAAdE,cAAc,GAAG;AACnB,QAAI,CAAC,KAAK5E,SAAV,EAAqB;AACjB,YAAM,KAAKH,QAAL,CAAckE,OAAd,CAAsBc,MAAtB,CAA6B,KAAKnE,GAAlC,CAAN;AACA,WAAK0B,SAAL,CAAe,IAAf;AACH,KAHD,MAIK;AACD,aAAO8B,OAAO,CAACC,MAAR,CAAe,IAAI/E,WAAW,CAACgF,SAAhB,CAA0B,+BAA1B,EAA2D,GAA3D,EAAgE,KAAhE,CAAf,CAAP;AACH;AACJ;;AAzO8C;;AA2OnDpF,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,YAAN,SAA2BO,WAAW,CAACwC,OAAvC,CAA+C;AAC3CtC,EAAAA,WAAW,CAACkF,gBAAD,EAAmB;AAC1B;AACA,SAAKA,gBAAL,GAAwBA,gBAAxB;AACA,SAAKA,gBAAL,CAAsBC,MAAtB,CAA6B,IAA7B;AACH,GAL0C,CAM3C;;;AACO,MAAHrE,GAAG,GAAG;AACN,WAAO,KAAKoE,gBAAL,CAAsBpE,GAA7B;AACH;;AACW,MAARE,QAAQ,GAAG;AACX,WAAO,KAAKkE,gBAAL,CAAsBlE,QAA7B;AACH;;AACc,MAAXC,WAAW,GAAG;AACd,WAAO,KAAKiE,gBAAL,CAAsBjE,WAA7B;AACH;;AACc,MAAXE,WAAW,GAAG;AACd,WAAO,KAAK+D,gBAAL,CAAsB/D,WAA7B;AACH;;AACc,aAAJE,IAAI,GAAG;AACd,WAAO/B,gBAAgB,CAAC+B,IAAxB;AACH;;AACO,MAAJA,IAAI,GAAG;AACP,WAAO/B,gBAAgB,CAAC+B,IAAxB;AACH,GAxB0C,CAyB3C;;;AACO,MAAHI,GAAG,GAAG;AACN,WAAO,KAAKyD,gBAAL,CAAsBzD,GAA7B;AACH;;AACQ,MAALpC,KAAK,GAAG;AACR,WAAO,KAAK6F,gBAAL,CAAsB7F,KAA7B;AACH;;AACc,MAAXqC,WAAW,GAAG;AACd,WAAO,KAAKwD,gBAAL,CAAsBxD,WAA7B;AACH;;AACa,MAAVC,UAAU,GAAG;AACb,WAAO,KAAKuD,gBAAL,CAAsBvD,UAA7B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACa,QAAHc,GAAG,CAACpD,KAAD,EAAQqD,eAAR,EAAyB;AAC9B,SAAK0C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBzC,GAAtB,CAA0BpD,KAA1B,EAAiCqD,eAAjC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANI,MAAM,CAACC,OAAD,EAAUL,eAAV,EAA2B;AACnC,SAAK0C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBpC,MAAtB,CAA6BC,OAA7B,EAAsCL,eAAtC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANZ,MAAM,CAACoB,GAAD,EAAMR,eAAN,EAAuB;AAC/B,SAAK0C,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBpD,MAAtB,CAA6BoB,GAA7B,EAAkCR,eAAlC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANW,MAAM,CAAC7C,GAAD,EAAM;AACd,SAAK4E,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsB7B,MAAtB,CAA6B7C,GAA7B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,QAAdwE,cAAc,GAAG;AACnB,SAAKI,eAAL;AACA,WAAO,KAAKF,gBAAL,CAAsBF,cAAtB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKH,gBAAL,CAAsBI,MAAtB,CAA6B,KAAKC,YAAlC;AACH;;AA/J0C;;AAiK/CnG,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AACAH,OAAO,CAACkD,OAAR,GAAkB/C,YAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SyncDocumentImpl = exports.SyncDocument = void 0;\r\nconst syncerror_1 = require(\"./utils/syncerror\");\r\nconst sanitize_1 = require(\"./utils/sanitize\");\r\nconst logger_1 = require(\"./utils/logger\");\r\nconst entity_1 = require(\"./entity\");\r\nconst mergingqueue_1 = require(\"./mergingqueue\");\r\nconst closeable_1 = require(\"./closeable\");\r\nclass SyncDocumentImpl extends entity_1.SyncEntity {\r\n    /**\r\n     * @private\r\n     */\r\n    constructor(services, descriptor, removalHandler) {\r\n        super(services, removalHandler);\r\n        this.isDeleted = false;\r\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\r\n            : acc;\r\n        this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\r\n        this.descriptor = descriptor;\r\n        this.descriptor.data = this.descriptor.data || {};\r\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.descriptor.url;\r\n    }\r\n    get revision() {\r\n        return this.descriptor.revision;\r\n    }\r\n    get lastEventId() {\r\n        return this.descriptor.last_event_id;\r\n    }\r\n    get dateExpires() {\r\n        return this.descriptor.date_expires;\r\n    }\r\n    static get type() {\r\n        return 'document';\r\n    }\r\n    get type() {\r\n        return 'document';\r\n    }\r\n    // below properties are specific to Insights only\r\n    get indexName() {\r\n        return undefined;\r\n    }\r\n    get queryString() {\r\n        return undefined;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.descriptor.sid;\r\n    }\r\n    get value() {\r\n        return this.descriptor.data;\r\n    }\r\n    get dateUpdated() {\r\n        return this.descriptor.date_updated;\r\n    }\r\n    get uniqueName() {\r\n        return this.descriptor.unique_name || null;\r\n    }\r\n    /**\r\n     * Update data entity with new data\r\n     * @private\r\n     */\r\n    _update(update) {\r\n        update.date_created = new Date(update.date_created);\r\n        switch (update.type) {\r\n            case 'document_updated':\r\n                if (update.id > this.lastEventId) {\r\n                    this.descriptor.last_event_id = update.id;\r\n                    this.descriptor.revision = update.document_revision;\r\n                    this.descriptor.date_updated = update.date_created;\r\n                    this.descriptor.data = update.document_data;\r\n                    this.broadcastEventToListeners('updated', { value: update.document_data, isLocal: false });\r\n                    this.services.storage.update(this.type, this.sid, this.uniqueName, {\r\n                        last_event_id: update.id,\r\n                        revision: update.document_revision,\r\n                        date_updated: update.date_created,\r\n                        data: update.document_data\r\n                    });\r\n                }\r\n                else {\r\n                    logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\r\n                }\r\n                break;\r\n            case 'document_removed':\r\n                this.onRemoved(false);\r\n                break;\r\n        }\r\n    }\r\n    async set(value, metadataUpdates) {\r\n        const input = metadataUpdates || {};\r\n        sanitize_1.validateOptionalTtl(input.ttl);\r\n        return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\r\n    }\r\n    async mutate(mutator, metadataUpdates) {\r\n        const input = metadataUpdates || {};\r\n        sanitize_1.validateOptionalTtl(input.ttl);\r\n        return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\r\n    }\r\n    async update(obj, metadataUpdates) {\r\n        return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\r\n    }\r\n    async setTtl(ttl) {\r\n        sanitize_1.validateMandatoryTtl(ttl);\r\n        const response = await this._postUpdateToServer({ ttl });\r\n        this.descriptor.date_expires = response.date_expires;\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    async _setUnconditionally(value, ttl) {\r\n        let result = await this._postUpdateToServer({ data: value, revision: undefined, ttl });\r\n        this._handleSuccessfulUpdateResult(result);\r\n        return this.value;\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    async _setWithIfMatch(mutatorFunction, ttl) {\r\n        let data = mutatorFunction(sanitize_1.deepClone(this.value));\r\n        if (data) {\r\n            let revision = this.revision;\r\n            try {\r\n                let result = await this._postUpdateToServer({ data, revision, ttl });\r\n                this._handleSuccessfulUpdateResult(result);\r\n                return this.value;\r\n            }\r\n            catch (error) {\r\n                if (error.status === 412) {\r\n                    await this._softSync();\r\n                    return this._setWithIfMatch(mutatorFunction);\r\n                }\r\n                else {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return this.value;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _handleSuccessfulUpdateResult(result) {\r\n        if (result.last_event_id > this.descriptor.last_event_id) {\r\n            // Ignore returned value if we already got a newer one\r\n            this.descriptor.revision = result.revision;\r\n            this.descriptor.data = result.data;\r\n            this.descriptor.last_event_id = result.last_event_id;\r\n            this.descriptor.date_expires = result.date_expires;\r\n            this.descriptor.date_updated = new Date(result.date_updated);\r\n            this.services.storage.update(this.type, this.sid, this.uniqueName, {\r\n                last_event_id: result.last_event_id,\r\n                revision: result.revision,\r\n                date_updated: result.date_updated,\r\n                data: result.data\r\n            });\r\n            this.broadcastEventToListeners('updated', { value: this.value, isLocal: true });\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    async _postUpdateToServer(request) {\r\n        if (!this.isDeleted) {\r\n            const requestBody = {\r\n                data: request.data\r\n            };\r\n            if (request.ttl !== undefined) {\r\n                requestBody.ttl = request.ttl;\r\n            }\r\n            const ifMatch = request.revision;\r\n            try {\r\n                const response = await this.services.network.post(this.uri, requestBody, ifMatch);\r\n                return {\r\n                    revision: response.body.revision,\r\n                    data: request.data,\r\n                    last_event_id: response.body.last_event_id,\r\n                    date_updated: response.body.date_updated,\r\n                    date_expires: response.body.date_expires\r\n                };\r\n            }\r\n            catch (error) {\r\n                if (error.status === 404) {\r\n                    this.onRemoved(false);\r\n                }\r\n                throw error;\r\n            }\r\n        }\r\n        else {\r\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\r\n        }\r\n    }\r\n    /**\r\n     * Get new data from server\r\n     * @private\r\n     */\r\n    async _softSync() {\r\n        return this.services.network.get(this.uri)\r\n            .then(response => {\r\n            const event = {\r\n                type: 'document_updated',\r\n                id: response.body.last_event_id,\r\n                document_revision: response.body.revision,\r\n                document_data: response.body.data,\r\n                date_created: response.body.date_updated\r\n            };\r\n            this._update(event);\r\n            return this;\r\n        })\r\n            .catch(err => {\r\n            if (err.status === 404) {\r\n                this.onRemoved(false);\r\n            }\r\n            else {\r\n                logger_1.default.error(`Can't get updates for ${this.sid}:`, err);\r\n            }\r\n        });\r\n    }\r\n    onRemoved(locally) {\r\n        if (this.isDeleted) {\r\n            return;\r\n        }\r\n        else {\r\n            this.isDeleted = true;\r\n            this._unsubscribe();\r\n            this.removalHandler(this.type, this.sid, this.uniqueName);\r\n            this.broadcastEventToListeners('removed', { isLocal: locally });\r\n        }\r\n    }\r\n    async removeDocument() {\r\n        if (!this.isDeleted) {\r\n            await this.services.network.delete(this.uri);\r\n            this.onRemoved(true);\r\n        }\r\n        else {\r\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\r\n        }\r\n    }\r\n}\r\nexports.SyncDocumentImpl = SyncDocumentImpl;\r\n/**\r\n * @class\r\n * @alias Document\r\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\r\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\r\n * @property {String} sid The immutable identifier of this document, assigned by the system.\r\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\r\n * to this document during creation. Globally unique among other Documents.\r\n * @property {Date} dateUpdated Date when the Document was last updated.\r\n * @property {Object} value The contents of this document.\r\n *\r\n * @fires Document#removed\r\n * @fires Document#updated\r\n */\r\nclass SyncDocument extends closeable_1.default {\r\n    constructor(syncDocumentImpl) {\r\n        super();\r\n        this.syncDocumentImpl = syncDocumentImpl;\r\n        this.syncDocumentImpl.attach(this);\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.syncDocumentImpl.uri;\r\n    }\r\n    get revision() {\r\n        return this.syncDocumentImpl.revision;\r\n    }\r\n    get lastEventId() {\r\n        return this.syncDocumentImpl.lastEventId;\r\n    }\r\n    get dateExpires() {\r\n        return this.syncDocumentImpl.dateExpires;\r\n    }\r\n    static get type() {\r\n        return SyncDocumentImpl.type;\r\n    }\r\n    get type() {\r\n        return SyncDocumentImpl.type;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.syncDocumentImpl.sid;\r\n    }\r\n    get value() {\r\n        return this.syncDocumentImpl.value;\r\n    }\r\n    get dateUpdated() {\r\n        return this.syncDocumentImpl.dateUpdated;\r\n    }\r\n    get uniqueName() {\r\n        return this.syncDocumentImpl.uniqueName;\r\n    }\r\n    /**\r\n     * Assign new contents to this document. The current value will be overwritten.\r\n     * @param {Object} value The new contents to assign.\r\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\r\n     * @returns {Promise<Object>} A promise resolving to the new value of the document.\r\n     * @public\r\n     * @example\r\n     * // Say, the Document value is { name: 'John Smith', age: 34 }\r\n     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\r\n     *   .then(function(newValue) {\r\n     *     // Now the Document value is { name: 'Barbara Oaks' }\r\n     *     console.log('Document set() successful, new value:', newValue);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Document set() failed', error);\r\n     *   });\r\n     */\r\n    async set(value, metadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncDocumentImpl.set(value, metadataUpdates);\r\n    }\r\n    /**\r\n     * Schedules a modification to this document that will apply a mutation function.\r\n     * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\r\n     * May be called multiple times, particularly if this Document is modified concurrently by remote code.\r\n     * If the mutation ultimately succeeds, the Document will have made the particular transition described\r\n     * by this function.\r\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\r\n     * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\r\n     *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\r\n     * @public\r\n     * @example\r\n     * var mutatorFunction = function(currentValue) {\r\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\r\n     *     return currentValue;\r\n     * };\r\n     * document.mutate(mutatorFunction, { ttl: 86400 }))\r\n     *   .then(function(newValue) {\r\n     *     console.log('Document mutate() successful, new value:', newValue);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Document mutate() failed', error);\r\n     *   });\r\n     */\r\n    async mutate(mutator, metadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\r\n    }\r\n    /**\r\n     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\r\n     * This is equivalent to\r\n     * <pre>\r\n     * document.mutate(function(currentValue) {\r\n     *   return Object.assign(currentValue, obj));\r\n     * });\r\n     * </pre>\r\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\r\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\r\n     * @return {Promise<Object>} A promise resolving to the new value of the document.\r\n     * @public\r\n     * @example\r\n     * // Say, the Document value is { name: 'John Smith' }\r\n     * document.update({ age: 34 }, { ttl: 86400 })\r\n     *   .then(function(newValue) {\r\n     *     // Now the Document value is { name: 'John Smith', age: 34 }\r\n     *     console.log('Document update() successful, new value:', newValue);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Document update() failed', error);\r\n     *   });\r\n     */\r\n    async update(obj, metadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncDocumentImpl.update(obj, metadataUpdates);\r\n    }\r\n    /**\r\n     * Update the time-to-live of the document.\r\n     * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\r\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n     * @public\r\n     * @example\r\n     * document.setTtl(3600)\r\n     *   .then(function() {\r\n     *     console.log('Document setTtl() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Document setTtl() failed', error);\r\n     *   });\r\n     */\r\n    async setTtl(ttl) {\r\n        this.ensureNotClosed();\r\n        return this.syncDocumentImpl.setTtl(ttl);\r\n    }\r\n    /**\r\n     * Delete a document.\r\n     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\r\n     * @public\r\n     * @example\r\n     * document.removeDocument()\r\n     *   .then(function() {\r\n     *     console.log('Document removeDocument() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Document removeDocument() failed', error);\r\n     *   });\r\n     */\r\n    async removeDocument() {\r\n        this.ensureNotClosed();\r\n        return this.syncDocumentImpl.removeDocument();\r\n    }\r\n    /**\r\n     * Conclude work with the document instance and remove all event listeners attached to it.\r\n     * Any subsequent operation on this object will be rejected with error.\r\n     * Other local copies of this document will continue operating and receiving events normally.\r\n     * @public\r\n     * @example\r\n     * document.close();\r\n     */\r\n    close() {\r\n        super.close();\r\n        this.syncDocumentImpl.detach(this.listenerUuid);\r\n    }\r\n}\r\nexports.SyncDocument = SyncDocument;\r\nexports.default = SyncDocument;\r\n/**\r\n * Contains Document metadata.\r\n * @typedef {Object} Document#Metadata\r\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\r\n * The value 0 means infinity.\r\n */\r\n/**\r\n * Applies a transformation to the document value.\r\n * @callback Document~Mutator\r\n * @param {Object} currentValue The current value of the document in the cloud.\r\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\r\n */\r\n/**\r\n * Fired when the document is removed, whether the remover was local or remote.\r\n * @event Document#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\r\n * @example\r\n * document.on('removed', function(args) {\r\n *   console.log('Document ' + document.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when the document's contents have changed, whether the updater was local or remote.\r\n * @event Document#updated\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Object} args.value A snapshot of the document's new contents.\r\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\r\n * @example\r\n * document.on('updated', function(args) {\r\n *   console.log('Document ' + document.sid + ' was updated');\r\n *   console.log('args.value: ', args.value);\r\n *   console.log('args.isLocal: ', args.isLocal);\r\n * });\r\n */\r\n"]},"metadata":{},"sourceType":"script"}