{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncClient = exports.Client = void 0;\n\nconst events_1 = require(\"events\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst twilio_notifications_1 = require(\"twilio-notifications\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst subscriptions_1 = require(\"./subscriptions\");\n\nconst router_1 = require(\"./router\");\n\nconst network_1 = require(\"./services/network\");\n\nconst syncdocument_1 = require(\"./syncdocument\");\n\nconst synclist_1 = require(\"./synclist\");\n\nconst syncmap_1 = require(\"./syncmap\");\n\nconst clientInfo_1 = require(\"./clientInfo\");\n\nconst entitiesCache_1 = require(\"./entitiesCache\");\n\nconst storage_1 = require(\"./services/storage\");\n\nconst syncstream_1 = require(\"./streams/syncstream\");\n\nconst livequery_1 = require(\"./livequery\");\n\nconst livequery_2 = require(\"./livequery\");\n\nconst SYNC_PRODUCT_ID = 'data_sync';\n\nconst SDK_VERSION = require('../package.json').version;\n\nfunction decompose(arg) {\n  if (!arg) {\n    return {\n      mode: 'create_new'\n    };\n  } else if (typeof arg === 'string') {\n    return {\n      id: arg,\n      mode: 'open_or_create'\n    };\n  } else {\n    sanitize_1.validateOptionalTtl(arg.ttl);\n    sanitize_1.validateId(arg.id);\n    let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n    return Object.assign(Object.assign({}, arg), {\n      mode: mode\n    });\n  }\n}\n/**\r\n * @class Client\r\n * @classdesc\r\n * Client for the Twilio Sync service.\r\n * @constructor\r\n * @param {String} token - Twilio access token.\r\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\r\n * @example\r\n * // Using NPM\r\n * var SyncClient = require('twilio-sync');\r\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\r\n *\r\n * // Using CDN\r\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\r\n *\r\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\r\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\r\n */\n\n\nclass Client extends events_1.EventEmitter {\n  constructor(fpaToken, options = {}) {\n    super();\n\n    if (!fpaToken) {\n      throw new Error('Sync library needs a valid Twilio token to be passed');\n    }\n\n    if (options.hasOwnProperty('logLevel')) {\n      logger_1.default.setLevel(options.logLevel);\n    } else {\n      logger_1.default.setLevel('silent');\n    }\n\n    const productId = options.productId = options.productId || SYNC_PRODUCT_ID; // Filling ClientMetadata\n\n    options.clientMetadata = options.clientMetadata || {};\n\n    if (!options.clientMetadata.hasOwnProperty('type')) {\n      options.clientMetadata.type = 'sync';\n    }\n\n    if (!options.clientMetadata.hasOwnProperty('sdk')) {\n      options.clientMetadata.sdk = 'JS';\n      options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    let twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\n    twilsock.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n    twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\n    twilsock.on('connectionError', err => this.emit('connectionError', err));\n    let notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\n    let config = new configuration_1.Configuration(options);\n    let network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\n    let storage = new storage_1.SessionStorage(config);\n    this.localStorageId = null;\n    twilsock.connect();\n    this.services = {\n      config,\n      twilsock,\n      notifications,\n      network,\n      storage,\n      router: null,\n      subscriptions: null\n    };\n    let subscriptions = new subscriptions_1.Subscriptions(this.services);\n    let router = new router_1.Router({\n      config,\n      subscriptions,\n      notifications\n    });\n    this.services.router = router;\n    this.services.subscriptions = subscriptions;\n    this.entities = new entitiesCache_1.EntitiesCache();\n    notifications.on('connectionStateChanged', () => {\n      this.emit('connectionStateChanged', this.services.notifications.connectionState);\n    });\n  }\n  /**\r\n   * Current version of Sync client.\r\n   * @name Client#version\r\n   * @type String\r\n   * @readonly\r\n   */\n\n\n  static get version() {\n    return SDK_VERSION;\n  }\n\n  get connectionState() {\n    return this.services.notifications.connectionState;\n  }\n  /**\r\n   * Returns promise which resolves when library is correctly initialized\r\n   * Or throws if initialization is impossible\r\n   * @private\r\n   */\n\n\n  async ensureReady() {\n    if (!this.services.config.sessionStorageEnabled) {\n      return;\n    }\n\n    try {\n      let storageSettings = await this.services.twilsock.storageId();\n      this.services.storage.updateStorageId(storageSettings.id);\n    } catch (e) {\n      logger_1.default.warn('Failed to initialize storage', e);\n    }\n  }\n\n  storeRootInSessionCache(type, id, value) {\n    // can't store without id\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return;\n    }\n\n    let valueToStore = sanitize_1.deepClone(value);\n\n    if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\n      valueToStore['last_event_id'] = null;\n      delete valueToStore['items'];\n    }\n\n    this.services.storage.store(type, id, valueToStore);\n  }\n\n  readRootFromSessionCache(type, id) {\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return null;\n    }\n\n    return this.services.storage.read(type, id);\n  }\n\n  async _get(baseUri, id, optimistic = false) {\n    if (!id) {\n      throw new syncerror_1.SyncError(`Cannot get entity without id`, 404);\n    }\n\n    const uri = new uri_1.UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();\n    let response = await this.services.network.get(uri);\n    return response.body;\n  }\n\n  _createDocument(id, data, ttl) {\n    const requestBody = {\n      unique_name: id,\n      data: data || {}\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.documentsUri, requestBody).then(response => {\n      response.body.data = requestBody.data;\n      return response.body;\n    });\n  }\n\n  async _getDocument(id) {\n    return this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id);\n  }\n\n  _createList(id, purpose, context, ttl) {\n    const requestBody = {\n      unique_name: id,\n      purpose: purpose,\n      context: context\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\n  }\n\n  async _getList(id) {\n    return this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id);\n  }\n\n  _createMap(id, ttl) {\n    const requestBody = {\n      unique_name: id\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\n  }\n\n  async _getMap(id, optimistic = false) {\n    return this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic);\n  }\n\n  async _getStream(id) {\n    return this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false);\n  }\n\n  async _createStream(id, ttl) {\n    const requestBody = {\n      unique_name: id\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    const response = await this.services.network.post(this.services.config.streamsUri, requestBody);\n    return response.body;\n  }\n\n  _getLiveQuery(sid) {\n    return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\n  }\n\n  getCached(id, type) {\n    if (id) {\n      return this.entities.get(id, type) || null;\n    }\n\n    return null;\n  }\n\n  removeFromCacheAndSession(type, sid, uniqueName) {\n    this.entities.remove(sid);\n\n    if (this.services.config.sessionStorageEnabled) {\n      this.services.storage.remove(type, sid, uniqueName);\n    }\n  }\n  /**\r\n   * Read or create a Sync Document.\r\n   * @param {String | Client#OpenOptions} [arg] One of:\r\n   * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\r\n   * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\r\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n   * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\r\n   * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\r\n   * @public\r\n   * @example\r\n   * syncClient.document('MyDocument')\r\n   *   .then(function(document) {\r\n   *     console.log('Successfully opened a Document. SID: ' + document.sid);\r\n   *     document.on('updated', function(event) {\r\n   *       console.log('Received updated event: ', event);\r\n   *     });\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.log('Unexpected error', error);\r\n   *   });\r\n   */\n\n\n  async document(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let docDescriptor;\n\n    if (opts.mode === 'create_new') {\n      docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n    } else {\n      let docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);\n\n      if (docFromInMemoryCache) {\n        return new syncdocument_1.SyncDocument(docFromInMemoryCache);\n      } else {\n        try {\n          docDescriptor = await this._getDocument(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.document(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\n    let syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncDocumentImpl = this.entities.store(syncDocumentImpl);\n    return new syncdocument_1.SyncDocument(syncDocumentImpl);\n  }\n  /**\r\n   * Read or create a Sync Map.\r\n   * @param {String | Client#OpenOptions} [arg] One of:\r\n   * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\r\n   * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\r\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n   * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\r\n   * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\r\n   * @public\r\n   * @example\r\n   * syncClient.map('MyMap')\r\n   *   .then(function(map) {\r\n   *     console.log('Successfully opened a Map. SID: ' + map.sid);\r\n   *     map.on('itemUpdated', function(event) {\r\n   *       console.log('Received itemUpdated event: ', event);\r\n   *     });\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.log('Unexpected error', error);\r\n   *   });\r\n   */\n\n\n  async map(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let mapDescriptor;\n\n    if (opts.mode === 'create_new') {\n      mapDescriptor = await this._createMap(opts.id, opts.ttl);\n    } else {\n      let mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);\n\n      if (mapFromInMemoryCache) {\n        return new syncmap_1.SyncMap(mapFromInMemoryCache);\n      } else {\n        try {\n          mapDescriptor = await this._getMap(opts.id, opts.includeItems);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              mapDescriptor = await this._createMap(opts.id, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.map(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\n    let syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncMapImpl = this.entities.store(syncMapImpl);\n    return new syncmap_1.SyncMap(syncMapImpl);\n  }\n  /**\r\n   * Read or create a Sync List.\r\n   * @param {String | Client#OpenOptions} [arg] One of:\r\n   * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\r\n   * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\r\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n   * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\r\n   * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\r\n   * @public\r\n   * @example\r\n   * syncClient.list('MyList')\r\n   *   .then(function(list) {\r\n   *     console.log('Successfully opened a List. SID: ' + list.sid);\r\n   *     list.on('itemAdded', function(event) {\r\n   *       console.log('Received itemAdded event: ', event);\r\n   *     });\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.log('Unexpected error', error);\r\n   *   });\r\n   */\n\n\n  async list(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let listDescriptor;\n\n    if (opts.mode === 'create_new') {\n      listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n    } else {\n      let listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);\n\n      if (listFromInMemoryCache) {\n        return new synclist_1.SyncList(listFromInMemoryCache);\n      } else {\n        try {\n          listDescriptor = await this._getList(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.list(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\n    let syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncListImpl = this.entities.store(syncListImpl);\n    return new synclist_1.SyncList(syncListImpl);\n  }\n  /**\r\n   * Read or create a Sync Message Stream.\r\n   * @param {String | Client#OpenOptions} [arg] One of:\r\n   * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\r\n   * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\r\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n   * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\r\n   * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\r\n   * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\r\n   * @public\r\n   * @example\r\n   * syncClient.stream('MyStream')\r\n   *   .then(function(stream) {\r\n   *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\r\n   *     stream.on('messagePublished', function(event) {\r\n   *       console.log('Received messagePublished event: ', event);\r\n   *     });\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.log('Unexpected error', error);\r\n   *   });\r\n   */\n\n\n  async stream(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let streamDescriptor;\n\n    if (opts.mode === 'create_new') {\n      streamDescriptor = await this._createStream(opts.id, opts.ttl);\n    } else {\n      let streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);\n\n      if (streamFromInMemoryCache) {\n        return new syncstream_1.SyncStream(streamFromInMemoryCache);\n      } else {\n        try {\n          streamDescriptor = await this._getStream(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              streamDescriptor = await this._createStream(opts.id, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.stream(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\n\n    const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n\n    let syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\n    syncStreamImpl = this.entities.store(syncStreamImpl);\n    return new syncstream_1.SyncStream(syncStreamImpl);\n  }\n  /**\r\n   * Gracefully shuts the Sync client down.\r\n   */\n\n\n  async shutdown() {\n    await this.services.subscriptions.shutdown();\n    await this.services.twilsock.disconnect();\n  }\n  /**\r\n   * Set new authentication token.\r\n   * @param {String} token New token to set.\r\n   * @return {Promise<void>}\r\n   * @public\r\n   */\n\n\n  async updateToken(token) {\n    if (!token) {\n      return Promise.reject(new Error('A valid Twilio token should be provided'));\n    }\n\n    return this.services.twilsock.updateToken(token);\n  }\n  /**\r\n   * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\r\n   * result set is updated whenever new (or updated) records match the given expression. Updated results\r\n   * are presented row-by-row according to the lifetime of the returned LiveQuery object.\r\n   *\r\n   * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\r\n   * @param queryExpression {String} A query expression to be executed against the given data index.\r\n   * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\r\n   * page for Sync Client limits and full list of operators currently supported in query expressions.\r\n   *\r\n   * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\r\n   * @public\r\n   * @example\r\n   * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\r\n   *     .then(function(args) {\r\n   *        console.log('Subscribed to live data updates for worker Bob');\r\n   *        let items = args.getItems();\r\n   *        Object.entries(items).forEach(([key, value]) => {\r\n   *          console.log('Search result item key: ' + key);\r\n   *          console.log('Search result item value: ' + value);\r\n   *        });\r\n   *     })\r\n   *     .catch(function(err) {\r\n   *        console.log('Error when subscribing to live updates for worker Bob', err);\r\n   *     });\r\n   */\n\n\n  async liveQuery(indexName, queryExpression) {\n    await this.ensureReady();\n\n    if (!indexName || typeof indexName !== 'string') {\n      throw new Error('Index name must contain a non-empty string value');\n    }\n\n    let queryUri = new uri_1.UriBuilder(this.services.config.insightsUri).pathSegment(indexName).pathSegment('Items').build(); // send query to CDS to get server-generated sid and item list\n\n    let response = await livequery_2.queryItems({\n      network: this.services.network,\n      uri: queryUri,\n      queryString: queryExpression,\n      type: livequery_1.LiveQuery.type\n    });\n    let liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);\n\n    if (!liveQueryImpl) {\n      let descriptor = this._getLiveQuery(response.query_id);\n\n      if (!descriptor) {\n        descriptor = {\n          indexName,\n          queryExpression,\n          sid: response.query_id,\n          queryUri,\n          last_event_id: response.last_event_id\n        };\n      }\n\n      const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n\n      liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\n    }\n\n    this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n    liveQueryImpl = this.entities.store(liveQueryImpl);\n    return new livequery_1.LiveQuery(liveQueryImpl);\n  }\n  /**\r\n   * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\r\n   * against the target index.\r\n   *\r\n   * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\r\n   * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\r\n   * @public\r\n   * @example\r\n   * syncClient.instantQuery('tr-worker')\r\n   *    .then(function(q) {\r\n   *        q.on('searchResult', function(items) {\r\n   *          Object.entries(items).forEach(([key, value]) => {\r\n   *             console.log('Search result item key: ' + key);\r\n   *             console.log('Search result item value: ' + value);\r\n   *          });\r\n   *       });\r\n   *    });\r\n   */\n\n\n  async instantQuery(indexName) {\n    await this.ensureReady();\n\n    let liveQueryCreator = (indexName, queryExpression) => {\n      return this.liveQuery(indexName, queryExpression);\n    };\n\n    const search = new livequery_1.InstantQuery({\n      indexName,\n      network: this.services.network,\n      insightsUri: this.services.config.insightsUri,\n      liveQueryCreator\n    });\n    return search;\n  }\n\n}\n\nexports.Client = Client;\nexports.SyncClient = Client;\nexports.default = Client;\n/**\r\n * Indicates current state of connection between the client and Sync service.\r\n * <p>Valid options are as follows:\r\n * <li>'connecting' - client is offline and connection attempt is in process.\r\n * <li>'connected' - client is online and ready.\r\n * <li>'disconnecting' - client is going offline as disconnection is in process.\r\n * <li>'disconnected' - client is offline and no connection attempt is in process.\r\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\r\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\r\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\r\n */\n\n/**\r\n * These options can be passed to Client constructor.\r\n * @typedef {Object} Client#ClientOptions\r\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\r\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\r\n */\n\n/**\r\n * Fired when connection state has been changed.\r\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\r\n * @event Client#connectionStateChanged\r\n * @example\r\n * syncClient.on('connectionStateChanged', function(newState) {\r\n *   console.log('Received new connection state: ' + newState);\r\n * });\r\n */\n\n/**\r\n * Fired when connection is interrupted by unexpected reason\r\n * @property {Object} error - connection error details\r\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\r\n * @property {String} error.message - root cause\r\n * @property {Number} [error.httpStatusCode] - http status code if available\r\n * @property {Number} [error.errorCode] - Twilio public error code if available\r\n * @event Client#connectionError\r\n * @example\r\n * syncClient.on('connectionError', function(connectionError) {\r\n *   console.log('Connection was interrupted: ' + connectionError.message +\r\n *     ' (isTerminal: ' + connectionError.terminal')');\r\n * });\r\n */\n\n/**\r\n * Options for opening a Sync Object.\r\n * @typedef {Object} Client#OpenOptions\r\n * @property {String} [id] Sync object SID or unique name.\r\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\r\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\r\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\r\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\r\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\r\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\r\n * @example <caption>The following example is applicable to all Sync objects\r\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\r\n * // Attempts to open an existing Document with unique name 'MyDocument'\r\n * // If no such Document exists, the promise is rejected\r\n * syncClient.document({\r\n *     id: 'MyDocument',\r\n *     mode: 'open_existing'\r\n *   })\r\n *   .then(...)\r\n *   .catch(...);\r\n *\r\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\r\n * // If such a Document already exists, the promise is rejected\r\n * syncClient.document({\r\n *     id: 'MyDocument',\r\n *     mode: 'create_new',\r\n *     ttl: 86400\r\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\r\n *   })\r\n *   .then(...)\r\n *   .catch(...);\r\n */\n\n/**\r\n * Fired when the access token is about to expire and needs to be updated.\r\n * The trigger takes place three minutes before the JWT access token expiry.\r\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\r\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\r\n * @event Client#tokenAboutToExpire\r\n * @type {void}\r\n * @example <caption>The following example illustrates access token refresh</caption>\r\n * syncClient.on('tokenAboutToExpire', function() {\r\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\r\n *   var token = '<your-access-token-here>';\r\n *   syncClient.updateToken(token);\r\n * });\r\n */\n\n/**\r\n * Fired when the access token is expired.\r\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\r\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\r\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\r\n * @event Client#tokenExpired\r\n * @type {void}\r\n */","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilio-sync/lib/client.js"],"names":["Object","defineProperty","exports","value","SyncClient","Client","events_1","require","twilsock_1","twilio_notifications_1","uri_1","syncerror_1","sanitize_1","logger_1","configuration_1","subscriptions_1","router_1","network_1","syncdocument_1","synclist_1","syncmap_1","clientInfo_1","entitiesCache_1","storage_1","syncstream_1","livequery_1","livequery_2","SYNC_PRODUCT_ID","SDK_VERSION","version","decompose","arg","mode","id","validateOptionalTtl","ttl","validateId","assign","EventEmitter","constructor","fpaToken","options","Error","hasOwnProperty","default","setLevel","logLevel","productId","clientMetadata","type","sdk","sdkv","twilsock","twilsockClient","Twilsock","on","emit","err","notifications","notificationsClient","Notifications","config","Configuration","network","NetworkService","ClientInfo","storage","SessionStorage","localStorageId","connect","services","router","subscriptions","Subscriptions","Router","entities","EntitiesCache","connectionState","ensureReady","sessionStorageEnabled","storageSettings","storageId","updateStorageId","e","warn","storeRootInSessionCache","valueToStore","deepClone","SyncList","SyncMap","store","readRootFromSessionCache","read","_get","baseUri","optimistic","SyncError","uri","UriBuilder","pathSegment","queryParam","undefined","build","response","get","body","_createDocument","data","requestBody","unique_name","post","documentsUri","then","_getDocument","SyncDocument","_createList","purpose","context","listsUri","_getList","_createMap","mapsUri","_getMap","_getStream","SyncStream","streamsUri","_createStream","_getLiveQuery","sid","LiveQuery","getCached","removeFromCacheAndSession","uniqueName","remove","document","opts","docDescriptor","docFromInMemoryCache","status","syncDocumentImpl","SyncDocumentImpl","map","mapDescriptor","mapFromInMemoryCache","includeItems","syncMapImpl","SyncMapImpl","list","listDescriptor","listFromInMemoryCache","syncListImpl","SyncListImpl","stream","streamDescriptor","streamFromInMemoryCache","streamRemovalHandler","syncStreamImpl","SyncStreamImpl","shutdown","disconnect","updateToken","token","Promise","reject","liveQuery","indexName","queryExpression","queryUri","insightsUri","queryItems","queryString","liveQueryImpl","query_id","descriptor","last_event_id","liveQueryRemovalHandler","LiveQueryImpl","items","liveQueryDescriptor","instantQuery","liveQueryCreator","search","InstantQuery"],"mappings":"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A9B,EAA0C,KAAKvG,QAA/C,EAAyDyG,uBAAzD,EAAkFxE,QAAQ,CAAC0E,KAA3F,CAAhB;AACH;;AACD,SAAK5F,uBAAL,CAA6B5D,WAAW,CAACwG,SAAZ,CAAsBhF,IAAnD,EAAyDsD,QAAQ,CAACqE,QAAlE,EAA4ED,aAAa,CAACO,mBAA1F;AACAP,IAAAA,aAAa,GAAG,KAAKhG,QAAL,CAAce,KAAd,CAAoBiF,aAApB,CAAhB;AACA,WAAO,IAAIlJ,WAAW,CAACwG,SAAhB,CAA0B0C,aAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACsB,QAAZQ,YAAY,CAACd,SAAD,EAAY;AAC1B,UAAM,KAAKvF,WAAL,EAAN;;AACA,QAAIsG,gBAAgB,GAAG,CAACf,SAAD,EAAYC,eAAZ,KAAgC;AACnD,aAAO,KAAKF,SAAL,CAAeC,SAAf,EAA0BC,eAA1B,CAAP;AACH,KAFD;;AAGA,UAAMe,MAAM,GAAG,IAAI5J,WAAW,CAAC6J,YAAhB,CAA6B;AACxCjB,MAAAA,SADwC;AAExCtG,MAAAA,OAAO,EAAE,KAAKO,QAAL,CAAcP,OAFiB;AAGxCyG,MAAAA,WAAW,EAAE,KAAKlG,QAAL,CAAcT,MAAd,CAAqB2G,WAHM;AAIxCY,MAAAA;AAJwC,KAA7B,CAAf;AAMA,WAAOC,MAAP;AACH;;AAzhBsC;;AA2hB3CnL,OAAO,CAACG,MAAR,GAAiBA,MAAjB;AACAH,OAAO,CAACE,UAAR,GAAqBC,MAArB;AACAH,OAAO,CAAC0C,OAAR,GAAkBvC,MAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SyncClient = exports.Client = void 0;\r\nconst events_1 = require(\"events\");\r\nconst twilsock_1 = require(\"twilsock\");\r\nconst twilio_notifications_1 = require(\"twilio-notifications\");\r\nconst uri_1 = require(\"./utils/uri\");\r\nconst syncerror_1 = require(\"./utils/syncerror\");\r\nconst sanitize_1 = require(\"./utils/sanitize\");\r\nconst logger_1 = require(\"./utils/logger\");\r\nconst configuration_1 = require(\"./configuration\");\r\nconst subscriptions_1 = require(\"./subscriptions\");\r\nconst router_1 = require(\"./router\");\r\nconst network_1 = require(\"./services/network\");\r\nconst syncdocument_1 = require(\"./syncdocument\");\r\nconst synclist_1 = require(\"./synclist\");\r\nconst syncmap_1 = require(\"./syncmap\");\r\nconst clientInfo_1 = require(\"./clientInfo\");\r\nconst entitiesCache_1 = require(\"./entitiesCache\");\r\nconst storage_1 = require(\"./services/storage\");\r\nconst syncstream_1 = require(\"./streams/syncstream\");\r\nconst livequery_1 = require(\"./livequery\");\r\nconst livequery_2 = require(\"./livequery\");\r\nconst SYNC_PRODUCT_ID = 'data_sync';\r\nconst SDK_VERSION = require('../package.json').version;\r\nfunction decompose(arg) {\r\n    if (!arg) {\r\n        return { mode: 'create_new' };\r\n    }\r\n    else if (typeof arg === 'string') {\r\n        return { id: arg, mode: 'open_or_create' };\r\n    }\r\n    else {\r\n        sanitize_1.validateOptionalTtl(arg.ttl);\r\n        sanitize_1.validateId(arg.id);\r\n        let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\r\n        return Object.assign(Object.assign({}, arg), { mode: mode });\r\n    }\r\n}\r\n/**\r\n * @class Client\r\n * @classdesc\r\n * Client for the Twilio Sync service.\r\n * @constructor\r\n * @param {String} token - Twilio access token.\r\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\r\n * @example\r\n * // Using NPM\r\n * var SyncClient = require('twilio-sync');\r\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\r\n *\r\n * // Using CDN\r\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\r\n *\r\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\r\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\r\n */\r\nclass Client extends events_1.EventEmitter {\r\n    constructor(fpaToken, options = {}) {\r\n        super();\r\n        if (!fpaToken) {\r\n            throw new Error('Sync library needs a valid Twilio token to be passed');\r\n        }\r\n        if (options.hasOwnProperty('logLevel')) {\r\n            logger_1.default.setLevel(options.logLevel);\r\n        }\r\n        else {\r\n            logger_1.default.setLevel('silent');\r\n        }\r\n        const productId = options.productId = options.productId || SYNC_PRODUCT_ID;\r\n        // Filling ClientMetadata\r\n        options.clientMetadata = options.clientMetadata || {};\r\n        if (!options.clientMetadata.hasOwnProperty('type')) {\r\n            options.clientMetadata.type = 'sync';\r\n        }\r\n        if (!options.clientMetadata.hasOwnProperty('sdk')) {\r\n            options.clientMetadata.sdk = 'JS';\r\n            options.clientMetadata.sdkv = SDK_VERSION;\r\n        }\r\n        let twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\r\n        twilsock.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\r\n        twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\r\n        twilsock.on('connectionError', err => this.emit('connectionError', err));\r\n        let notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\r\n        let config = new configuration_1.Configuration(options);\r\n        let network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\r\n        let storage = new storage_1.SessionStorage(config);\r\n        this.localStorageId = null;\r\n        twilsock.connect();\r\n        this.services = {\r\n            config,\r\n            twilsock,\r\n            notifications,\r\n            network,\r\n            storage,\r\n            router: null,\r\n            subscriptions: null\r\n        };\r\n        let subscriptions = new subscriptions_1.Subscriptions(this.services);\r\n        let router = new router_1.Router({ config, subscriptions, notifications });\r\n        this.services.router = router;\r\n        this.services.subscriptions = subscriptions;\r\n        this.entities = new entitiesCache_1.EntitiesCache();\r\n        notifications.on('connectionStateChanged', () => {\r\n            this.emit('connectionStateChanged', this.services.notifications.connectionState);\r\n        });\r\n    }\r\n    /**\r\n     * Current version of Sync client.\r\n     * @name Client#version\r\n     * @type String\r\n     * @readonly\r\n     */\r\n    static get version() {\r\n        return SDK_VERSION;\r\n    }\r\n    get connectionState() {\r\n        return this.services.notifications.connectionState;\r\n    }\r\n    /**\r\n     * Returns promise which resolves when library is correctly initialized\r\n     * Or throws if initialization is impossible\r\n     * @private\r\n     */\r\n    async ensureReady() {\r\n        if (!this.services.config.sessionStorageEnabled) {\r\n            return;\r\n        }\r\n        try {\r\n            let storageSettings = await this.services.twilsock.storageId();\r\n            this.services.storage.updateStorageId(storageSettings.id);\r\n        }\r\n        catch (e) {\r\n            logger_1.default.warn('Failed to initialize storage', e);\r\n        }\r\n    }\r\n    storeRootInSessionCache(type, id, value) {\r\n        // can't store without id\r\n        if (!this.services.config.sessionStorageEnabled || !id) {\r\n            return;\r\n        }\r\n        let valueToStore = sanitize_1.deepClone(value);\r\n        if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\r\n            valueToStore['last_event_id'] = null;\r\n            delete valueToStore['items'];\r\n        }\r\n        this.services.storage.store(type, id, valueToStore);\r\n    }\r\n    readRootFromSessionCache(type, id) {\r\n        if (!this.services.config.sessionStorageEnabled || !id) {\r\n            return null;\r\n        }\r\n        return this.services.storage.read(type, id);\r\n    }\r\n    async _get(baseUri, id, optimistic = false) {\r\n        if (!id) {\r\n            throw new syncerror_1.SyncError(`Cannot get entity without id`, 404);\r\n        }\r\n        const uri = new uri_1.UriBuilder(baseUri).pathSegment(id)\r\n            .queryParam('Include', optimistic ? 'items' : undefined).build();\r\n        let response = await this.services.network.get(uri);\r\n        return response.body;\r\n    }\r\n    _createDocument(id, data, ttl) {\r\n        const requestBody = {\r\n            unique_name: id,\r\n            data: data || {}\r\n        };\r\n        if (ttl !== undefined) {\r\n            requestBody.ttl = ttl;\r\n        }\r\n        return this.services.network.post(this.services.config.documentsUri, requestBody)\r\n            .then(response => {\r\n            response.body.data = requestBody.data;\r\n            return response.body;\r\n        });\r\n    }\r\n    async _getDocument(id) {\r\n        return (this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));\r\n    }\r\n    _createList(id, purpose, context, ttl) {\r\n        const requestBody = {\r\n            unique_name: id,\r\n            purpose: purpose,\r\n            context: context\r\n        };\r\n        if (ttl !== undefined) {\r\n            requestBody.ttl = ttl;\r\n        }\r\n        return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\r\n    }\r\n    async _getList(id) {\r\n        return (this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));\r\n    }\r\n    _createMap(id, ttl) {\r\n        const requestBody = {\r\n            unique_name: id\r\n        };\r\n        if (ttl !== undefined) {\r\n            requestBody.ttl = ttl;\r\n        }\r\n        return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\r\n    }\r\n    async _getMap(id, optimistic = false) {\r\n        return (this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));\r\n    }\r\n    async _getStream(id) {\r\n        return (this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));\r\n    }\r\n    async _createStream(id, ttl) {\r\n        const requestBody = {\r\n            unique_name: id\r\n        };\r\n        if (ttl !== undefined) {\r\n            requestBody.ttl = ttl;\r\n        }\r\n        const response = await this.services.network.post(this.services.config.streamsUri, requestBody);\r\n        return response.body;\r\n    }\r\n    _getLiveQuery(sid) {\r\n        return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\r\n    }\r\n    getCached(id, type) {\r\n        if (id) {\r\n            return this.entities.get(id, type) || null;\r\n        }\r\n        return null;\r\n    }\r\n    removeFromCacheAndSession(type, sid, uniqueName) {\r\n        this.entities.remove(sid);\r\n        if (this.services.config.sessionStorageEnabled) {\r\n            this.services.storage.remove(type, sid, uniqueName);\r\n        }\r\n    }\r\n    /**\r\n     * Read or create a Sync Document.\r\n     * @param {String | Client#OpenOptions} [arg] One of:\r\n     * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\r\n     * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\r\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n     * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\r\n     * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\r\n     * @public\r\n     * @example\r\n     * syncClient.document('MyDocument')\r\n     *   .then(function(document) {\r\n     *     console.log('Successfully opened a Document. SID: ' + document.sid);\r\n     *     document.on('updated', function(event) {\r\n     *       console.log('Received updated event: ', event);\r\n     *     });\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log('Unexpected error', error);\r\n     *   });\r\n     */\r\n    async document(arg) {\r\n        await this.ensureReady();\r\n        let opts = decompose(arg);\r\n        let docDescriptor;\r\n        if (opts.mode === 'create_new') {\r\n            docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\r\n        }\r\n        else {\r\n            let docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);\r\n            if (docFromInMemoryCache) {\r\n                return new syncdocument_1.SyncDocument(docFromInMemoryCache);\r\n            }\r\n            else {\r\n                try {\r\n                    docDescriptor = await this._getDocument(opts.id);\r\n                }\r\n                catch (err) {\r\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\r\n                        throw err;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\r\n                        }\r\n                        catch (err) {\r\n                            if (err.status === 409) {\r\n                                return this.document(arg);\r\n                            }\r\n                            else {\r\n                                throw err;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\r\n        let syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\r\n        syncDocumentImpl = this.entities.store(syncDocumentImpl);\r\n        return new syncdocument_1.SyncDocument(syncDocumentImpl);\r\n    }\r\n    /**\r\n     * Read or create a Sync Map.\r\n     * @param {String | Client#OpenOptions} [arg] One of:\r\n     * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\r\n     * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\r\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n     * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\r\n     * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\r\n     * @public\r\n     * @example\r\n     * syncClient.map('MyMap')\r\n     *   .then(function(map) {\r\n     *     console.log('Successfully opened a Map. SID: ' + map.sid);\r\n     *     map.on('itemUpdated', function(event) {\r\n     *       console.log('Received itemUpdated event: ', event);\r\n     *     });\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log('Unexpected error', error);\r\n     *   });\r\n     */\r\n    async map(arg) {\r\n        await this.ensureReady();\r\n        let opts = decompose(arg);\r\n        let mapDescriptor;\r\n        if (opts.mode === 'create_new') {\r\n            mapDescriptor = await this._createMap(opts.id, opts.ttl);\r\n        }\r\n        else {\r\n            let mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);\r\n            if (mapFromInMemoryCache) {\r\n                return new syncmap_1.SyncMap(mapFromInMemoryCache);\r\n            }\r\n            else {\r\n                try {\r\n                    mapDescriptor = await this._getMap(opts.id, opts.includeItems);\r\n                }\r\n                catch (err) {\r\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\r\n                        throw err;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            mapDescriptor = await this._createMap(opts.id, opts.ttl);\r\n                        }\r\n                        catch (err) {\r\n                            if (err.status === 409) {\r\n                                return this.map(arg);\r\n                            }\r\n                            else {\r\n                                throw err;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\r\n        let syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\r\n        syncMapImpl = this.entities.store(syncMapImpl);\r\n        return new syncmap_1.SyncMap(syncMapImpl);\r\n    }\r\n    /**\r\n     * Read or create a Sync List.\r\n     * @param {String | Client#OpenOptions} [arg] One of:\r\n     * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\r\n     * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\r\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n     * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\r\n     * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\r\n     * @public\r\n     * @example\r\n     * syncClient.list('MyList')\r\n     *   .then(function(list) {\r\n     *     console.log('Successfully opened a List. SID: ' + list.sid);\r\n     *     list.on('itemAdded', function(event) {\r\n     *       console.log('Received itemAdded event: ', event);\r\n     *     });\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log('Unexpected error', error);\r\n     *   });\r\n     */\r\n    async list(arg) {\r\n        await this.ensureReady();\r\n        let opts = decompose(arg);\r\n        let listDescriptor;\r\n        if (opts.mode === 'create_new') {\r\n            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\r\n        }\r\n        else {\r\n            let listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);\r\n            if (listFromInMemoryCache) {\r\n                return new synclist_1.SyncList(listFromInMemoryCache);\r\n            }\r\n            else {\r\n                try {\r\n                    listDescriptor = await this._getList(opts.id);\r\n                }\r\n                catch (err) {\r\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\r\n                        throw err;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\r\n                        }\r\n                        catch (err) {\r\n                            if (err.status === 409) {\r\n                                return this.list(arg);\r\n                            }\r\n                            else {\r\n                                throw err;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\r\n        let syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\r\n        syncListImpl = this.entities.store(syncListImpl);\r\n        return new synclist_1.SyncList(syncListImpl);\r\n    }\r\n    /**\r\n     * Read or create a Sync Message Stream.\r\n     * @param {String | Client#OpenOptions} [arg] One of:\r\n     * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\r\n     * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\r\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\r\n     * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\r\n     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\r\n     * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\r\n     * @public\r\n     * @example\r\n     * syncClient.stream('MyStream')\r\n     *   .then(function(stream) {\r\n     *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\r\n     *     stream.on('messagePublished', function(event) {\r\n     *       console.log('Received messagePublished event: ', event);\r\n     *     });\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log('Unexpected error', error);\r\n     *   });\r\n     */\r\n    async stream(arg) {\r\n        await this.ensureReady();\r\n        let opts = decompose(arg);\r\n        let streamDescriptor;\r\n        if (opts.mode === 'create_new') {\r\n            streamDescriptor = await this._createStream(opts.id, opts.ttl);\r\n        }\r\n        else {\r\n            let streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);\r\n            if (streamFromInMemoryCache) {\r\n                return new syncstream_1.SyncStream(streamFromInMemoryCache);\r\n            }\r\n            else {\r\n                try {\r\n                    streamDescriptor = await this._getStream(opts.id);\r\n                }\r\n                catch (err) {\r\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\r\n                        throw err;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            streamDescriptor = await this._createStream(opts.id, opts.ttl);\r\n                        }\r\n                        catch (err) {\r\n                            if (err.status === 409) {\r\n                                return this.stream(arg);\r\n                            }\r\n                            else {\r\n                                throw err;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\r\n        const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\r\n        let syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\r\n        syncStreamImpl = this.entities.store(syncStreamImpl);\r\n        return new syncstream_1.SyncStream(syncStreamImpl);\r\n    }\r\n    /**\r\n     * Gracefully shuts the Sync client down.\r\n     */\r\n    async shutdown() {\r\n        await this.services.subscriptions.shutdown();\r\n        await this.services.twilsock.disconnect();\r\n    }\r\n    /**\r\n     * Set new authentication token.\r\n     * @param {String} token New token to set.\r\n     * @return {Promise<void>}\r\n     * @public\r\n     */\r\n    async updateToken(token) {\r\n        if (!token) {\r\n            return Promise.reject(new Error('A valid Twilio token should be provided'));\r\n        }\r\n        return this.services.twilsock.updateToken(token);\r\n    }\r\n    /**\r\n     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\r\n     * result set is updated whenever new (or updated) records match the given expression. Updated results\r\n     * are presented row-by-row according to the lifetime of the returned LiveQuery object.\r\n     *\r\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\r\n     * @param queryExpression {String} A query expression to be executed against the given data index.\r\n     * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\r\n     * page for Sync Client limits and full list of operators currently supported in query expressions.\r\n     *\r\n     * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\r\n     * @public\r\n     * @example\r\n     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\r\n     *     .then(function(args) {\r\n     *        console.log('Subscribed to live data updates for worker Bob');\r\n     *        let items = args.getItems();\r\n     *        Object.entries(items).forEach(([key, value]) => {\r\n     *          console.log('Search result item key: ' + key);\r\n     *          console.log('Search result item value: ' + value);\r\n     *        });\r\n     *     })\r\n     *     .catch(function(err) {\r\n     *        console.log('Error when subscribing to live updates for worker Bob', err);\r\n     *     });\r\n     */\r\n    async liveQuery(indexName, queryExpression) {\r\n        await this.ensureReady();\r\n        if (!indexName || typeof indexName !== 'string') {\r\n            throw new Error('Index name must contain a non-empty string value');\r\n        }\r\n        let queryUri = new uri_1.UriBuilder(this.services.config.insightsUri)\r\n            .pathSegment(indexName)\r\n            .pathSegment('Items')\r\n            .build();\r\n        // send query to CDS to get server-generated sid and item list\r\n        let response = await livequery_2.queryItems({\r\n            network: this.services.network,\r\n            uri: queryUri,\r\n            queryString: queryExpression,\r\n            type: livequery_1.LiveQuery.type\r\n        });\r\n        let liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);\r\n        if (!liveQueryImpl) {\r\n            let descriptor = this._getLiveQuery(response.query_id);\r\n            if (!descriptor) {\r\n                descriptor = {\r\n                    indexName,\r\n                    queryExpression,\r\n                    sid: response.query_id,\r\n                    queryUri,\r\n                    last_event_id: response.last_event_id\r\n                };\r\n            }\r\n            const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\r\n            liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\r\n        }\r\n        this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\r\n        liveQueryImpl = this.entities.store(liveQueryImpl);\r\n        return new livequery_1.LiveQuery(liveQueryImpl);\r\n    }\r\n    /**\r\n     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\r\n     * against the target index.\r\n     *\r\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\r\n     * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\r\n     * @public\r\n     * @example\r\n     * syncClient.instantQuery('tr-worker')\r\n     *    .then(function(q) {\r\n     *        q.on('searchResult', function(items) {\r\n     *          Object.entries(items).forEach(([key, value]) => {\r\n     *             console.log('Search result item key: ' + key);\r\n     *             console.log('Search result item value: ' + value);\r\n     *          });\r\n     *       });\r\n     *    });\r\n     */\r\n    async instantQuery(indexName) {\r\n        await this.ensureReady();\r\n        let liveQueryCreator = (indexName, queryExpression) => {\r\n            return this.liveQuery(indexName, queryExpression);\r\n        };\r\n        const search = new livequery_1.InstantQuery({\r\n            indexName,\r\n            network: this.services.network,\r\n            insightsUri: this.services.config.insightsUri,\r\n            liveQueryCreator\r\n        });\r\n        return search;\r\n    }\r\n}\r\nexports.Client = Client;\r\nexports.SyncClient = Client;\r\nexports.default = Client;\r\n/**\r\n * Indicates current state of connection between the client and Sync service.\r\n * <p>Valid options are as follows:\r\n * <li>'connecting' - client is offline and connection attempt is in process.\r\n * <li>'connected' - client is online and ready.\r\n * <li>'disconnecting' - client is going offline as disconnection is in process.\r\n * <li>'disconnected' - client is offline and no connection attempt is in process.\r\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\r\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\r\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\r\n */\r\n/**\r\n * These options can be passed to Client constructor.\r\n * @typedef {Object} Client#ClientOptions\r\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\r\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\r\n */\r\n/**\r\n * Fired when connection state has been changed.\r\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\r\n * @event Client#connectionStateChanged\r\n * @example\r\n * syncClient.on('connectionStateChanged', function(newState) {\r\n *   console.log('Received new connection state: ' + newState);\r\n * });\r\n */\r\n/**\r\n * Fired when connection is interrupted by unexpected reason\r\n * @property {Object} error - connection error details\r\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\r\n * @property {String} error.message - root cause\r\n * @property {Number} [error.httpStatusCode] - http status code if available\r\n * @property {Number} [error.errorCode] - Twilio public error code if available\r\n * @event Client#connectionError\r\n * @example\r\n * syncClient.on('connectionError', function(connectionError) {\r\n *   console.log('Connection was interrupted: ' + connectionError.message +\r\n *     ' (isTerminal: ' + connectionError.terminal')');\r\n * });\r\n */\r\n/**\r\n * Options for opening a Sync Object.\r\n * @typedef {Object} Client#OpenOptions\r\n * @property {String} [id] Sync object SID or unique name.\r\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\r\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\r\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\r\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\r\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\r\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\r\n * @example <caption>The following example is applicable to all Sync objects\r\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\r\n * // Attempts to open an existing Document with unique name 'MyDocument'\r\n * // If no such Document exists, the promise is rejected\r\n * syncClient.document({\r\n *     id: 'MyDocument',\r\n *     mode: 'open_existing'\r\n *   })\r\n *   .then(...)\r\n *   .catch(...);\r\n *\r\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\r\n * // If such a Document already exists, the promise is rejected\r\n * syncClient.document({\r\n *     id: 'MyDocument',\r\n *     mode: 'create_new',\r\n *     ttl: 86400\r\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\r\n *   })\r\n *   .then(...)\r\n *   .catch(...);\r\n */\r\n/**\r\n * Fired when the access token is about to expire and needs to be updated.\r\n * The trigger takes place three minutes before the JWT access token expiry.\r\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\r\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\r\n * @event Client#tokenAboutToExpire\r\n * @type {void}\r\n * @example <caption>The following example illustrates access token refresh</caption>\r\n * syncClient.on('tokenAboutToExpire', function() {\r\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\r\n *   var token = '<your-access-token-here>';\r\n *   syncClient.updateToken(token);\r\n * });\r\n */\r\n/**\r\n * Fired when the access token is expired.\r\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\r\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\r\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\r\n * @event Client#tokenExpired\r\n * @type {void}\r\n */\r\n"]},"metadata":{},"sourceType":"script"}