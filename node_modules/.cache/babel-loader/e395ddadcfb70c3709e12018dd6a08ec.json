{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriptions = void 0;\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\n\n\nclass SubscribedEntity {\n  constructor(entity) {\n    this.localObject = entity;\n    this.pendingCorrelationId = null;\n    this.pendingAction = null;\n    this.established = false;\n    this.retryCount = 0;\n  }\n\n  get sid() {\n    return this.localObject.sid;\n  }\n\n  get type() {\n    return this.localObject.type;\n  }\n\n  get lastEventId() {\n    return this.localObject.lastEventId;\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return this.localObject.indexName;\n  }\n\n  get queryString() {\n    return this.localObject.queryString;\n  }\n\n  get isEstablished() {\n    return this.established;\n  }\n\n  update(event, isStrictlyOrdered) {\n    this.localObject._update(event, isStrictlyOrdered);\n  }\n\n  updatePending(action, correlationId) {\n    this.pendingAction = action;\n    this.pendingCorrelationId = correlationId;\n  }\n\n  reset() {\n    this.updatePending(null, null);\n    this.retryCount = 0;\n    this.established = false;\n    this.setSubscriptionState('none');\n  }\n\n  markAsFailed(message) {\n    this.rejectedWithError = message.error;\n    this.updatePending(null, null);\n    this.localObject.reportFailure(new syncerror_1.SyncError(`Failed to subscribe on service events: ${message.error.message}`, message.error.status, message.error.code));\n  }\n\n  complete(eventId) {\n    this.updatePending(null, null);\n    this.established = true;\n\n    this.localObject._advanceLastEventId(eventId);\n  }\n\n  setSubscriptionState(newState) {\n    this.localObject._setSubscriptionState(newState);\n  }\n\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\n\n\nclass Subscriptions {\n  /**\n   * @constructor\n   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n   *\n   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n   *\n   * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n   */\n  constructor(services) {\n    this.isConnected = false;\n    this.maxBatchSize = 100; // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n    // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n    // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n\n    this.subscriptionTtlTimer = null;\n    this.pendingPokeReason = null;\n    this.services = services;\n    this.subscriptions = new Map();\n    this.persisted = new Map();\n    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n    const defaultBackoffConfig = {\n      randomisationFactor: 0.2,\n      initialDelay: 100,\n      maxDelay: 2 * 60 * 1000\n    };\n    this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n    // backoff 'ready' event, at which point a new subscription set is calculated.\n\n    this.backoff.on('ready', () => {\n      let {\n        action: action,\n        subscriptions: subscriptionRequests\n      } = this.getSubscriptionUpdateBatch();\n\n      if (action) {\n        this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n      } else {\n        this.backoff.reset();\n        logger_1.default.debug('All subscriptions resolved.');\n      }\n    });\n  }\n\n  getSubscriptionUpdateBatch() {\n    function subtract(these, those, action, limit) {\n      let result = [];\n\n      for (let [thisKey, thisValue] of these) {\n        const otherValue = those.get(thisKey);\n\n        if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n          result.push(thisValue);\n\n          if (limit && result.length >= limit) {\n            break;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n\n    if (listToAdd.length > 0) {\n      return {\n        action: 'establish',\n        subscriptions: listToAdd\n      };\n    }\n\n    let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n\n    if (listToRemove.length > 0) {\n      return {\n        action: 'cancel',\n        subscriptions: listToRemove\n      };\n    }\n\n    return {\n      action: null,\n      subscriptions: null\n    };\n  }\n\n  persist() {\n    this.backoff.backoff();\n  }\n\n  async applyNewSubscriptionUpdateBatch(action, requests) {\n    if (!this.isConnected) {\n      logger_1.default.debug(`Twilsock connection (required for subscription) not ready; waiting…`);\n      this.backoff.reset();\n      return;\n    } // Keeping in mind that events may begin flowing _before_ we receive the response\n\n\n    requests = this.processLocalActions(action, requests);\n    const correlationId = new Date().getTime();\n\n    for (const subscribed of requests) {\n      this.recordActionAttemptOn(subscribed, action, correlationId);\n    }\n\n    let reason = this.pendingPokeReason;\n    this.pendingPokeReason = null; // Send this batch to the service\n\n    try {\n      let response = await this.request(action, correlationId, reason, requests);\n      let newMaxBatchSize = response.body.max_batch_size;\n\n      if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n        this.maxBatchSize = newMaxBatchSize;\n      }\n\n      if (!this.subscriptionTtlTimer) {\n        let subscriptionTtlInS = response.body.ttl_in_s;\n        let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n        let isValidTtl = isNumeric && subscriptionTtlInS > 0;\n\n        if (isValidTtl) {\n          this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n        }\n      }\n\n      if (action === 'establish') {\n        const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n        let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n        let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n\n        if (isValidTimeout) {\n          setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n        } else {\n          logger_1.default.error(`Invalid timeout: ${estimatedDeliveryInMs}`);\n        }\n\n        requests.filter(r => r.pendingCorrelationId === correlationId).forEach(r => r.setSubscriptionState('response_in_flight'));\n      }\n\n      this.backoff.reset();\n    } catch (e) {\n      for (const attemptedSubscription of requests) {\n        this.recordActionFailureOn(attemptedSubscription, action);\n      }\n\n      if (e instanceof twilsock_1.TransportUnavailableError) {\n        logger_1.default.debug(`Twilsock connection (required for subscription) not ready (c:${correlationId}); waiting…`);\n        this.backoff.reset();\n      } else {\n        logger_1.default.debug(`Failed an attempt to ${action} subscriptions (c:${correlationId}); retrying`, e);\n        this.persist();\n      }\n    }\n  }\n\n  verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n    const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n    const silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;\n\n    if (silencePeriod >= estimatedDeliveryInMs) {\n      // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n      requests.filter(r => r.pendingCorrelationId === correlationId).forEach(r => {\n        r.updatePending(null, null);\n        r.retryCount++;\n        this.persisted.delete(r.sid);\n      });\n      this.persist();\n      this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n    } else {\n      // Otherwise, the poke responses are probably in transit and we should wait for them\n      const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n      setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n    }\n  }\n\n  processLocalActions(action, requests) {\n    if (action === 'cancel') {\n      return requests.filter(request => !request.rejectedWithError);\n    }\n\n    return requests;\n  }\n\n  recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n    attemptedSubscription.setSubscriptionState('request_in_flight');\n\n    if (action === 'establish') {\n      this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n      attemptedSubscription.updatePending(action, correlationId);\n    } else {\n      // cancel\n      let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n\n      if (persistedSubscription) {\n        persistedSubscription.updatePending(action, correlationId);\n      }\n    }\n  }\n\n  recordActionFailureOn(attemptedSubscription, action) {\n    attemptedSubscription.setSubscriptionState('none');\n    attemptedSubscription.updatePending(null, null);\n\n    if (action === 'establish') {\n      this.persisted.delete(attemptedSubscription.sid);\n    }\n  }\n\n  request(action, correlationId, reason, objects) {\n    let requests = objects.map(object => ({\n      object_sid: object.sid,\n      object_type: object.type,\n      last_event_id: action === 'establish' ? object.lastEventId : undefined,\n      index_name: action === 'establish' ? object.indexName : undefined,\n      query_string: action === 'establish' ? object.queryString : undefined\n    }));\n    let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n    logger_1.default.debug(`Attempting '${action}' request (c:${correlationId}):`, requests);\n    const requestBody = {\n      event_protocol_version: 3,\n      action,\n      correlation_id: correlationId,\n      retried_requests: retriedRequests,\n      ttl_in_s: -1,\n      requests\n    };\n\n    if (reason === 'ttl') {\n      requestBody.reason = reason;\n    }\n\n    return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n  }\n  /**\n   * Establishes intent to be subscribed to this entity. That subscription will be effected\n   * asynchronously.\n   * If subscription to the given sid already exists, it will be overwritten.\n   *\n   * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n   * @param {Object} entity should represent the (singular) local representation of this entity.\n   *      Incoming events and modifications to the entity will be directed at the _update() function\n   *      of this provided reference.\n   *\n   * @return undefined\n   */\n\n\n  add(sid, entity) {\n    logger_1.default.debug(`Establishing intent to subscribe to ${sid}`);\n    const existingSubscription = this.subscriptions.get(sid);\n\n    if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n      // If last event id is the same as before - we're fine\n      return;\n    }\n\n    this.persisted.delete(sid);\n    this.subscriptions.set(sid, new SubscribedEntity(entity));\n    this.persist();\n  }\n  /**\n   * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n   * call, no further events shall be routed to the local representation of the entity, even\n   * though a server-side subscription may take more time to actually terminate.\n   *\n   * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n   *      This call only has meaningful effect if that entity is subscribed at the\n   *      time of call. Otherwise does nothing.\n   *\n   * @return undefined\n   */\n\n\n  remove(sid) {\n    logger_1.default.debug(`Establishing intent to unsubscribe from ${sid}`);\n    const removed = this.subscriptions.delete(sid);\n\n    if (removed) {\n      this.persist();\n    }\n  }\n  /**\n   * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n   * to which we are subscribed).\n   *\n   * @param {object} message is the full, unaltered body of the incoming notification.\n   *\n   * @return undefined\n   */\n\n\n  acceptMessage(message, isStrictlyOrdered) {\n    logger_1.default.trace('Subscriptions received', message);\n\n    if (message.correlation_id) {\n      this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n    }\n\n    let event_type;\n\n    switch (message.event_type) {\n      case 'subscription_established':\n        this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n        break;\n\n      case 'subscription_canceled':\n        this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n        break;\n\n      case 'subscription_failed':\n        this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n        break;\n\n      case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n        {\n          let typedSid;\n\n          switch (event_type[0]) {\n            case 'map_':\n              typedSid = message.event.map_sid;\n              break;\n\n            case 'list_':\n              typedSid = message.event.list_sid;\n              break;\n\n            case 'document_':\n              typedSid = message.event.document_sid;\n              break;\n\n            case 'stream_':\n              typedSid = message.event.stream_sid;\n              break;\n\n            case 'live_query_':\n              typedSid = message.event.query_id; // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n              // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n              // to this type in legacy clients, which we have to support now; hence a hack)\n\n              isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n\n              if (message.strictly_ordered === true) {\n                isStrictlyOrdered = true;\n              }\n\n              break;\n\n            default:\n              typedSid = undefined;\n          }\n\n          this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n        }\n        break;\n\n      default:\n        logger_1.default.debug(`Dropping unknown message type ${message.event_type}`);\n        break;\n    }\n  }\n\n  applySubscriptionEstablishedMessage(message, correlationId) {\n    const sid = message.object_sid;\n    let subscriptionIntent = this.persisted.get(message.object_sid);\n\n    if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n      if (message.replay_status === 'interrupted') {\n        logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) interrupted; continuing eagerly.`);\n        subscriptionIntent.updatePending(null, null);\n        this.persisted.delete(subscriptionIntent.sid);\n        this.backoff.reset();\n      } else if (message.replay_status === 'completed') {\n        logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) completed. Subscription is ready.`);\n        subscriptionIntent.complete(message.last_event_id);\n        this.persisted.set(message.object_sid, subscriptionIntent);\n        subscriptionIntent.setSubscriptionState('established');\n        this.backoff.reset();\n      }\n    } else {\n      logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n    }\n\n    this.persist();\n  }\n\n  applySubscriptionCancelledMessage(message, correlationId) {\n    let persistedSubscription = this.persisted.get(message.object_sid);\n\n    if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n      persistedSubscription.updatePending(null, null);\n      persistedSubscription.setSubscriptionState('none');\n      this.persisted.delete(message.object_sid);\n    } else {\n      logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n    }\n\n    this.persist();\n  }\n\n  applySubscriptionFailedMessage(message, correlationId) {\n    const sid = message.object_sid;\n    let subscriptionIntent = this.subscriptions.get(sid);\n    let subscription = this.persisted.get(sid);\n\n    if (subscriptionIntent && subscription) {\n      if (subscription.pendingCorrelationId === correlationId) {\n        logger_1.default.error(`Failed to subscribe on ${subscription.sid}`, message.error);\n        subscription.markAsFailed(message);\n        subscription.setSubscriptionState('none');\n      }\n    } else if (!subscriptionIntent && subscription) {\n      this.persisted.delete(sid);\n      subscription.setSubscriptionState('none');\n    }\n\n    this.persist();\n  }\n\n  applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n    if (!sid) {\n      return;\n    } // Looking for subscription descriptor to check if poke has been completed\n\n\n    isStrictlyOrdered = isStrictlyOrdered || (() => {\n      let subscription = this.persisted.get(sid);\n      return subscription && subscription.isEstablished;\n    })(); // Still searching for subscriptionIntents. User could remove subscription already\n\n\n    let subscriptionIntent = this.subscriptions.get(sid);\n\n    if (subscriptionIntent) {\n      message.event.type = message.event_type;\n      subscriptionIntent.update(message.event, isStrictlyOrdered);\n    } else {\n      logger_1.default.debug(`Message dropped for SID '${sid}', for which there is no subscription.`);\n    }\n  }\n\n  onConnectionStateChanged(isConnected) {\n    this.isConnected = isConnected;\n\n    if (isConnected) {\n      this.poke('reconnect');\n    }\n  }\n\n  onSubscriptionTtlElapsed() {\n    if (this.isConnected) {\n      this.poke('ttl');\n    }\n  }\n  /**\n   * Prompts a playback of any missed changes made to any subscribed object. This method\n   * should be invoked whenever the connectivity layer has experienced cross-cutting\n   * delivery failures that would affect the entire local sync set. Any tangible result\n   * of this operation will result in calls to the _update() function of subscribed\n   * Sync entities.\n   */\n\n\n  poke(reason) {\n    logger_1.default.debug(`Triggering event replay for all subscriptions, reason=${reason}`);\n    this.pendingPokeReason = reason;\n\n    if (this.subscriptionTtlTimer) {\n      clearTimeout(this.subscriptionTtlTimer);\n      this.subscriptionTtlTimer = null;\n    }\n\n    let failedSubscriptions = [];\n\n    for (let it of this.persisted.values()) {\n      it.reset();\n\n      if (it.rejectedWithError) {\n        failedSubscriptions.push(it);\n      }\n    }\n\n    this.persisted.clear();\n\n    for (let it of failedSubscriptions) {\n      this.persisted.set(it.sid, it);\n    }\n\n    this.persist();\n  }\n  /**\n   * Stops all communication, clears any subscription intent, and returns.\n   */\n\n\n  shutdown() {\n    this.backoff.reset();\n    this.subscriptions.clear();\n  }\n\n}\n\nexports.Subscriptions = Subscriptions;","map":{"version":3,"sources":["C:/Users/Usuario/Downloads/Twilio/node_modules/twilio-sync/lib/subscriptions.js"],"names":["Object","defineProperty","exports","value","Subscriptions","operation_retrier_1","require","syncerror_1","logger_1","twilsock_1","SubscribedEntity","constructor","entity","localObject","pendingCorrelationId","pendingAction","established","retryCount","sid","type","lastEventId","indexName","queryString","isEstablished","update","event","isStrictlyOrdered","_update","updatePending","action","correlationId","reset","setSubscriptionState","markAsFailed","message","rejectedWithError","error","reportFailure","SyncError","status","code","complete","eventId","_advanceLastEventId","newState","_setSubscriptionState","services","isConnected","maxBatchSize","subscriptionTtlTimer","pendingPokeReason","subscriptions","Map","persisted","latestPokeResponseArrivalTimestampByCorrelationId","defaultBackoffConfig","randomisationFactor","initialDelay","maxDelay","backoff","Backoff","exponential","assign","config","backoffConfig","on","subscriptionRequests","getSubscriptionUpdateBatch","applyNewSubscriptionUpdateBatch","default","debug","subtract","these","those","limit","result","thisKey","thisValue","otherValue","get","push","length","listToAdd","listToRemove","persist","requests","processLocalActions","Date","getTime","subscribed","recordActionAttemptOn","reason","response","request","newMaxBatchSize","body","max_batch_size","isNaN","parseInt","isFinite","subscriptionTtlInS","ttl_in_s","isNumeric","parseFloat","isValidTtl","setTimeout","onSubscriptionTtlElapsed","estimatedDeliveryInMs","estimated_delivery_in_ms","isValidTimeout","verifyPokeDelivery","filter","r","forEach","e","attemptedSubscription","recordActionFailureOn","TransportUnavailableError","lastReceived","silencePeriod","delete","timeoutExtension","set","persistedSubscription","objects","map","object","object_sid","object_type","last_event_id","undefined","index_name","query_string","retriedRequests","a","requestBody","event_protocol_version","correlation_id","retried_requests","network","post","subscriptionsUri","add","existingSubscription","remove","removed","acceptMessage","trace","event_type","applySubscriptionEstablishedMessage","applySubscriptionCancelledMessage","applySubscriptionFailedMessage","match","input","typedSid","map_sid","list_sid","document_sid","stream_sid","query_id","strictly_ordered","applyEventToSubscribedEntity","subscriptionIntent","replay_status","subscription","onConnectionStateChanged","poke","clearTimeout","failedSubscriptions","it","values","clear","shutdown"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriptions = void 0;\nconst operation_retrier_1 = require(\"operation-retrier\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\nclass SubscribedEntity {\n    constructor(entity) {\n        this.localObject = entity;\n        this.pendingCorrelationId = null;\n        this.pendingAction = null;\n        this.established = false;\n        this.retryCount = 0;\n    }\n    get sid() {\n        return this.localObject.sid;\n    }\n    get type() {\n        return this.localObject.type;\n    }\n    get lastEventId() {\n        return this.localObject.lastEventId;\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return this.localObject.indexName;\n    }\n    get queryString() {\n        return this.localObject.queryString;\n    }\n    get isEstablished() {\n        return this.established;\n    }\n    update(event, isStrictlyOrdered) {\n        this.localObject._update(event, isStrictlyOrdered);\n    }\n    updatePending(action, correlationId) {\n        this.pendingAction = action;\n        this.pendingCorrelationId = correlationId;\n    }\n    reset() {\n        this.updatePending(null, null);\n        this.retryCount = 0;\n        this.established = false;\n        this.setSubscriptionState('none');\n    }\n    markAsFailed(message) {\n        this.rejectedWithError = message.error;\n        this.updatePending(null, null);\n        this.localObject.reportFailure(new syncerror_1.SyncError(`Failed to subscribe on service events: ${message.error.message}`, message.error.status, message.error.code));\n    }\n    complete(eventId) {\n        this.updatePending(null, null);\n        this.established = true;\n        this.localObject._advanceLastEventId(eventId);\n    }\n    setSubscriptionState(newState) {\n        this.localObject._setSubscriptionState(newState);\n    }\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\nclass Subscriptions {\n    /**\n     * @constructor\n     * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n     *\n     * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n     *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n     *\n     * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n     */\n    constructor(services) {\n        this.isConnected = false;\n        this.maxBatchSize = 100;\n        // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n        // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n        // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n        this.subscriptionTtlTimer = null;\n        this.pendingPokeReason = null;\n        this.services = services;\n        this.subscriptions = new Map();\n        this.persisted = new Map();\n        this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n        const defaultBackoffConfig = {\n            randomisationFactor: 0.2,\n            initialDelay: 100,\n            maxDelay: 2 * 60 * 1000\n        };\n        this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig));\n        // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n        // backoff 'ready' event, at which point a new subscription set is calculated.\n        this.backoff.on('ready', () => {\n            let { action: action, subscriptions: subscriptionRequests } = this.getSubscriptionUpdateBatch();\n            if (action) {\n                this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n            }\n            else {\n                this.backoff.reset();\n                logger_1.default.debug('All subscriptions resolved.');\n            }\n        });\n    }\n    getSubscriptionUpdateBatch() {\n        function subtract(these, those, action, limit) {\n            let result = [];\n            for (let [thisKey, thisValue] of these) {\n                const otherValue = those.get(thisKey);\n                if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n                    result.push(thisValue);\n                    if (limit && result.length >= limit) {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n        if (listToAdd.length > 0) {\n            return { action: 'establish', subscriptions: listToAdd };\n        }\n        let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n        if (listToRemove.length > 0) {\n            return { action: 'cancel', subscriptions: listToRemove };\n        }\n        return { action: null, subscriptions: null };\n    }\n    persist() {\n        this.backoff.backoff();\n    }\n    async applyNewSubscriptionUpdateBatch(action, requests) {\n        if (!this.isConnected) {\n            logger_1.default.debug(`Twilsock connection (required for subscription) not ready; waiting…`);\n            this.backoff.reset();\n            return;\n        }\n        // Keeping in mind that events may begin flowing _before_ we receive the response\n        requests = this.processLocalActions(action, requests);\n        const correlationId = new Date().getTime();\n        for (const subscribed of requests) {\n            this.recordActionAttemptOn(subscribed, action, correlationId);\n        }\n        let reason = this.pendingPokeReason;\n        this.pendingPokeReason = null;\n        // Send this batch to the service\n        try {\n            let response = await this.request(action, correlationId, reason, requests);\n            let newMaxBatchSize = response.body.max_batch_size;\n            if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                this.maxBatchSize = newMaxBatchSize;\n            }\n            if (!this.subscriptionTtlTimer) {\n                let subscriptionTtlInS = response.body.ttl_in_s;\n                let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                let isValidTtl = isNumeric && subscriptionTtlInS > 0;\n                if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n                }\n            }\n            if (action === 'establish') {\n                const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n                if (isValidTimeout) {\n                    setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n                }\n                else {\n                    logger_1.default.error(`Invalid timeout: ${estimatedDeliveryInMs}`);\n                }\n                requests.filter(r => r.pendingCorrelationId === correlationId)\n                    .forEach(r => r.setSubscriptionState('response_in_flight'));\n            }\n            this.backoff.reset();\n        }\n        catch (e) {\n            for (const attemptedSubscription of requests) {\n                this.recordActionFailureOn(attemptedSubscription, action);\n            }\n            if (e instanceof twilsock_1.TransportUnavailableError) {\n                logger_1.default.debug(`Twilsock connection (required for subscription) not ready (c:${correlationId}); waiting…`);\n                this.backoff.reset();\n            }\n            else {\n                logger_1.default.debug(`Failed an attempt to ${action} subscriptions (c:${correlationId}); retrying`, e);\n                this.persist();\n            }\n        }\n    }\n    verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n        const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n        const silencePeriod = lastReceived ? (new Date().getTime() - lastReceived)\n            : estimatedDeliveryInMs;\n        if (silencePeriod >= estimatedDeliveryInMs) {\n            // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n            requests\n                .filter(r => r.pendingCorrelationId === correlationId)\n                .forEach(r => {\n                r.updatePending(null, null);\n                r.retryCount++;\n                this.persisted.delete(r.sid);\n            });\n            this.persist();\n            this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n        }\n        else {\n            // Otherwise, the poke responses are probably in transit and we should wait for them\n            const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n            setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n        }\n    }\n    processLocalActions(action, requests) {\n        if (action === 'cancel') {\n            return requests.filter(request => !request.rejectedWithError);\n        }\n        return requests;\n    }\n    recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n        attemptedSubscription.setSubscriptionState('request_in_flight');\n        if (action === 'establish') {\n            this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n            attemptedSubscription.updatePending(action, correlationId);\n        }\n        else { // cancel\n            let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n            if (persistedSubscription) {\n                persistedSubscription.updatePending(action, correlationId);\n            }\n        }\n    }\n    recordActionFailureOn(attemptedSubscription, action) {\n        attemptedSubscription.setSubscriptionState('none');\n        attemptedSubscription.updatePending(null, null);\n        if (action === 'establish') {\n            this.persisted.delete(attemptedSubscription.sid);\n        }\n    }\n    request(action, correlationId, reason, objects) {\n        let requests = objects.map(object => ({\n            object_sid: object.sid,\n            object_type: object.type,\n            last_event_id: action === 'establish' ? object.lastEventId : undefined,\n            index_name: action === 'establish' ? object.indexName : undefined,\n            query_string: action === 'establish' ? object.queryString : undefined,\n        }));\n        let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n        logger_1.default.debug(`Attempting '${action}' request (c:${correlationId}):`, requests);\n        const requestBody = {\n            event_protocol_version: 3,\n            action,\n            correlation_id: correlationId,\n            retried_requests: retriedRequests,\n            ttl_in_s: -1,\n            requests\n        };\n        if (reason === 'ttl') {\n            requestBody.reason = reason;\n        }\n        return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n    add(sid, entity) {\n        logger_1.default.debug(`Establishing intent to subscribe to ${sid}`);\n        const existingSubscription = this.subscriptions.get(sid);\n        if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n            // If last event id is the same as before - we're fine\n            return;\n        }\n        this.persisted.delete(sid);\n        this.subscriptions.set(sid, new SubscribedEntity(entity));\n        this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n    remove(sid) {\n        logger_1.default.debug(`Establishing intent to unsubscribe from ${sid}`);\n        const removed = this.subscriptions.delete(sid);\n        if (removed) {\n            this.persist();\n        }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n    acceptMessage(message, isStrictlyOrdered) {\n        logger_1.default.trace('Subscriptions received', message);\n        if (message.correlation_id) {\n            this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n        }\n        let event_type;\n        switch (message.event_type) {\n            case 'subscription_established':\n                this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_canceled':\n                this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_failed':\n                this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n                break;\n            case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n                {\n                    let typedSid;\n                    switch (event_type[0]) {\n                        case 'map_':\n                            typedSid = message.event.map_sid;\n                            break;\n                        case 'list_':\n                            typedSid = message.event.list_sid;\n                            break;\n                        case 'document_':\n                            typedSid = message.event.document_sid;\n                            break;\n                        case 'stream_':\n                            typedSid = message.event.stream_sid;\n                            break;\n                        case 'live_query_':\n                            typedSid = message.event.query_id;\n                            // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                            // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                            // to this type in legacy clients, which we have to support now; hence a hack)\n                            isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n                            if (message.strictly_ordered === true) {\n                                isStrictlyOrdered = true;\n                            }\n                            break;\n                        default:\n                            typedSid = undefined;\n                    }\n                    this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n                }\n                break;\n            default:\n                logger_1.default.debug(`Dropping unknown message type ${message.event_type}`);\n                break;\n        }\n    }\n    applySubscriptionEstablishedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.persisted.get(message.object_sid);\n        if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n            if (message.replay_status === 'interrupted') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) interrupted; continuing eagerly.`);\n                subscriptionIntent.updatePending(null, null);\n                this.persisted.delete(subscriptionIntent.sid);\n                this.backoff.reset();\n            }\n            else if (message.replay_status === 'completed') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) completed. Subscription is ready.`);\n                subscriptionIntent.complete(message.last_event_id);\n                this.persisted.set(message.object_sid, subscriptionIntent);\n                subscriptionIntent.setSubscriptionState('established');\n                this.backoff.reset();\n            }\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionCancelledMessage(message, correlationId) {\n        let persistedSubscription = this.persisted.get(message.object_sid);\n        if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n            persistedSubscription.updatePending(null, null);\n            persistedSubscription.setSubscriptionState('none');\n            this.persisted.delete(message.object_sid);\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionFailedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.subscriptions.get(sid);\n        let subscription = this.persisted.get(sid);\n        if (subscriptionIntent && subscription) {\n            if (subscription.pendingCorrelationId === correlationId) {\n                logger_1.default.error(`Failed to subscribe on ${subscription.sid}`, message.error);\n                subscription.markAsFailed(message);\n                subscription.setSubscriptionState('none');\n            }\n        }\n        else if (!subscriptionIntent && subscription) {\n            this.persisted.delete(sid);\n            subscription.setSubscriptionState('none');\n        }\n        this.persist();\n    }\n    applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n        if (!sid) {\n            return;\n        }\n        // Looking for subscription descriptor to check if poke has been completed\n        isStrictlyOrdered = isStrictlyOrdered || (() => {\n            let subscription = this.persisted.get(sid);\n            return subscription && subscription.isEstablished;\n        })();\n        // Still searching for subscriptionIntents. User could remove subscription already\n        let subscriptionIntent = this.subscriptions.get(sid);\n        if (subscriptionIntent) {\n            message.event.type = message.event_type;\n            subscriptionIntent.update(message.event, isStrictlyOrdered);\n        }\n        else {\n            logger_1.default.debug(`Message dropped for SID '${sid}', for which there is no subscription.`);\n        }\n    }\n    onConnectionStateChanged(isConnected) {\n        this.isConnected = isConnected;\n        if (isConnected) {\n            this.poke('reconnect');\n        }\n    }\n    onSubscriptionTtlElapsed() {\n        if (this.isConnected) {\n            this.poke('ttl');\n        }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n    poke(reason) {\n        logger_1.default.debug(`Triggering event replay for all subscriptions, reason=${reason}`);\n        this.pendingPokeReason = reason;\n        if (this.subscriptionTtlTimer) {\n            clearTimeout(this.subscriptionTtlTimer);\n            this.subscriptionTtlTimer = null;\n        }\n        let failedSubscriptions = [];\n        for (let it of this.persisted.values()) {\n            it.reset();\n            if (it.rejectedWithError) {\n                failedSubscriptions.push(it);\n            }\n        }\n        this.persisted.clear();\n        for (let it of failedSubscriptions) {\n            this.persisted.set(it.sid, it);\n        }\n        this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n    shutdown() {\n        this.backoff.reset();\n        this.subscriptions.clear();\n    }\n}\nexports.Subscriptions = Subscriptions;\n"]},"metadata":{},"sourceType":"script"}