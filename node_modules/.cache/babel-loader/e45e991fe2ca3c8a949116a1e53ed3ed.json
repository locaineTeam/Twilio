{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstantQuery = exports.LiveQuery = exports.queryItems = exports.LiveQueryImpl = exports.InsightsItem = void 0;\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst events_1 = require(\"events\");\n\nconst entity_1 = require(\"./entity\");\n\nconst closeable_1 = require(\"./closeable\");\n\nconst cache_1 = require(\"./cache\");\n\nclass InsightsItem {}\n\nexports.InsightsItem = InsightsItem;\n\nclass LiveQueryImpl extends entity_1.SyncEntity {\n  constructor(descriptor, services, removalHandler, items) {\n    super(services, removalHandler);\n    this.descriptor = descriptor;\n    this.cache = new cache_1.Cache();\n\n    if (items) {\n      items.forEach(item => {\n        this.cache.store(item.key, {\n          key: item.key,\n          value: item.data\n        }, item.revision);\n      });\n    }\n  } // public\n\n\n  get sid() {\n    return this.descriptor.sid;\n  } // private extension of SyncEntity\n\n\n  get uniqueName() {\n    return null;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  static get type() {\n    return 'live_query';\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get indexName() {\n    return this.descriptor.indexName;\n  }\n\n  get queryString() {\n    return this.descriptor.queryExpression;\n  } // custom private props\n\n\n  get queryUri() {\n    return this.descriptor.queryUri;\n  }\n\n  get liveQueryDescriptor() {\n    return this.descriptor;\n  } // dummy stub from iface\n\n\n  onRemoved() {}\n\n  getItems() {\n    const dataByKey = {};\n    this.cache.forEach((key, item) => {\n      dataByKey[key] = item.value;\n    });\n    return dataByKey;\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _update(message, isStrictlyOrdered) {\n    switch (message.type) {\n      case 'live_query_item_updated':\n        this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n        break;\n\n      case 'live_query_item_removed':\n        this.handleItemRemoved(message.item_key, message.item_revision);\n        break;\n\n      case 'live_query_updated':\n        this.handleBatchUpdate(message.items);\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(message.last_event_id);\n    }\n  }\n\n  handleItemMutated(key, value, revision) {\n    if (this.shouldIgnoreEvent(key, revision)) {\n      logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);\n    } else {\n      const newItem = {\n        key,\n        value\n      };\n      this.cache.store(key, newItem, revision);\n      this.broadcastEventToListeners('itemUpdated', newItem);\n    }\n  }\n\n  handleItemRemoved(key, revision) {\n    const force = revision === null;\n\n    if (this.shouldIgnoreEvent(key, revision)) {\n      logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);\n    } else {\n      this.cache.delete(key, revision, force);\n      this.broadcastEventToListeners('itemRemoved', {\n        key\n      });\n    }\n  }\n\n  handleBatchUpdate(items) {\n    // preprocess item set for easy key-based access (it's a one-time constant time operation)\n    let newItems = {};\n\n    if (items != null) {\n      items.forEach(item => {\n        newItems[item.key] = {\n          data: item.data,\n          revision: item.revision\n        };\n      });\n    } // go through existing items and generate update/remove events for them\n\n\n    this.cache.forEach((key, item) => {\n      const newItem = newItems[key];\n\n      if (newItem != null) {\n        this.handleItemMutated(key, newItem.data, newItem.revision);\n      } else {\n        this.handleItemRemoved(key, null); // force deletion w/o revision\n      } // once item is handled, remove it from incoming array\n\n\n      delete newItems[key];\n    }); // once we handled all the known items, handle remaining pack\n\n    for (let key in newItems) {\n      this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n    }\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return key != null && eventId != null && this.cache.isKnown(key, eventId);\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _advanceLastEventId(eventId, revision) {\n    // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n    }\n  }\n\n}\n\nexports.LiveQueryImpl = LiveQueryImpl;\n\nasync function queryItems(params) {\n  let {\n    network,\n    queryString,\n    uri,\n    type\n  } = params;\n\n  if (queryString == null) {\n    // should not be null or undefined\n    throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);\n  }\n\n  const liveQueryRequestBody = {\n    query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n\n  };\n\n  if (type === LiveQuery.type) {\n    liveQueryRequestBody.type = type;\n  }\n\n  let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n  return response.body;\n}\n\nexports.queryItems = queryItems;\n/**\r\n * @class\r\n * @alias LiveQuery\r\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\r\n *     subsequently receives pushed updates whenever new (or updated) records would match the\r\n *     given expression. Updated results are presented row-by-row until this query is explicitly\r\n *     closed.\r\n *\r\n *     Use the {@link Client#liveQuery} method to create a live query.\r\n *\r\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\r\n *\r\n * @fires LiveQuery#itemUpdated\r\n * @fires LiveQuery#itemRemoved\r\n */\n\nclass LiveQuery extends closeable_1.Closeable {\n  /**\r\n   * @private\r\n   */\n  constructor(liveQueryImpl) {\n    super();\n    this.liveQueryImpl = liveQueryImpl;\n    this.liveQueryImpl.attach(this);\n  } // private props\n\n\n  static get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get lastEventId() {\n    return this.liveQueryImpl.lastEventId;\n  } // public\n\n\n  get sid() {\n    return this.liveQueryImpl.sid;\n  }\n  /**\r\n   * Closes this query instance and unsubscribes from further service events.\r\n   * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\r\n   * @public\r\n   */\n\n\n  close() {\n    super.close();\n    this.liveQueryImpl.detach(this.listenerUuid);\n  }\n  /**\r\n   * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\r\n   * @public\r\n   */\n\n\n  getItems() {\n    this.ensureNotClosed();\n    return this.liveQueryImpl.getItems();\n  }\n\n}\n\nexports.LiveQuery = LiveQuery;\n/**\r\n * @class\r\n * @alias InstantQuery\r\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\r\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\r\n * beyond the initial result set.\r\n *\r\n * Use the {@link Client#instantQuery} method to create an Instant Query.\r\n *\r\n * @fires InstantQuery#searchResult\r\n */\n\nclass InstantQuery extends events_1.EventEmitter {\n  /**\r\n   * @private\r\n   */\n  constructor(params) {\n    super();\n    this.queryExpression = null;\n    this.items = {};\n    Object.assign(this, params);\n    this.updateIndexName(params.indexName);\n  } // private props\n\n\n  static get type() {\n    return 'instant_query';\n  }\n\n  get type() {\n    return InstantQuery.type;\n  }\n  /**\r\n   * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\r\n   * event.\r\n   * @param {String} queryExpression A query expression to be executed against the given data index. For more information\r\n   * on the syntax read {@link Client#liveQuery}.\r\n   * @returns {Promise<void>} A promise that resolves when query result has been received.\r\n   * @public\r\n   */\n\n\n  async search(queryExpression) {\n    this.items = {};\n    return queryItems({\n      network: this.network,\n      uri: this.queryUri,\n      queryString: queryExpression\n    }).then(response => {\n      this.queryExpression = queryExpression;\n\n      if (response.items) {\n        response.items.forEach(item => {\n          this.items[item.key] = item.data;\n        });\n      }\n\n      this.emit('searchResult', this.getItems());\n    }).catch(err => {\n      logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);\n      this.queryExpression = null;\n      throw err;\n    });\n  }\n  /**\r\n   * Instantiates a LiveQuery object based on the last known query expression that was passed to the\r\n   * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\r\n   * while current object can be still used to execute repetitive searches.\r\n   * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\r\n   * @public\r\n   */\n\n\n  async subscribe() {\n    if (this.queryExpression == null) {\n      // should not be null or undefined\n      return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));\n    }\n\n    return this.liveQueryCreator(this.indexName, this.queryExpression);\n  }\n  /**\r\n   * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\r\n   * @public\r\n   */\n\n\n  getItems() {\n    return this.items;\n  }\n  /**\r\n   * Set new index name\r\n   * @param {String} indexName New index name to set\r\n   * @returns void\r\n   * @public\r\n   */\n\n\n  updateIndexName(indexName) {\n    if (!indexName || typeof indexName !== 'string') {\n      throw new Error('Index name must contain a non-empty string value');\n    }\n\n    this.indexName = indexName;\n    this.queryUri = this.generateQueryUri(this.indexName);\n  }\n\n  generateQueryUri(indexName) {\n    return new uri_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();\n  }\n\n}\n\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\r\n * @class InsightsItem\r\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\r\n * @property {String} key The identifier that maps to this item within the search result.\r\n * @property {Object} value The contents of the item.\r\n */\n\n/**\r\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\r\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\r\n * {@link InsightsItem}-s.\r\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\r\n */\n\n/**\r\n * Fired when an item has been added or updated.\r\n * @event LiveQuery#itemUpdated\r\n * @param {InsightsItem} item Updated item.\r\n * @example\r\n * liveQuery.on('itemUpdated', function(item) {\r\n *   console.log('Item ' + item.key + ' was updated');\r\n *   console.log('Item value: ', item.value);\r\n * });\r\n */\n\n/**\r\n * Fired when an existing item has been removed.\r\n * @event LiveQuery#itemRemoved\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {String} args.key The key of the removed item.\r\n * @example\r\n * liveQuery.on('itemRemoved', function(args) {\r\n *   console.log('Item ' + args.key + ' was removed');\r\n * });\r\n */\n\n/**\r\n * Fired when a search result is ready.\r\n * @event InstantQuery#searchResult\r\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\r\n * @example\r\n * instantQuery.on('searchResult', function(items) {\r\n *    Object.entries(items).forEach(([key, value]) => {\r\n *      console.log('Search result item key: ' + key);\r\n *      console.log('Search result item value: ' + value);\r\n *    });\r\n * });\r\n */","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilio-sync/lib/livequery.js"],"names":["Object","defineProperty","exports","value","InstantQuery","LiveQuery","queryItems","LiveQueryImpl","InsightsItem","uri_1","require","syncerror_1","logger_1","events_1","entity_1","closeable_1","cache_1","SyncEntity","constructor","descriptor","services","removalHandler","items","cache","Cache","forEach","item","store","key","data","revision","sid","uniqueName","type","lastEventId","last_event_id","indexName","queryString","queryExpression","queryUri","liveQueryDescriptor","onRemoved","getItems","dataByKey","_update","message","isStrictlyOrdered","handleItemMutated","item_key","item_data","item_revision","handleItemRemoved","handleBatchUpdate","_advanceLastEventId","shouldIgnoreEvent","default","trace","newItem","broadcastEventToListeners","force","delete","newItems","eventId","isKnown","params","network","uri","SyncError","liveQueryRequestBody","query_string","response","post","undefined","body","Closeable","liveQueryImpl","attach","close","detach","listenerUuid","ensureNotClosed","EventEmitter","assign","updateIndexName","search","then","emit","catch","err","error","subscribe","Promise","reject","liveQueryCreator","Error","generateQueryUri","UriBuilder","insightsUri","pathSegment","build"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InstantQuery = exports.LiveQuery = exports.queryItems = exports.LiveQueryImpl = exports.InsightsItem = void 0;\r\nconst uri_1 = require(\"./utils/uri\");\r\nconst syncerror_1 = require(\"./utils/syncerror\");\r\nconst logger_1 = require(\"./utils/logger\");\r\nconst events_1 = require(\"events\");\r\nconst entity_1 = require(\"./entity\");\r\nconst closeable_1 = require(\"./closeable\");\r\nconst cache_1 = require(\"./cache\");\r\nclass InsightsItem {\r\n}\r\nexports.InsightsItem = InsightsItem;\r\nclass LiveQueryImpl extends entity_1.SyncEntity {\r\n    constructor(descriptor, services, removalHandler, items) {\r\n        super(services, removalHandler);\r\n        this.descriptor = descriptor;\r\n        this.cache = new cache_1.Cache();\r\n        if (items) {\r\n            items.forEach(item => {\r\n                this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);\r\n            });\r\n        }\r\n    }\r\n    // public\r\n    get sid() {\r\n        return this.descriptor.sid;\r\n    }\r\n    // private extension of SyncEntity\r\n    get uniqueName() {\r\n        return null;\r\n    }\r\n    get type() {\r\n        return LiveQueryImpl.type;\r\n    }\r\n    static get type() {\r\n        return 'live_query';\r\n    }\r\n    get lastEventId() {\r\n        return this.descriptor.last_event_id;\r\n    }\r\n    get indexName() {\r\n        return this.descriptor.indexName;\r\n    }\r\n    get queryString() {\r\n        return this.descriptor.queryExpression;\r\n    }\r\n    // custom private props\r\n    get queryUri() {\r\n        return this.descriptor.queryUri;\r\n    }\r\n    get liveQueryDescriptor() {\r\n        return this.descriptor;\r\n    }\r\n    // dummy stub from iface\r\n    onRemoved() {\r\n    }\r\n    getItems() {\r\n        const dataByKey = {};\r\n        this.cache.forEach((key, item) => {\r\n            dataByKey[key] = item.value;\r\n        });\r\n        return dataByKey;\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _update(message, isStrictlyOrdered) {\r\n        switch (message.type) {\r\n            case 'live_query_item_updated':\r\n                this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\r\n                break;\r\n            case 'live_query_item_removed':\r\n                this.handleItemRemoved(message.item_key, message.item_revision);\r\n                break;\r\n            case 'live_query_updated':\r\n                this.handleBatchUpdate(message.items);\r\n                break;\r\n        }\r\n        if (isStrictlyOrdered) {\r\n            this._advanceLastEventId(message.last_event_id);\r\n        }\r\n    }\r\n    handleItemMutated(key, value, revision) {\r\n        if (this.shouldIgnoreEvent(key, revision)) {\r\n            logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);\r\n        }\r\n        else {\r\n            const newItem = { key, value };\r\n            this.cache.store(key, newItem, revision);\r\n            this.broadcastEventToListeners('itemUpdated', newItem);\r\n        }\r\n    }\r\n    handleItemRemoved(key, revision) {\r\n        const force = (revision === null);\r\n        if (this.shouldIgnoreEvent(key, revision)) {\r\n            logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);\r\n        }\r\n        else {\r\n            this.cache.delete(key, revision, force);\r\n            this.broadcastEventToListeners('itemRemoved', { key });\r\n        }\r\n    }\r\n    handleBatchUpdate(items) {\r\n        // preprocess item set for easy key-based access (it's a one-time constant time operation)\r\n        let newItems = {};\r\n        if (items != null) {\r\n            items.forEach(item => {\r\n                newItems[item.key] = {\r\n                    data: item.data,\r\n                    revision: item.revision\r\n                };\r\n            });\r\n        }\r\n        // go through existing items and generate update/remove events for them\r\n        this.cache.forEach((key, item) => {\r\n            const newItem = newItems[key];\r\n            if (newItem != null) {\r\n                this.handleItemMutated(key, newItem.data, newItem.revision);\r\n            }\r\n            else {\r\n                this.handleItemRemoved(key, null); // force deletion w/o revision\r\n            }\r\n            // once item is handled, remove it from incoming array\r\n            delete newItems[key];\r\n        });\r\n        // once we handled all the known items, handle remaining pack\r\n        for (let key in newItems) {\r\n            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\r\n        }\r\n    }\r\n    shouldIgnoreEvent(key, eventId) {\r\n        return key != null && eventId != null && this.cache.isKnown(key, eventId);\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _advanceLastEventId(eventId, revision) {\r\n        // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\r\n        if (this.lastEventId < eventId) {\r\n            this.descriptor.last_event_id = eventId;\r\n        }\r\n    }\r\n}\r\nexports.LiveQueryImpl = LiveQueryImpl;\r\nasync function queryItems(params) {\r\n    let { network, queryString, uri, type } = params;\r\n    if (queryString == null) { // should not be null or undefined\r\n        throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);\r\n    }\r\n    const liveQueryRequestBody = {\r\n        query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\r\n    };\r\n    if (type === LiveQuery.type) {\r\n        liveQueryRequestBody.type = type;\r\n    }\r\n    let response = await network.post(uri, liveQueryRequestBody, undefined, true);\r\n    return response.body;\r\n}\r\nexports.queryItems = queryItems;\r\n/**\r\n * @class\r\n * @alias LiveQuery\r\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\r\n *     subsequently receives pushed updates whenever new (or updated) records would match the\r\n *     given expression. Updated results are presented row-by-row until this query is explicitly\r\n *     closed.\r\n *\r\n *     Use the {@link Client#liveQuery} method to create a live query.\r\n *\r\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\r\n *\r\n * @fires LiveQuery#itemUpdated\r\n * @fires LiveQuery#itemRemoved\r\n */\r\nclass LiveQuery extends closeable_1.Closeable {\r\n    /**\r\n     * @private\r\n     */\r\n    constructor(liveQueryImpl) {\r\n        super();\r\n        this.liveQueryImpl = liveQueryImpl;\r\n        this.liveQueryImpl.attach(this);\r\n    }\r\n    // private props\r\n    static get type() {\r\n        return LiveQueryImpl.type;\r\n    }\r\n    get type() {\r\n        return LiveQueryImpl.type;\r\n    }\r\n    get lastEventId() {\r\n        return this.liveQueryImpl.lastEventId;\r\n    }\r\n    // public\r\n    get sid() {\r\n        return this.liveQueryImpl.sid;\r\n    }\r\n    /**\r\n     * Closes this query instance and unsubscribes from further service events.\r\n     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\r\n     * @public\r\n     */\r\n    close() {\r\n        super.close();\r\n        this.liveQueryImpl.detach(this.listenerUuid);\r\n    }\r\n    /**\r\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\r\n     * @public\r\n     */\r\n    getItems() {\r\n        this.ensureNotClosed();\r\n        return this.liveQueryImpl.getItems();\r\n    }\r\n}\r\nexports.LiveQuery = LiveQuery;\r\n/**\r\n * @class\r\n * @alias InstantQuery\r\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\r\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\r\n * beyond the initial result set.\r\n *\r\n * Use the {@link Client#instantQuery} method to create an Instant Query.\r\n *\r\n * @fires InstantQuery#searchResult\r\n */\r\nclass InstantQuery extends events_1.EventEmitter {\r\n    /**\r\n     * @private\r\n     */\r\n    constructor(params) {\r\n        super();\r\n        this.queryExpression = null;\r\n        this.items = {};\r\n        Object.assign(this, params);\r\n        this.updateIndexName(params.indexName);\r\n    }\r\n    // private props\r\n    static get type() {\r\n        return 'instant_query';\r\n    }\r\n    get type() {\r\n        return InstantQuery.type;\r\n    }\r\n    /**\r\n     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\r\n     * event.\r\n     * @param {String} queryExpression A query expression to be executed against the given data index. For more information\r\n     * on the syntax read {@link Client#liveQuery}.\r\n     * @returns {Promise<void>} A promise that resolves when query result has been received.\r\n     * @public\r\n     */\r\n    async search(queryExpression) {\r\n        this.items = {};\r\n        return queryItems({\r\n            network: this.network,\r\n            uri: this.queryUri,\r\n            queryString: queryExpression\r\n        })\r\n            .then(response => {\r\n            this.queryExpression = queryExpression;\r\n            if (response.items) {\r\n                response.items.forEach((item) => {\r\n                    this.items[item.key] = item.data;\r\n                });\r\n            }\r\n            this.emit('searchResult', this.getItems());\r\n        })\r\n            .catch(err => {\r\n            logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);\r\n            this.queryExpression = null;\r\n            throw err;\r\n        });\r\n    }\r\n    /**\r\n     * Instantiates a LiveQuery object based on the last known query expression that was passed to the\r\n     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\r\n     * while current object can be still used to execute repetitive searches.\r\n     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\r\n     * @public\r\n     */\r\n    async subscribe() {\r\n        if (this.queryExpression == null) { // should not be null or undefined\r\n            return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));\r\n        }\r\n        return this.liveQueryCreator(this.indexName, this.queryExpression);\r\n    }\r\n    /**\r\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\r\n     * @public\r\n     */\r\n    getItems() {\r\n        return this.items;\r\n    }\r\n    /**\r\n     * Set new index name\r\n     * @param {String} indexName New index name to set\r\n     * @returns void\r\n     * @public\r\n     */\r\n    updateIndexName(indexName) {\r\n        if (!indexName || typeof indexName !== 'string') {\r\n            throw new Error('Index name must contain a non-empty string value');\r\n        }\r\n        this.indexName = indexName;\r\n        this.queryUri = this.generateQueryUri(this.indexName);\r\n    }\r\n    generateQueryUri(indexName) {\r\n        return new uri_1.UriBuilder(this.insightsUri)\r\n            .pathSegment(indexName)\r\n            .pathSegment('Items')\r\n            .build();\r\n    }\r\n}\r\nexports.InstantQuery = InstantQuery;\r\nexports.default = LiveQuery;\r\n/**\r\n * @class InsightsItem\r\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\r\n * @property {String} key The identifier that maps to this item within the search result.\r\n * @property {Object} value The contents of the item.\r\n */\r\n/**\r\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\r\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\r\n * {@link InsightsItem}-s.\r\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\r\n */\r\n/**\r\n * Fired when an item has been added or updated.\r\n * @event LiveQuery#itemUpdated\r\n * @param {InsightsItem} item Updated item.\r\n * @example\r\n * liveQuery.on('itemUpdated', function(item) {\r\n *   console.log('Item ' + item.key + ' was updated');\r\n *   console.log('Item value: ', item.value);\r\n * });\r\n */\r\n/**\r\n * Fired when an existing item has been removed.\r\n * @event LiveQuery#itemRemoved\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {String} args.key The key of the removed item.\r\n * @example\r\n * liveQuery.on('itemRemoved', function(args) {\r\n *   console.log('Item ' + args.key + ' was removed');\r\n * });\r\n */\r\n/**\r\n * Fired when a search result is ready.\r\n * @event InstantQuery#searchResult\r\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\r\n * @example\r\n * instantQuery.on('searchResult', function(items) {\r\n *    Object.entries(items).forEach(([key, value]) => {\r\n *      console.log('Search result item key: ' + key);\r\n *      console.log('Search result item value: ' + value);\r\n *    });\r\n * });\r\n */\r\n"]},"metadata":{},"sourceType":"script"}