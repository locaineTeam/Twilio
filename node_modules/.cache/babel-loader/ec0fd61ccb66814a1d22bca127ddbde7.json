{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar difference = require('../').difference;\n\nvar flatMap = require('../').flatMap;\n/**\r\n * Create a random {@link SSRC}.\r\n * @returns {SSRC}\r\n */\n\n\nfunction createSSRC() {\n  var ssrcMax = 0xffffffff;\n  return String(Math.floor(Math.random() * ssrcMax));\n}\n/**\r\n * @property {string} cName\r\n * @property {boolean} isSimulcastEnabled\r\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\r\n * @property {Set<PrimarySSRC>} primarySSRCs\r\n * @property {string} streamId\r\n * @property {Track.ID} trackId\r\n */\n\n\nvar TrackAttributes = function () {\n  /**\r\n   * Construct a {@link MediaStreamTrack} attribute store.\r\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\r\n   * @param {MediaStreamID} streamId - The MediaStream ID\r\n   * @param {string} cName - The MediaStream cname\r\n   */\n  function TrackAttributes(trackId, streamId, cName) {\n    _classCallCheck(this, TrackAttributes);\n\n    Object.defineProperties(this, {\n      cName: {\n        enumerable: true,\n        value: cName\n      },\n      isSimulcastEnabled: {\n        enumerable: true,\n        value: false,\n        writable: true\n      },\n      primarySSRCs: {\n        enumerable: true,\n        value: new Set()\n      },\n      rtxPairs: {\n        enumerable: true,\n        value: new Map()\n      },\n      streamId: {\n        enumerable: true,\n        value: streamId\n      },\n      trackId: {\n        enumerable: true,\n        value: trackId\n      }\n    });\n  }\n  /**\r\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\r\n   * @returns {void}\r\n   */\n\n\n  _createClass(TrackAttributes, [{\n    key: 'addSimulcastSSRCs',\n    value: function addSimulcastSSRCs() {\n      if (this.isSimulcastEnabled) {\n        return;\n      }\n\n      var simulcastSSRCs = [createSSRC(), createSSRC()];\n      simulcastSSRCs.forEach(function (ssrc) {\n        this.primarySSRCs.add(ssrc);\n      }, this);\n\n      if (this.rtxPairs.size) {\n        simulcastSSRCs.forEach(function (ssrc) {\n          this.rtxPairs.set(createSSRC(), ssrc);\n        }, this);\n      }\n    }\n    /**\r\n     * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\r\n     * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\r\n     * @param {SSRC} ssrc - The {@link SSRC} to be added\r\n     * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\r\n     *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\r\n     * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\r\n     *   {@link SimSSRC}; false otherwise\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: 'addSSRC',\n    value: function addSSRC(ssrc, primarySSRC, isSimSSRC) {\n      if (primarySSRC) {\n        this.rtxPairs.set(ssrc, primarySSRC);\n      } else {\n        this.primarySSRCs.add(ssrc);\n      }\n\n      this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\n    }\n    /**\r\n     * Construct the SDP lines for the {@link TrackAttributes}.\r\n     * @param {boolean} [excludeRtx=false]\r\n     * @returns {Array<string>} Array of SDP lines\r\n     */\n\n  }, {\n    key: 'toSdpLines',\n    value: function toSdpLines(excludeRtx) {\n      var _this = this;\n\n      var rtxPairs = excludeRtx ? [] : Array.from(this.rtxPairs.entries()).map(function (rtxPair) {\n        return rtxPair.reverse();\n      });\n      var simSSRCs = Array.from(this.primarySSRCs.values());\n      var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\n      var attrLines = flatMap(ssrcs, function (ssrc) {\n        return ['a=ssrc:' + ssrc + ' cname:' + _this.cName, 'a=ssrc:' + ssrc + ' msid:' + _this.streamId + ' ' + _this.trackId];\n      });\n      var rtxPairLines = rtxPairs.map(function (rtxPair) {\n        return 'a=ssrc-group:FID ' + rtxPair.join(' ');\n      });\n      var simGroupLines = ['a=ssrc-group:SIM ' + simSSRCs.join(' ')];\n      return rtxPairLines.concat(attrLines).concat(simGroupLines);\n    }\n  }]);\n\n  return TrackAttributes;\n}();\n/**\r\n * Get the matches for a given RegEx pattern.\r\n * @param {string} section - SDP media section\r\n * @param {string} pattern - RegEx pattern\r\n * @returns {Array<Array<string>>} - Array of pattern matches\r\n */\n\n\nfunction getMatches(section, pattern) {\n  var matches = section.match(new RegExp(pattern, 'gm')) || [];\n  return matches.map(function (match) {\n    var matches = match.match(new RegExp(pattern)) || [];\n    return matches.slice(1);\n  });\n}\n/**\r\n * Get the {@link SimSSRC}s that belong to a simulcast group.\r\n * @param {string} section - SDP media section\r\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\r\n */\n\n\nfunction getSimulcastSSRCs(section) {\n  var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\n}\n/**\r\n * Get the value of the given attribute for an SSRC.\r\n * @param {string} section - SDP media section\r\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\r\n * @param {string} attribute - {@link SSRC} attribute name\r\n * @param {string} - {@link SSRC} attribute value\r\n */\n\n\nfunction getSSRCAttribute(section, ssrc, attribute) {\n  var pattern = 'a=ssrc:' + ssrc + ' ' + attribute + ':(.+)';\n  return section.match(new RegExp(pattern))[1];\n}\n/**\r\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\r\n * @param {string} section - SDP media section\r\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\r\n *   corresponding {@link PrimarySSRC}s\r\n */\n\n\nfunction getSSRCRtxPairs(section) {\n  var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\n  return new Map(getMatches(section, rtxPairPattern).map(function (pair) {\n    return pair.reverse();\n  }));\n}\n/**\r\n * Create SSRC attribute tuples.\r\n * @param {string} section\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\r\n */\n\n\nfunction createSSRCAttributeTuples(section, sdpFormat) {\n  return {\n    planb: createPlanBSSRCAttributeTuples,\n    unified: createUnifiedPlanSSRCAttributeTuples\n  }[sdpFormat](section);\n}\n/**\r\n * Create \"plan-b\" SSRC attribute tuples.\r\n * @param {string} section\r\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\r\n */\n\n\nfunction createPlanBSSRCAttributeTuples(section) {\n  return getMatches(section, '^a=ssrc:([0-9]+) msid:([^\\\\s]+) ([^\\\\s]+)$');\n}\n/**\r\n * Create \"unified-plan\" SSRC attribute tuples.\r\n * @param {string} section\r\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\r\n */\n\n\nfunction createUnifiedPlanSSRCAttributeTuples(section) {\n  var _flatMap = flatMap(getMatches(section, '^a=msid:(.+) (.+)$')),\n      _flatMap2 = _slicedToArray(_flatMap, 2),\n      streamId = _flatMap2[0],\n      trackId = _flatMap2[1];\n\n  var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\n  return ssrcs.map(function (ssrc) {\n    return [ssrc, streamId, trackId];\n  });\n}\n/**\r\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\r\n * @param {string} section - SDP media section\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @returns {Map<Track.ID, TrackAttributes>}\r\n */\n\n\nfunction createTrackIdsToAttributes(section, sdpFormat) {\n  var simSSRCs = getSimulcastSSRCs(section);\n  var rtxPairs = getSSRCRtxPairs(section);\n  var ssrcAttrTuples = createSSRCAttributeTuples(section, sdpFormat);\n  return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {\n    var ssrc = tuple[0];\n    var streamId = tuple[1];\n    var trackId = tuple[2];\n    var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));\n    var primarySSRC = rtxPairs.get(ssrc) || null;\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\n  }, new Map());\n}\n/**\r\n * Apply simulcast settings to the given SDP media section.\r\n * @param {string} section - SDP media section\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\r\n *   map which will be updated for new MediaStreamTrack IDs\r\n * @returns {string} - The transformed SDP media section\r\n */\n\n\nfunction setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) {\n  var newTrackIdsToAttributes = createTrackIdsToAttributes(section, sdpFormat);\n  var newTrackIds = Array.from(newTrackIdsToAttributes.keys());\n  var trackIds = Array.from(trackIdsToAttributes.keys());\n  var trackIdsToAdd = difference(newTrackIds, trackIds);\n  var trackIdsToIgnore = difference(trackIds, newTrackIds); // Update \"trackIdsToAttributes\" with TrackAttributes for new\n  // MediaStreamTrack IDs.\n\n  var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) {\n    return newTrackIdsToAttributes.get(trackId);\n  });\n  trackAttributesToAdd.forEach(function (trackAttributes) {\n    trackAttributes.addSimulcastSSRCs();\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\n  }); // Get the SDP lines of the relevant MediaStreamTrack IDs from\n  // \"trackIdsToAttributes\".\n\n  trackIds = Array.from(trackIdsToAttributes.keys());\n  var relevantTrackIds = difference(trackIds, trackIdsToIgnore);\n  var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) {\n    return trackIdsToAttributes.get(trackId);\n  });\n  var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\n  var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) {\n    return trackAttributes.toSdpLines(excludeRtx);\n  }); // Add the simulcast SSRC SDP lines to the media section. The Set ensures\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\n  // \"relevantSdpLines\" are removed.\n\n  var sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\n  var xGoogleFlagConference = 'a=x-google-flag:conference';\n\n  if (!section.match(xGoogleFlagConference)) {\n    sectionLines.push(xGoogleFlagConference);\n  }\n\n  return sectionLines.join('\\r\\n');\n}\n/**\r\n * String representing a MediaStream ID.\r\n * @typedef {string} MediaStreamID\r\n */\n\n/**\r\n * String representing the SSRC of a MediaStreamTrack.\r\n * @typedef {string} SSRC\r\n */\n\n/**\r\n * Primary SSRC.\r\n * @typedef {SSRC} PrimarySSRC\r\n */\n\n/**\r\n * Retransmission SSRC.\r\n * @typedef {SSRC} RtxSSRC\r\n */\n\n/**\r\n * Simulcast SSRC.\r\n * @typedef {SSRC} SimSSRC\r\n */\n\n\nmodule.exports = setSimulcastInMediaSection;","map":{"version":3,"sources":["C:/Users/Usuario/Downloads/Twilio/node_modules/twilio-video/es5/util/sdp/simulcast.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","difference","require","flatMap","createSSRC","ssrcMax","String","Math","floor","random","TrackAttributes","trackId","streamId","cName","isSimulcastEnabled","primarySSRCs","Set","rtxPairs","Map","addSimulcastSSRCs","simulcastSSRCs","forEach","ssrc","add","size","set","addSSRC","primarySSRC","isSimSSRC","toSdpLines","excludeRtx","_this","from","entries","map","rtxPair","reverse","simSSRCs","values","ssrcs","attrLines","rtxPairLines","join","simGroupLines","concat","getMatches","section","pattern","matches","match","RegExp","slice","getSimulcastSSRCs","simGroupPattern","getSSRCAttribute","attribute","getSSRCRtxPairs","rtxPairPattern","pair","createSSRCAttributeTuples","sdpFormat","planb","createPlanBSSRCAttributeTuples","unified","createUnifiedPlanSSRCAttributeTuples","_flatMap","_flatMap2","createTrackIdsToAttributes","ssrcAttrTuples","reduce","trackIdsToSSRCs","tuple","trackAttributes","get","has","setSimulcastInMediaSection","trackIdsToAttributes","newTrackIdsToAttributes","newTrackIds","keys","trackIds","trackIdsToAdd","trackIdsToIgnore","trackAttributesToAdd","relevantTrackIds","relevantTrackAttributes","relevantSdpLines","sectionLines","split","xGoogleFlagConference","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar difference = require('../').difference;\r\nvar flatMap = require('../').flatMap;\r\n\r\n/**\r\n * Create a random {@link SSRC}.\r\n * @returns {SSRC}\r\n */\r\nfunction createSSRC() {\r\n  var ssrcMax = 0xffffffff;\r\n  return String(Math.floor(Math.random() * ssrcMax));\r\n}\r\n\r\n/**\r\n * @property {string} cName\r\n * @property {boolean} isSimulcastEnabled\r\n * @property {Map<RtxSSRC, PrimarySSRC>} rtxPairs\r\n * @property {Set<PrimarySSRC>} primarySSRCs\r\n * @property {string} streamId\r\n * @property {Track.ID} trackId\r\n */\r\n\r\nvar TrackAttributes = function () {\r\n  /**\r\n   * Construct a {@link MediaStreamTrack} attribute store.\r\n   * @param {Track.ID} trackId - The MediaStreamTrack ID\r\n   * @param {MediaStreamID} streamId - The MediaStream ID\r\n   * @param {string} cName - The MediaStream cname\r\n   */\r\n  function TrackAttributes(trackId, streamId, cName) {\r\n    _classCallCheck(this, TrackAttributes);\r\n\r\n    Object.defineProperties(this, {\r\n      cName: {\r\n        enumerable: true,\r\n        value: cName\r\n      },\r\n      isSimulcastEnabled: {\r\n        enumerable: true,\r\n        value: false,\r\n        writable: true\r\n      },\r\n      primarySSRCs: {\r\n        enumerable: true,\r\n        value: new Set()\r\n      },\r\n      rtxPairs: {\r\n        enumerable: true,\r\n        value: new Map()\r\n      },\r\n      streamId: {\r\n        enumerable: true,\r\n        value: streamId\r\n      },\r\n      trackId: {\r\n        enumerable: true,\r\n        value: trackId\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add {@link SimSSRC}s to the {@link TrackAttributes}.\r\n   * @returns {void}\r\n   */\r\n\r\n\r\n  _createClass(TrackAttributes, [{\r\n    key: 'addSimulcastSSRCs',\r\n    value: function addSimulcastSSRCs() {\r\n      if (this.isSimulcastEnabled) {\r\n        return;\r\n      }\r\n      var simulcastSSRCs = [createSSRC(), createSSRC()];\r\n      simulcastSSRCs.forEach(function (ssrc) {\r\n        this.primarySSRCs.add(ssrc);\r\n      }, this);\r\n\r\n      if (this.rtxPairs.size) {\r\n        simulcastSSRCs.forEach(function (ssrc) {\r\n          this.rtxPairs.set(createSSRC(), ssrc);\r\n        }, this);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add the given {@link PrimarySSRC} or {@link RtxSSRC} to the {@link TrackAttributes}\r\n     * and update the \"isSimulcastEnabled\" flag if it is also a {@link SimSSRC}.\r\n     * @param {SSRC} ssrc - The {@link SSRC} to be added\r\n     * @param {?PrimarySSRC} primarySSRC - The {@link PrimarySSRC}; if the given\r\n     *   {@link SSRC} itself is the {@link PrimarySSRC}, then this is set to null\r\n     * @param {boolean} isSimSSRC - true if the given {@link SSRC} is a\r\n     *   {@link SimSSRC}; false otherwise\r\n     * @returns {void}\r\n     */\r\n\r\n  }, {\r\n    key: 'addSSRC',\r\n    value: function addSSRC(ssrc, primarySSRC, isSimSSRC) {\r\n      if (primarySSRC) {\r\n        this.rtxPairs.set(ssrc, primarySSRC);\r\n      } else {\r\n        this.primarySSRCs.add(ssrc);\r\n      }\r\n      this.isSimulcastEnabled = this.isSimulcastEnabled || isSimSSRC;\r\n    }\r\n\r\n    /**\r\n     * Construct the SDP lines for the {@link TrackAttributes}.\r\n     * @param {boolean} [excludeRtx=false]\r\n     * @returns {Array<string>} Array of SDP lines\r\n     */\r\n\r\n  }, {\r\n    key: 'toSdpLines',\r\n    value: function toSdpLines(excludeRtx) {\r\n      var _this = this;\r\n\r\n      var rtxPairs = excludeRtx ? [] : Array.from(this.rtxPairs.entries()).map(function (rtxPair) {\r\n        return rtxPair.reverse();\r\n      });\r\n\r\n      var simSSRCs = Array.from(this.primarySSRCs.values());\r\n      var ssrcs = rtxPairs.length ? flatMap(rtxPairs) : simSSRCs;\r\n\r\n      var attrLines = flatMap(ssrcs, function (ssrc) {\r\n        return ['a=ssrc:' + ssrc + ' cname:' + _this.cName, 'a=ssrc:' + ssrc + ' msid:' + _this.streamId + ' ' + _this.trackId];\r\n      });\r\n      var rtxPairLines = rtxPairs.map(function (rtxPair) {\r\n        return 'a=ssrc-group:FID ' + rtxPair.join(' ');\r\n      });\r\n      var simGroupLines = ['a=ssrc-group:SIM ' + simSSRCs.join(' ')];\r\n\r\n      return rtxPairLines.concat(attrLines).concat(simGroupLines);\r\n    }\r\n  }]);\r\n\r\n  return TrackAttributes;\r\n}();\r\n\r\n/**\r\n * Get the matches for a given RegEx pattern.\r\n * @param {string} section - SDP media section\r\n * @param {string} pattern - RegEx pattern\r\n * @returns {Array<Array<string>>} - Array of pattern matches\r\n */\r\n\r\n\r\nfunction getMatches(section, pattern) {\r\n  var matches = section.match(new RegExp(pattern, 'gm')) || [];\r\n  return matches.map(function (match) {\r\n    var matches = match.match(new RegExp(pattern)) || [];\r\n    return matches.slice(1);\r\n  });\r\n}\r\n\r\n/**\r\n * Get the {@link SimSSRC}s that belong to a simulcast group.\r\n * @param {string} section - SDP media section\r\n * @returns {Set<SimSSRC>} Set of simulcast {@link SSRC}s\r\n */\r\nfunction getSimulcastSSRCs(section) {\r\n  var simGroupPattern = '^a=ssrc-group:SIM ([0-9]+) ([0-9]+) ([0-9]+)$';\r\n  return new Set(flatMap(getMatches(section, simGroupPattern)));\r\n}\r\n\r\n/**\r\n * Get the value of the given attribute for an SSRC.\r\n * @param {string} section - SDP media section\r\n * @param {SSRC} ssrc - {@link SSRC} whose attribute's value is to be determinded\r\n * @param {string} attribute - {@link SSRC} attribute name\r\n * @param {string} - {@link SSRC} attribute value\r\n */\r\nfunction getSSRCAttribute(section, ssrc, attribute) {\r\n  var pattern = 'a=ssrc:' + ssrc + ' ' + attribute + ':(.+)';\r\n  return section.match(new RegExp(pattern))[1];\r\n}\r\n\r\n/**\r\n * Create a Map of {@link PrimarySSRC}s and their {@link RtxSSRC}s.\r\n * @param {string} section - SDP media section\r\n * @returns {Map<RtxSSRC, PrimarySSRC>} - Map of {@link RtxSSRC}s and their\r\n *   corresponding {@link PrimarySSRC}s\r\n */\r\nfunction getSSRCRtxPairs(section) {\r\n  var rtxPairPattern = '^a=ssrc-group:FID ([0-9]+) ([0-9]+)$';\r\n  return new Map(getMatches(section, rtxPairPattern).map(function (pair) {\r\n    return pair.reverse();\r\n  }));\r\n}\r\n\r\n/**\r\n * Create SSRC attribute tuples.\r\n * @param {string} section\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\r\n */\r\nfunction createSSRCAttributeTuples(section, sdpFormat) {\r\n  return {\r\n    planb: createPlanBSSRCAttributeTuples,\r\n    unified: createUnifiedPlanSSRCAttributeTuples\r\n  }[sdpFormat](section);\r\n}\r\n\r\n/**\r\n * Create \"plan-b\" SSRC attribute tuples.\r\n * @param {string} section\r\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\r\n */\r\nfunction createPlanBSSRCAttributeTuples(section) {\r\n  return getMatches(section, '^a=ssrc:([0-9]+) msid:([^\\\\s]+) ([^\\\\s]+)$');\r\n}\r\n\r\n/**\r\n * Create \"unified-plan\" SSRC attribute tuples.\r\n * @param {string} section\r\n * @returns {Array<[SSRC, MediaStreamID, Track.ID]>}\r\n */\r\nfunction createUnifiedPlanSSRCAttributeTuples(section) {\r\n  var _flatMap = flatMap(getMatches(section, '^a=msid:(.+) (.+)$')),\r\n      _flatMap2 = _slicedToArray(_flatMap, 2),\r\n      streamId = _flatMap2[0],\r\n      trackId = _flatMap2[1];\r\n\r\n  var ssrcs = flatMap(getMatches(section, '^a=ssrc:(.+) cname:.+$'));\r\n  return ssrcs.map(function (ssrc) {\r\n    return [ssrc, streamId, trackId];\r\n  });\r\n}\r\n\r\n/**\r\n * Create a Map of MediaStreamTrack IDs and their {@link TrackAttributes}.\r\n * @param {string} section - SDP media section\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @returns {Map<Track.ID, TrackAttributes>}\r\n */\r\nfunction createTrackIdsToAttributes(section, sdpFormat) {\r\n  var simSSRCs = getSimulcastSSRCs(section);\r\n  var rtxPairs = getSSRCRtxPairs(section);\r\n  var ssrcAttrTuples = createSSRCAttributeTuples(section, sdpFormat);\r\n\r\n  return ssrcAttrTuples.reduce(function (trackIdsToSSRCs, tuple) {\r\n    var ssrc = tuple[0];\r\n    var streamId = tuple[1];\r\n    var trackId = tuple[2];\r\n\r\n    var trackAttributes = trackIdsToSSRCs.get(trackId) || new TrackAttributes(trackId, streamId, getSSRCAttribute(section, ssrc, 'cname'));\r\n\r\n    var primarySSRC = rtxPairs.get(ssrc) || null;\r\n    trackAttributes.addSSRC(ssrc, primarySSRC, simSSRCs.has(ssrc));\r\n    return trackIdsToSSRCs.set(trackId, trackAttributes);\r\n  }, new Map());\r\n}\r\n\r\n/**\r\n * Apply simulcast settings to the given SDP media section.\r\n * @param {string} section - SDP media section\r\n * @param {'planb' | 'unified'} sdpFormat\r\n * @param {Map<Track.ID, TrackAttributes>} trackIdsToAttributes - Existing\r\n *   map which will be updated for new MediaStreamTrack IDs\r\n * @returns {string} - The transformed SDP media section\r\n */\r\nfunction setSimulcastInMediaSection(section, sdpFormat, trackIdsToAttributes) {\r\n  var newTrackIdsToAttributes = createTrackIdsToAttributes(section, sdpFormat);\r\n  var newTrackIds = Array.from(newTrackIdsToAttributes.keys());\r\n  var trackIds = Array.from(trackIdsToAttributes.keys());\r\n  var trackIdsToAdd = difference(newTrackIds, trackIds);\r\n  var trackIdsToIgnore = difference(trackIds, newTrackIds);\r\n\r\n  // Update \"trackIdsToAttributes\" with TrackAttributes for new\r\n  // MediaStreamTrack IDs.\r\n  var trackAttributesToAdd = flatMap(trackIdsToAdd, function (trackId) {\r\n    return newTrackIdsToAttributes.get(trackId);\r\n  });\r\n  trackAttributesToAdd.forEach(function (trackAttributes) {\r\n    trackAttributes.addSimulcastSSRCs();\r\n    trackIdsToAttributes.set(trackAttributes.trackId, trackAttributes);\r\n  });\r\n\r\n  // Get the SDP lines of the relevant MediaStreamTrack IDs from\r\n  // \"trackIdsToAttributes\".\r\n  trackIds = Array.from(trackIdsToAttributes.keys());\r\n  var relevantTrackIds = difference(trackIds, trackIdsToIgnore);\r\n  var relevantTrackAttributes = flatMap(relevantTrackIds, function (trackId) {\r\n    return trackIdsToAttributes.get(trackId);\r\n  });\r\n  var excludeRtx = !section.match(/a=rtpmap:[0-9]+ rtx/);\r\n  var relevantSdpLines = flatMap(relevantTrackAttributes, function (trackAttributes) {\r\n    return trackAttributes.toSdpLines(excludeRtx);\r\n  });\r\n\r\n  // Add the simulcast SSRC SDP lines to the media section. The Set ensures\r\n  // that the duplicates of the SSRC SDP lines that are in both \"section\" and\r\n  // \"relevantSdpLines\" are removed.\r\n  var sectionLines = flatMap(new Set(section.split('\\r\\n').concat(relevantSdpLines)));\r\n\r\n  var xGoogleFlagConference = 'a=x-google-flag:conference';\r\n  if (!section.match(xGoogleFlagConference)) {\r\n    sectionLines.push(xGoogleFlagConference);\r\n  }\r\n\r\n  return sectionLines.join('\\r\\n');\r\n}\r\n\r\n/**\r\n * String representing a MediaStream ID.\r\n * @typedef {string} MediaStreamID\r\n */\r\n\r\n/**\r\n * String representing the SSRC of a MediaStreamTrack.\r\n * @typedef {string} SSRC\r\n */\r\n\r\n/**\r\n * Primary SSRC.\r\n * @typedef {SSRC} PrimarySSRC\r\n */\r\n\r\n/**\r\n * Retransmission SSRC.\r\n * @typedef {SSRC} RtxSSRC\r\n */\r\n\r\n/**\r\n * Simulcast SSRC.\r\n * @typedef {SSRC} SimSSRC\r\n */\r\n\r\nmodule.exports = setSimulcastInMediaSection;"]},"metadata":{},"sourceType":"script"}