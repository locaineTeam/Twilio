{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncMap = exports.SyncMapImpl = void 0;\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mapitem_1 = require(\"./mapitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncMapImpl extends entity_1.SyncEntity {\n  /**\r\n   * @private\r\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n\n    if (descriptor.items) {\n      descriptor.items.forEach(itemDescriptor => {\n        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n        this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n      });\n    }\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'map';\n  }\n\n  get type() {\n    return 'map';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  async set(key, value, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(key, input, input => this._putItemUnconditionally(key, value, input.ttl));\n  }\n\n  async get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    } else {\n      return this._getItemFromServer(key);\n    }\n  }\n\n  async _getItemFromServer(key) {\n    let result = await this.queryItems({\n      key: key\n    });\n\n    if (result.items.length < 1) {\n      throw new syncerror_1.SyncError(`No item with key ${key} found`, 404, 54201);\n    } else {\n      return result.items[0];\n    }\n  }\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(key, input, input => this._putItemWithIfMatch(key, mutator, input.ttl));\n  }\n\n  async update(key, obj, itemMetadataUpdates) {\n    return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n  }\n\n  async _putItemUnconditionally(key, data, ttl) {\n    const result = await this._putItemToServer(key, data, undefined, ttl);\n    const item = result.item;\n\n    this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n    return this.cache.get(item.key);\n  }\n\n  async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n    const currentItem = await this.get(key).catch(error => {\n      if (error.status === 404) {\n        // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n        return new mapitem_1.MapItem({\n          key: key,\n          data: {},\n          last_event_id: -1,\n          revision: '-1',\n          url: null,\n          date_updated: null,\n          date_expires: null\n        });\n      } else {\n        throw error;\n      }\n    });\n    let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n\n    if (data) {\n      let ifMatch = currentItem.revision;\n\n      try {\n        const result = await this._putItemToServer(key, data, ifMatch, ttl);\n        const item = result.item;\n\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n        return this.cache.get(item.key);\n      } catch (error) {\n        if (error.status === 412) {\n          await this._getItemFromServer(key);\n          return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return currentItem;\n    }\n  }\n\n  async _putItemToServer(key, data, ifMatch, ttl) {\n    const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n    const requestBody = {\n      data\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    try {\n      const response = await this.services.network.put(url, requestBody, ifMatch);\n      const mapItemDescriptor = response.body;\n      mapItemDescriptor.data = data; // The server does not return the data in the response\n\n      mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n      const added = response.status.code === 201;\n      return {\n        added,\n        item: mapItemDescriptor\n      };\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async remove(key) {\n    if (typeof key === 'undefined') {\n      throw new Error('Key argument is invalid');\n    }\n\n    let item = await this.get(key);\n    let response = await this.services.network.delete(item.uri);\n\n    this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  async queryItems(args) {\n    args = args || {};\n    const uri = new uri_1.UriBuilder(this.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();\n    let response = await this.services.network.get(uri);\n    let items = response.body.items.map(el => {\n      el.date_updated = new Date(el.date_updated);\n      let itemInCache = this.cache.get(el.key);\n\n      if (itemInCache) {\n        this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n      } else {\n        this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n      }\n\n      return this.cache.get(el.key);\n    });\n    const meta = response.body.meta;\n    return new paginator_1.Paginator(items, pageToken => this.queryItems({\n      pageToken\n    }), meta.previous_token, meta.next_token);\n  }\n\n  async getItems(args) {\n    args = args || {};\n    sanitize_1.validatePageSize(args.pageSize);\n    args.limit = args.pageSize || args.limit || 50;\n    args.order = args.order || 'asc';\n    return this.queryItems(args);\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\r\n   * Handle update from the server\r\n   * @private\r\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'map_item_added':\n      case 'map_item_updated':\n        {\n          this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n          update.type === 'map_item_added', true);\n        }\n        break;\n\n      case 'map_item_removed':\n        {\n          this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'map_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.map_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(key, lastEventId)) {\n      logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(key);\n\n      if (!item) {\n        item = new mapitem_1.MapItem({\n          key: key,\n          url,\n          last_event_id: lastEventId,\n          revision,\n          data: value,\n          date_updated: dateUpdated,\n          date_expires: dateExpires\n        });\n        this.cache.store(key, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else {\n        item.update(lastEventId, revision, value, dateUpdated);\n        this.cache.store(key, item, lastEventId);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(key, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      key: key,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async setItemTtl(key, ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    let existingItem = await this.get(key);\n    const requestBody = {\n      ttl\n    };\n    const response = await this.services.network.post(existingItem.uri, requestBody);\n    existingItem.updateDateExpires(response.body.date_expires);\n  }\n\n  async removeMap() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n\n}\n\nexports.SyncMapImpl = SyncMapImpl;\n/**\r\n * @class\r\n * @alias Map\r\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\r\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\r\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\r\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\r\n * programmer to this map on creation. Unique among other Maps.\r\n * @property {Date} dateUpdated Date when the Map was last updated.\r\n *\r\n * @fires Map#removed\r\n * @fires Map#itemAdded\r\n * @fires Map#itemRemoved\r\n * @fires Map#itemUpdated\r\n */\n\nclass SyncMap extends closeable_1.Closeable {\n  constructor(syncMapImpl) {\n    super();\n    this.syncMapImpl = syncMapImpl;\n    this.syncMapImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncMapImpl.uri;\n  }\n\n  get links() {\n    return this.syncMapImpl.links;\n  }\n\n  get revision() {\n    return this.syncMapImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncMapImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncMapImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncMapImpl.type;\n  }\n\n  get type() {\n    return SyncMapImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncMapImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncMapImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncMapImpl.dateUpdated;\n  }\n  /**\r\n   * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\r\n   * @param {String} key Unique item identifier.\r\n   * @param {Object} value Value to be set.\r\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n   * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\r\n   * @public\r\n   * @example\r\n   * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     console.log('Map Item set() successful, item value:', item.value);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map Item set() failed', error);\r\n   *   });\r\n   */\n\n\n  async set(key, value, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.set(key, value, itemMetadataUpdates);\n  }\n  /**\r\n   * Retrieve an item by key.\r\n   * @param {String} key Identifies the desired item.\r\n   * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\r\n   * This promise will be rejected if item was not found.\r\n   * @public\r\n   * @example\r\n   * map.get('myKey')\r\n   *   .then(function(item) {\r\n   *     console.log('Map Item get() successful, item value:', item.value)\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map Item get() failed', error);\r\n   *   });\r\n   */\n\n\n  async get(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.get(key);\n  }\n  /**\r\n   * Schedules a modification to this Map Item that will apply a mutation function.\r\n   * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\r\n   * @param {String} key Selects the map item to be mutated.\r\n   * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\r\n   * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\r\n   * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\r\n   * by this function.\r\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n   * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\r\n   * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\r\n   * @public\r\n   * @example\r\n   * var mutatorFunction = function(currentValue) {\r\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\r\n   *     return currentValue;\r\n   * };\r\n   * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     console.log('Map Item mutate() successful, new value:', item.value)\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map Item mutate() failed', error);\r\n   *   });\r\n   */\n\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n  }\n  /**\r\n   * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\r\n   * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\r\n   * into it.\r\n   * This is equivalent to\r\n   * <pre>\r\n   * map.mutate('myKey', function(currentValue) {\r\n   *   return Object.assign(currentValue, obj));\r\n   * });\r\n   * </pre>\r\n   * @param {String} key Selects the map item to update.\r\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\r\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n   * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\r\n   * @public\r\n   * @example\r\n   * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\r\n   * map.update('myKey', { age: 34 }, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     // Now the Map Item value is { name: 'John Smith', age: 34 }\r\n   *     console.log('Map Item update() successful, new value:', item.value);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map Item update() failed', error);\r\n   *   });\r\n   */\n\n\n  async update(key, obj, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n  }\n  /**\r\n   * Delete an item, given its key.\r\n   * @param {String} key Selects the item to delete.\r\n   * @returns {Promise<void>} A promise to remove an item.\r\n   * The promise will be rejected if 'key' is undefined or an item was not found.\r\n   * @public\r\n   * @example\r\n   * map.remove('myKey')\r\n   *   .then(function() {\r\n   *     console.log('Map Item remove() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map Item remove() failed', error);\r\n   *   });\r\n   */\n\n\n  async remove(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.remove(key);\n  }\n  /**\r\n   * Get a complete list of items from the map.\r\n   * @param {Object} [args] Arguments for query.\r\n   * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\r\n   * @param {Number} [args.pageSize=50] Result page size.\r\n   * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\r\n   * @return {Promise<Paginator<MapItem>>}\r\n   * @public\r\n   * @example\r\n   * var pageHandler = function(paginator) {\r\n   *   paginator.items.forEach(function(item) {\r\n   *     console.log('Item ' + item.key + ': ', item.value);\r\n   *   });\r\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\r\n   *                                : null;\r\n   * };\r\n   * map.getItems({ from: 'myKey', order: 'asc' })\r\n   *   .then(pageHandler)\r\n   *   .catch(function(error) {\r\n   *     console.error('Map getItems() failed', error);\r\n   *   });\r\n   */\n\n\n  async getItems(args) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.getItems(args);\n  }\n  /**\r\n   * Update the time-to-live of the map.\r\n   * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\r\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n   * @public\r\n   * @example\r\n   * map.setTtl(3600)\r\n   *   .then(function() {\r\n   *     console.log('Map setTtl() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map setTtl() failed', error);\r\n   *   });\r\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setTtl(ttl);\n  }\n  /**\r\n   * Update the time-to-live of a map item.\r\n   * @param {Number} key Item key.\r\n   * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\r\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n   * @public\r\n   * @example\r\n   * map.setItemTtl('myKey', 86400)\r\n   *   .then(function() {\r\n   *     console.log('Map setItemTtl() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map setItemTtl() failed', error);\r\n   *   });\r\n   */\n\n\n  async setItemTtl(key, ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setItemTtl(key, ttl);\n  }\n  /**\r\n   * Delete this map. It will be impossible to restore it.\r\n   * @return {Promise<void>} A promise that resolves when the map has been deleted.\r\n   * @public\r\n   * @example\r\n   * map.removeMap()\r\n   *   .then(function() {\r\n   *     console.log('Map removeMap() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('Map removeMap() failed', error);\r\n   *   });\r\n   */\n\n\n  async removeMap() {\n    this.ensureNotClosed();\n    await this.syncMapImpl.removeMap();\n  }\n  /**\r\n   * Conclude work with the map instance and remove all event listeners attached to it.\r\n   * Any subsequent operation on this object will be rejected with error.\r\n   * Other local copies of this map will continue operating and receiving events normally.\r\n   * @public\r\n   * @example\r\n   * map.close();\r\n   */\n\n\n  close() {\n    super.close();\n    this.syncMapImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\r\n * Contains Map Item metadata.\r\n * @typedef {Object} Map#ItemMetadata\r\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\r\n * The value 0 means infinity.\r\n */\n\n/**\r\n * Applies a transformation to the item value. May be called multiple times on the\r\n * same datum in case of collisions with remote code.\r\n * @callback Map~Mutator\r\n * @param {Object} currentValue The current value of the item in the cloud.\r\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\r\n */\n\n/**\r\n * Fired when a new item appears in the map, whether its creator was local or remote.\r\n * @event Map#itemAdded\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {MapItem} args.item Added item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\r\n * @example\r\n * map.on('itemAdded', function(args) {\r\n *   console.log('Map item ' + args.item.key + ' was added');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\r\n * @event Map#itemUpdated\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {MapItem} args.item Updated item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\r\n * @example\r\n * map.on('itemUpdated', function(args) {\r\n *   console.log('Map item ' + args.item.key + ' was updated');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a map item is removed, whether the remover was local or remote.\r\n * @event Map#itemRemoved\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {String} args.key The key of the removed item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\r\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\r\n * @example\r\n * map.on('itemRemoved', function(args) {\r\n *   console.log('Map item ' + args.key + ' was removed');\r\n *   console.log('args.value:', args.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a map is deleted entirely, by any actor local or remote.\r\n * @event Map#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\r\n * @example\r\n * map.on('removed', function(args) {\r\n *   console.log('Map ' + map.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */","map":{"version":3,"sources":["C:/Users/IJuanchoG/Desktop/Twilio/node_modules/twilio-sync/lib/syncmap.js"],"names":["Object","defineProperty","exports","value","SyncMap","SyncMapImpl","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","mapitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","SyncEntity","constructor","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","items","forEach","itemDescriptor","store","key","MapItem","last_event_id","uri","url","links","revision","lastEventId","dateExpires","date_expires","type","indexName","undefined","queryString","sid","uniqueName","unique_name","dateUpdated","set","itemMetadataUpdates","validateOptionalTtl","squashAndAdd","_putItemUnconditionally","get","has","_getItemFromServer","result","queryItems","length","SyncError","mutate","mutator","add","_putItemWithIfMatch","update","obj","remote","assign","data","_putItemToServer","item","_handleItemMutated","added","mutatorFunction","currentItem","catch","error","status","deepClone","ifMatch","UriBuilder","pathSegment","build","requestBody","response","network","put","mapItemDescriptor","body","code","onRemoved","remove","Error","delete","_handleItemRemoved","args","queryParam","from","limit","pageToken","order","map","el","itemInCache","meta","Paginator","previous_token","next_token","getItems","validatePageSize","pageSize","shouldIgnoreEvent","eventId","isKnown","_update","isStrictlyOrdered","date_created","item_key","item_url","id","item_revision","item_data","_advanceLastEventId","map_revision","_updateRootDateUpdated","getTime","storage","default","trace","emitItemMutationEvent","updateDateExpires","eventName","broadcastEventToListeners","isLocal","oldData","locally","_unsubscribe","setTtl","validateMandatoryTtl","post","setItemTtl","existingItem","removeMap","Closeable","syncMapImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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AACA;AACA;AACA;AACA;;;AACgB,QAAN8B,MAAM,CAAC9B,GAAD,EAAM+B,OAAN,EAAeZ,mBAAf,EAAoC;AAC5C,SAAKiG,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBpF,MAAjB,CAAwB9B,GAAxB,EAA6B+B,OAA7B,EAAsCZ,mBAAtC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANe,MAAM,CAAClC,GAAD,EAAMmC,GAAN,EAAWhB,mBAAX,EAAgC;AACxC,SAAKiG,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBhF,MAAjB,CAAwBlC,GAAxB,EAA6BmC,GAA7B,EAAkChB,mBAAlC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAAN0C,MAAM,CAAC7D,GAAD,EAAM;AACd,SAAKoH,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBrD,MAAjB,CAAwB7D,GAAxB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,QAAR8E,QAAQ,CAACb,IAAD,EAAO;AACjB,SAAKmD,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBpC,QAAjB,CAA0Bb,IAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAAN0C,MAAM,CAACtH,GAAD,EAAM;AACd,SAAK+H,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBP,MAAjB,CAAwBtH,GAAxB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,QAAVyH,UAAU,CAAC9G,GAAD,EAAMX,GAAN,EAAW;AACvB,SAAK+H,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBJ,UAAjB,CAA4B9G,GAA5B,EAAiCX,GAAjC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAT2H,SAAS,GAAG;AACd,SAAKI,eAAL;AACA,UAAM,KAAKF,WAAL,CAAiBF,SAAjB,EAAN;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKH,WAAL,CAAiBI,MAAjB,CAAwB,KAAKC,YAA7B;AACH;;AAtPuC;;AAwP5CzJ,OAAO,CAACE,OAAR,GAAkBA,OAAlB;AACAF,OAAO,CAACmI,OAAR,GAAkBjI,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SyncMap = exports.SyncMapImpl = void 0;\r\nconst sanitize_1 = require(\"./utils/sanitize\");\r\nconst uri_1 = require(\"./utils/uri\");\r\nconst syncerror_1 = require(\"./utils/syncerror\");\r\nconst logger_1 = require(\"./utils/logger\");\r\nconst entity_1 = require(\"./entity\");\r\nconst mapitem_1 = require(\"./mapitem\");\r\nconst paginator_1 = require(\"./paginator\");\r\nconst cache_1 = require(\"./cache\");\r\nconst mergingqueue_1 = require(\"./mergingqueue\");\r\nconst closeable_1 = require(\"./closeable\");\r\nclass SyncMapImpl extends entity_1.SyncEntity {\r\n    /**\r\n     * @private\r\n     */\r\n    constructor(services, descriptor, removalHandler) {\r\n        super(services, removalHandler);\r\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\r\n            : acc;\r\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\r\n        this.cache = new cache_1.Cache();\r\n        this.descriptor = descriptor;\r\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\r\n        if (descriptor.items) {\r\n            descriptor.items.forEach(itemDescriptor => {\r\n                itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\r\n                this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\r\n            });\r\n        }\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.descriptor.url;\r\n    }\r\n    get links() {\r\n        return this.descriptor.links;\r\n    }\r\n    get revision() {\r\n        return this.descriptor.revision;\r\n    }\r\n    get lastEventId() {\r\n        return this.descriptor.last_event_id;\r\n    }\r\n    get dateExpires() {\r\n        return this.descriptor.date_expires;\r\n    }\r\n    static get type() {\r\n        return 'map';\r\n    }\r\n    get type() {\r\n        return 'map';\r\n    }\r\n    // below properties are specific to Insights only\r\n    get indexName() {\r\n        return undefined;\r\n    }\r\n    get queryString() {\r\n        return undefined;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.descriptor.sid;\r\n    }\r\n    get uniqueName() {\r\n        return this.descriptor.unique_name || null;\r\n    }\r\n    get dateUpdated() {\r\n        return this.descriptor.date_updated;\r\n    }\r\n    async set(key, value, itemMetadataUpdates) {\r\n        const input = itemMetadataUpdates || {};\r\n        sanitize_1.validateOptionalTtl(input.ttl);\r\n        return this.updateMergingQueue.squashAndAdd(key, input, (input) => this._putItemUnconditionally(key, value, input.ttl));\r\n    }\r\n    async get(key) {\r\n        if (this.cache.has(key)) {\r\n            return this.cache.get(key);\r\n        }\r\n        else {\r\n            return this._getItemFromServer(key);\r\n        }\r\n    }\r\n    async _getItemFromServer(key) {\r\n        let result = await this.queryItems({ key: key });\r\n        if (result.items.length < 1) {\r\n            throw new syncerror_1.SyncError(`No item with key ${key} found`, 404, 54201);\r\n        }\r\n        else {\r\n            return result.items[0];\r\n        }\r\n    }\r\n    async mutate(key, mutator, itemMetadataUpdates) {\r\n        const input = itemMetadataUpdates || {};\r\n        sanitize_1.validateOptionalTtl(input.ttl);\r\n        return this.updateMergingQueue.add(key, input, (input) => this._putItemWithIfMatch(key, mutator, input.ttl));\r\n    }\r\n    async update(key, obj, itemMetadataUpdates) {\r\n        return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\r\n    }\r\n    async _putItemUnconditionally(key, data, ttl) {\r\n        const result = await this._putItemToServer(key, data, undefined, ttl);\r\n        const item = result.item;\r\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\r\n        return this.cache.get(item.key);\r\n    }\r\n    async _putItemWithIfMatch(key, mutatorFunction, ttl) {\r\n        const currentItem = await this.get(key)\r\n            .catch(error => {\r\n            if (error.status === 404) {\r\n                // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\r\n                return new mapitem_1.MapItem({ key: key, data: {}, last_event_id: -1, revision: '-1', url: null, date_updated: null, date_expires: null });\r\n            }\r\n            else {\r\n                throw error;\r\n            }\r\n        });\r\n        let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\r\n        if (data) {\r\n            let ifMatch = currentItem.revision;\r\n            try {\r\n                const result = await this._putItemToServer(key, data, ifMatch, ttl);\r\n                const item = result.item;\r\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\r\n                return this.cache.get(item.key);\r\n            }\r\n            catch (error) {\r\n                if (error.status === 412) {\r\n                    await this._getItemFromServer(key);\r\n                    return this._putItemWithIfMatch(key, mutatorFunction, ttl);\r\n                }\r\n                else {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return currentItem;\r\n        }\r\n    }\r\n    async _putItemToServer(key, data, ifMatch, ttl) {\r\n        const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\r\n        const requestBody = { data };\r\n        if (ttl !== undefined) {\r\n            requestBody.ttl = ttl;\r\n        }\r\n        try {\r\n            const response = await this.services.network.put(url, requestBody, ifMatch);\r\n            const mapItemDescriptor = response.body;\r\n            mapItemDescriptor.data = data; // The server does not return the data in the response\r\n            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\r\n            const added = response.status.code === 201;\r\n            return { added, item: mapItemDescriptor };\r\n        }\r\n        catch (error) {\r\n            if (error.status === 404) {\r\n                this.onRemoved(false);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    async remove(key) {\r\n        if (typeof key === 'undefined') {\r\n            throw new Error('Key argument is invalid');\r\n        }\r\n        let item = await this.get(key);\r\n        let response = await this.services.network.delete(item.uri);\r\n        this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    async queryItems(args) {\r\n        args = args || {};\r\n        const uri = new uri_1.UriBuilder(this.links.items)\r\n            .queryParam('From', args.from)\r\n            .queryParam('PageSize', args.limit)\r\n            .queryParam('Key', args.key)\r\n            .queryParam('PageToken', args.pageToken)\r\n            .queryParam('Order', args.order)\r\n            .build();\r\n        let response = await this.services.network.get(uri);\r\n        let items = response.body.items.map(el => {\r\n            el.date_updated = new Date(el.date_updated);\r\n            let itemInCache = this.cache.get(el.key);\r\n            if (itemInCache) {\r\n                this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\r\n            }\r\n            else {\r\n                this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\r\n            }\r\n            return this.cache.get(el.key);\r\n        });\r\n        const meta = response.body.meta;\r\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\r\n    }\r\n    async getItems(args) {\r\n        args = args || {};\r\n        sanitize_1.validatePageSize(args.pageSize);\r\n        args.limit = args.pageSize || args.limit || 50;\r\n        args.order = args.order || 'asc';\r\n        return this.queryItems(args);\r\n    }\r\n    shouldIgnoreEvent(key, eventId) {\r\n        return this.cache.isKnown(key, eventId);\r\n    }\r\n    /**\r\n     * Handle update from the server\r\n     * @private\r\n     */\r\n    _update(update, isStrictlyOrdered) {\r\n        update.date_created = new Date(update.date_created);\r\n        switch (update.type) {\r\n            case 'map_item_added':\r\n            case 'map_item_updated':\r\n                {\r\n                    this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\r\n                    update.type === 'map_item_added', true);\r\n                }\r\n                break;\r\n            case 'map_item_removed':\r\n                {\r\n                    this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\r\n                }\r\n                break;\r\n            case 'map_removed':\r\n                {\r\n                    this.onRemoved(false);\r\n                }\r\n                break;\r\n        }\r\n        if (isStrictlyOrdered) {\r\n            this._advanceLastEventId(update.id, update.map_revision);\r\n        }\r\n    }\r\n    _advanceLastEventId(eventId, revision) {\r\n        if (this.lastEventId < eventId) {\r\n            this.descriptor.last_event_id = eventId;\r\n            if (revision) {\r\n                this.descriptor.revision = revision;\r\n            }\r\n        }\r\n    }\r\n    _updateRootDateUpdated(dateUpdated) {\r\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\r\n            this.descriptor.date_updated = dateUpdated;\r\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\r\n        }\r\n    }\r\n    _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\r\n        if (this.shouldIgnoreEvent(key, lastEventId)) {\r\n            logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\r\n            return;\r\n        }\r\n        else {\r\n            this._updateRootDateUpdated(dateUpdated);\r\n            let item = this.cache.get(key);\r\n            if (!item) {\r\n                item = new mapitem_1.MapItem({ key: key, url, last_event_id: lastEventId, revision, data: value, date_updated: dateUpdated, date_expires: dateExpires });\r\n                this.cache.store(key, item, lastEventId);\r\n                this.emitItemMutationEvent(item, remote, added);\r\n            }\r\n            else {\r\n                item.update(lastEventId, revision, value, dateUpdated);\r\n                this.cache.store(key, item, lastEventId);\r\n                if (dateExpires !== undefined) {\r\n                    item.updateDateExpires(dateExpires);\r\n                }\r\n                this.emitItemMutationEvent(item, remote, false);\r\n            }\r\n        }\r\n    }\r\n    emitItemMutationEvent(item, remote, added) {\r\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\r\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\r\n        this._updateRootDateUpdated(dateUpdated);\r\n        this.cache.delete(key, eventId);\r\n        this.broadcastEventToListeners('itemRemoved', { key: key, isLocal: !remote, value: oldData });\r\n    }\r\n    onRemoved(locally) {\r\n        this._unsubscribe();\r\n        this.removalHandler(this.type, this.sid, this.uniqueName);\r\n        this.broadcastEventToListeners('removed', { isLocal: locally });\r\n    }\r\n    async setTtl(ttl) {\r\n        sanitize_1.validateMandatoryTtl(ttl);\r\n        try {\r\n            const requestBody = { ttl };\r\n            const response = await this.services.network.post(this.uri, requestBody);\r\n            this.descriptor.date_expires = response.body.date_expires;\r\n        }\r\n        catch (error) {\r\n            if (error.status === 404) {\r\n                this.onRemoved(false);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    async setItemTtl(key, ttl) {\r\n        sanitize_1.validateMandatoryTtl(ttl);\r\n        let existingItem = await this.get(key);\r\n        const requestBody = { ttl };\r\n        const response = await this.services.network.post(existingItem.uri, requestBody);\r\n        existingItem.updateDateExpires(response.body.date_expires);\r\n    }\r\n    async removeMap() {\r\n        await this.services.network.delete(this.uri);\r\n        this.onRemoved(true);\r\n    }\r\n}\r\nexports.SyncMapImpl = SyncMapImpl;\r\n/**\r\n * @class\r\n * @alias Map\r\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\r\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\r\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\r\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\r\n * programmer to this map on creation. Unique among other Maps.\r\n * @property {Date} dateUpdated Date when the Map was last updated.\r\n *\r\n * @fires Map#removed\r\n * @fires Map#itemAdded\r\n * @fires Map#itemRemoved\r\n * @fires Map#itemUpdated\r\n */\r\nclass SyncMap extends closeable_1.Closeable {\r\n    constructor(syncMapImpl) {\r\n        super();\r\n        this.syncMapImpl = syncMapImpl;\r\n        this.syncMapImpl.attach(this);\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.syncMapImpl.uri;\r\n    }\r\n    get links() {\r\n        return this.syncMapImpl.links;\r\n    }\r\n    get revision() {\r\n        return this.syncMapImpl.revision;\r\n    }\r\n    get lastEventId() {\r\n        return this.syncMapImpl.lastEventId;\r\n    }\r\n    get dateExpires() {\r\n        return this.syncMapImpl.dateExpires;\r\n    }\r\n    static get type() {\r\n        return SyncMapImpl.type;\r\n    }\r\n    get type() {\r\n        return SyncMapImpl.type;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.syncMapImpl.sid;\r\n    }\r\n    get uniqueName() {\r\n        return this.syncMapImpl.uniqueName;\r\n    }\r\n    get dateUpdated() {\r\n        return this.syncMapImpl.dateUpdated;\r\n    }\r\n    /**\r\n     * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\r\n     * @param {String} key Unique item identifier.\r\n     * @param {Object} value Value to be set.\r\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\r\n     * @public\r\n     * @example\r\n     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     console.log('Map Item set() successful, item value:', item.value);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map Item set() failed', error);\r\n     *   });\r\n     */\r\n    async set(key, value, itemMetadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.set(key, value, itemMetadataUpdates);\r\n    }\r\n    /**\r\n     * Retrieve an item by key.\r\n     * @param {String} key Identifies the desired item.\r\n     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\r\n     * This promise will be rejected if item was not found.\r\n     * @public\r\n     * @example\r\n     * map.get('myKey')\r\n     *   .then(function(item) {\r\n     *     console.log('Map Item get() successful, item value:', item.value)\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map Item get() failed', error);\r\n     *   });\r\n     */\r\n    async get(key) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.get(key);\r\n    }\r\n    /**\r\n     * Schedules a modification to this Map Item that will apply a mutation function.\r\n     * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\r\n     * @param {String} key Selects the map item to be mutated.\r\n     * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\r\n     * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\r\n     * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\r\n     * by this function.\r\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n     * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\r\n     * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\r\n     * @public\r\n     * @example\r\n     * var mutatorFunction = function(currentValue) {\r\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\r\n     *     return currentValue;\r\n     * };\r\n     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     console.log('Map Item mutate() successful, new value:', item.value)\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map Item mutate() failed', error);\r\n     *   });\r\n     */\r\n    async mutate(key, mutator, itemMetadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\r\n    }\r\n    /**\r\n     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\r\n     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\r\n     * into it.\r\n     * This is equivalent to\r\n     * <pre>\r\n     * map.mutate('myKey', function(currentValue) {\r\n     *   return Object.assign(currentValue, obj));\r\n     * });\r\n     * </pre>\r\n     * @param {String} key Selects the map item to update.\r\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\r\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\r\n     * @public\r\n     * @example\r\n     * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\r\n     * map.update('myKey', { age: 34 }, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     // Now the Map Item value is { name: 'John Smith', age: 34 }\r\n     *     console.log('Map Item update() successful, new value:', item.value);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map Item update() failed', error);\r\n     *   });\r\n     */\r\n    async update(key, obj, itemMetadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\r\n    }\r\n    /**\r\n     * Delete an item, given its key.\r\n     * @param {String} key Selects the item to delete.\r\n     * @returns {Promise<void>} A promise to remove an item.\r\n     * The promise will be rejected if 'key' is undefined or an item was not found.\r\n     * @public\r\n     * @example\r\n     * map.remove('myKey')\r\n     *   .then(function() {\r\n     *     console.log('Map Item remove() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map Item remove() failed', error);\r\n     *   });\r\n     */\r\n    async remove(key) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.remove(key);\r\n    }\r\n    /**\r\n     * Get a complete list of items from the map.\r\n     * @param {Object} [args] Arguments for query.\r\n     * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\r\n     * @param {Number} [args.pageSize=50] Result page size.\r\n     * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\r\n     * @return {Promise<Paginator<MapItem>>}\r\n     * @public\r\n     * @example\r\n     * var pageHandler = function(paginator) {\r\n     *   paginator.items.forEach(function(item) {\r\n     *     console.log('Item ' + item.key + ': ', item.value);\r\n     *   });\r\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\r\n     *                                : null;\r\n     * };\r\n     * map.getItems({ from: 'myKey', order: 'asc' })\r\n     *   .then(pageHandler)\r\n     *   .catch(function(error) {\r\n     *     console.error('Map getItems() failed', error);\r\n     *   });\r\n     */\r\n    async getItems(args) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.getItems(args);\r\n    }\r\n    /**\r\n     * Update the time-to-live of the map.\r\n     * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\r\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n     * @public\r\n     * @example\r\n     * map.setTtl(3600)\r\n     *   .then(function() {\r\n     *     console.log('Map setTtl() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map setTtl() failed', error);\r\n     *   });\r\n     */\r\n    async setTtl(ttl) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.setTtl(ttl);\r\n    }\r\n    /**\r\n     * Update the time-to-live of a map item.\r\n     * @param {Number} key Item key.\r\n     * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\r\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n     * @public\r\n     * @example\r\n     * map.setItemTtl('myKey', 86400)\r\n     *   .then(function() {\r\n     *     console.log('Map setItemTtl() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map setItemTtl() failed', error);\r\n     *   });\r\n     */\r\n    async setItemTtl(key, ttl) {\r\n        this.ensureNotClosed();\r\n        return this.syncMapImpl.setItemTtl(key, ttl);\r\n    }\r\n    /**\r\n     * Delete this map. It will be impossible to restore it.\r\n     * @return {Promise<void>} A promise that resolves when the map has been deleted.\r\n     * @public\r\n     * @example\r\n     * map.removeMap()\r\n     *   .then(function() {\r\n     *     console.log('Map removeMap() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('Map removeMap() failed', error);\r\n     *   });\r\n     */\r\n    async removeMap() {\r\n        this.ensureNotClosed();\r\n        await this.syncMapImpl.removeMap();\r\n    }\r\n    /**\r\n     * Conclude work with the map instance and remove all event listeners attached to it.\r\n     * Any subsequent operation on this object will be rejected with error.\r\n     * Other local copies of this map will continue operating and receiving events normally.\r\n     * @public\r\n     * @example\r\n     * map.close();\r\n     */\r\n    close() {\r\n        super.close();\r\n        this.syncMapImpl.detach(this.listenerUuid);\r\n    }\r\n}\r\nexports.SyncMap = SyncMap;\r\nexports.default = SyncMap;\r\n/**\r\n * Contains Map Item metadata.\r\n * @typedef {Object} Map#ItemMetadata\r\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\r\n * The value 0 means infinity.\r\n */\r\n/**\r\n * Applies a transformation to the item value. May be called multiple times on the\r\n * same datum in case of collisions with remote code.\r\n * @callback Map~Mutator\r\n * @param {Object} currentValue The current value of the item in the cloud.\r\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\r\n */\r\n/**\r\n * Fired when a new item appears in the map, whether its creator was local or remote.\r\n * @event Map#itemAdded\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {MapItem} args.item Added item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\r\n * @example\r\n * map.on('itemAdded', function(args) {\r\n *   console.log('Map item ' + args.item.key + ' was added');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\r\n * @event Map#itemUpdated\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {MapItem} args.item Updated item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\r\n * @example\r\n * map.on('itemUpdated', function(args) {\r\n *   console.log('Map item ' + args.item.key + ' was updated');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a map item is removed, whether the remover was local or remote.\r\n * @event Map#itemRemoved\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {String} args.key The key of the removed item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\r\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\r\n * @example\r\n * map.on('itemRemoved', function(args) {\r\n *   console.log('Map item ' + args.key + ' was removed');\r\n *   console.log('args.value:', args.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a map is deleted entirely, by any actor local or remote.\r\n * @event Map#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\r\n * @example\r\n * map.on('removed', function(args) {\r\n *   console.log('Map ' + map.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n"]},"metadata":{},"sourceType":"script"}