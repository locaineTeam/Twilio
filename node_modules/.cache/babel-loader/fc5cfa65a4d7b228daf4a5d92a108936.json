{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncListImpl = exports.SyncList = void 0;\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst listitem_1 = require(\"./listitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncListImpl extends entity_1.SyncEntity {\n  /**\r\n   * @private\r\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'list';\n  }\n\n  get type() {\n    return 'list';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {\n    const requestBody = {\n      data\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    const response = await this.services.network.post(url, requestBody, ifMatch);\n    response.body.data = data;\n    response.body.date_updated = new Date(response.body.date_updated);\n    return response.body;\n  }\n\n  async push(value, itemMetadata) {\n    let ttl = (itemMetadata || {}).ttl;\n    sanitize_1.validateOptionalTtl(ttl);\n    let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);\n    let index = Number(item.index);\n\n    this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\n\n    return this.cache.get(index);\n  }\n\n  async set(index, value, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(index, input, input => this._updateItemUnconditionally(index, value, input.ttl));\n  }\n\n  async _updateItemUnconditionally(index, data, ttl) {\n    let existingItem = await this.get(index);\n    const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\n\n    this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n    return this.cache.get(index);\n  }\n\n  async _updateItemWithIfMatch(index, mutatorFunction, ttl) {\n    const existingItem = await this.get(index);\n    const data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\n\n    if (data) {\n      const ifMatch = existingItem.revision;\n\n      try {\n        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\n\n        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n        return this.cache.get(index);\n      } catch (error) {\n        if (error.status === 412) {\n          await this._getItemFromServer(index);\n          return this._updateItemWithIfMatch(index, mutatorFunction, ttl);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return existingItem;\n    }\n  }\n\n  async mutate(index, mutator, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(index, input, input => this._updateItemWithIfMatch(index, mutator, input.ttl));\n  }\n\n  async update(index, obj, itemMetadataUpdates) {\n    return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);\n  }\n\n  async remove(index) {\n    let item = await this.get(index);\n    let response = await this.services.network.delete(item.uri);\n\n    this._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n  }\n\n  async get(index) {\n    let cachedItem = this.cache.get(index);\n\n    if (cachedItem) {\n      return cachedItem;\n    } else {\n      return this._getItemFromServer(index);\n    }\n  }\n\n  async _getItemFromServer(index) {\n    let result = await this.queryItems({\n      index\n    });\n\n    if (result.items.length < 1) {\n      throw new syncerror_1.SyncError(`No item with index ${index} found`, 404, 54151);\n    } else {\n      return result.items[0];\n    }\n  }\n  /**\r\n   * Query items from the List\r\n   * @private\r\n   */\n\n\n  async queryItems(arg) {\n    arg = arg || {};\n    const url = new uri_1.UriBuilder(this.links.items).queryParam('From', arg.from).queryParam('PageSize', arg.limit).queryParam('Index', arg.index).queryParam('PageToken', arg.pageToken).queryParam('Order', arg.order).build();\n    let response = await this.services.network.get(url);\n    let items = response.body.items.map(el => {\n      el.date_updated = new Date(el.date_updated);\n      let itemInCache = this.cache.get(el.index);\n\n      if (itemInCache) {\n        this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n      } else {\n        this.cache.store(Number(el.index), new listitem_1.ListItem({\n          index: Number(el.index),\n          uri: el.url,\n          revision: el.revision,\n          lastEventId: el.last_event_id,\n          dateUpdated: el.date_updated,\n          dateExpires: el.date_expires,\n          value: el.data\n        }), el.last_event_id);\n      }\n\n      return this.cache.get(el.index);\n    });\n    let meta = response.body.meta;\n    return new paginator_1.Paginator(items, pageToken => this.queryItems({\n      pageToken\n    }), meta.previous_token, meta.next_token);\n  }\n\n  async getItems(args) {\n    args = args || {};\n    sanitize_1.validatePageSize(args.pageSize);\n    args.limit = args.pageSize || args.limit || 50;\n    args.order = args.order || 'asc';\n    return this.queryItems(args);\n  }\n  /**\r\n   * @return {Promise<Object>} Context of List\r\n   * @private\r\n   */\n\n\n  async getContext() {\n    if (!this.context) {\n      let response = await this.services.network.get(this.links.context); // store fetched context if we have't received any newer update\n\n      this._updateContextIfRequired(response.body.data, response.body.last_event_id);\n    }\n\n    return this.context;\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async setItemTtl(index, ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    let existingItem = await this.get(index);\n    const requestBody = {\n      ttl\n    };\n    const response = await this.services.network.post(existingItem.uri, requestBody);\n    existingItem.updateDateExpires(response.body.date_expires);\n  }\n\n  async removeList() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\r\n   * Handle update, which came from the server.\r\n   * @private\r\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    const itemIndex = Number(update.item_index);\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'list_item_added':\n      case 'list_item_updated':\n        {\n          this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\n          update.type === 'list_item_added', true);\n        }\n        break;\n\n      case 'list_item_removed':\n        {\n          this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'list_context_updated':\n        {\n          this._handleContextUpdate(update.context_data, update.id, update.date_created);\n        }\n        break;\n\n      case 'list_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.list_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(index, lastEventId)) {\n      logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(index);\n\n      if (!item) {\n        let item = new listitem_1.ListItem({\n          index,\n          uri,\n          lastEventId,\n          revision,\n          value,\n          dateUpdated,\n          dateExpires\n        });\n        this.cache.store(index, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else {\n        item.update(lastEventId, revision, value, dateUpdated);\n        this.cache.store(index, item, lastEventId);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(index, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      index: index,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _handleContextUpdate(data, eventId, dateUpdated) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    if (this._updateContextIfRequired(data, eventId)) {\n      this.broadcastEventToListeners('contextUpdated', {\n        context: data,\n        isLocal: false\n      });\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _updateContextIfRequired(data, eventId) {\n    if (!this.contextEventId || eventId > this.contextEventId) {\n      this.context = data;\n      this.contextEventId = eventId;\n      return true;\n    } else {\n      logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\n      return false;\n    }\n  }\n\n}\n\nexports.SyncListImpl = SyncListImpl;\n/**\r\n * @class\r\n * @alias List\r\n * @classdesc Represents a Sync List, which stores an ordered list of values.\r\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\r\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\r\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\r\n * @property {Date} dateUpdated Date when the List was last updated.\r\n *\r\n * @fires List#removed\r\n * @fires List#itemAdded\r\n * @fires List#itemRemoved\r\n * @fires List#itemUpdated\r\n */\n\nclass SyncList extends closeable_1.default {\n  constructor(syncListImpl) {\n    super();\n    this.syncListImpl = syncListImpl;\n    this.syncListImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncListImpl.uri;\n  }\n\n  get revision() {\n    return this.syncListImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncListImpl.lastEventId;\n  }\n\n  get links() {\n    return this.syncListImpl.links;\n  }\n\n  get dateExpires() {\n    return this.syncListImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncListImpl.type;\n  }\n\n  get type() {\n    return SyncListImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncListImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncListImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncListImpl.dateUpdated;\n  }\n  /**\r\n   * Add a new item to the list.\r\n   * @param {Object} value Value to be added.\r\n   * @param {List#ItemMetadata} [itemMetadata] Item metadata.\r\n   * @returns {Promise<ListItem>} A newly added item.\r\n   * @public\r\n   * @example\r\n   * list.push({ name: 'John Smith' }, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List Item push() failed', error);\r\n   *   });\r\n   */\n\n\n  async push(value, itemMetadata) {\n    this.ensureNotClosed();\n    return this.syncListImpl.push(value, itemMetadata);\n  }\n  /**\r\n   * Assign new value to an existing item, given its index.\r\n   * @param {Number} index Index of the item to be updated.\r\n   * @param {Object} value New value to be assigned to an item.\r\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n   * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\r\n   * The promise will be rejected if the item does not exist.\r\n   * @public\r\n   * @example\r\n   * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     console.log('List Item set() successful, item value:', item.value)\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List Item set() failed', error);\r\n   *   });\r\n   */\n\n\n  async set(index, value, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncListImpl.set(index, value, itemMetadataUpdates);\n  }\n  /**\r\n   * Modify an existing item by applying a mutation function to it.\r\n   * @param {Number} index Index of an item to be changed.\r\n   * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\r\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n   * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\r\n   *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\r\n   *    will be rejected if the indicated item does not already exist.\r\n   * @public\r\n   * @example\r\n   * var mutatorFunction = function(currentValue) {\r\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\r\n   *     return currentValue;\r\n   * };\r\n   * list.mutate(42, mutatorFunction, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     console.log('List Item mutate() successful, new value:', item.value)\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List Item mutate() failed', error);\r\n   *   });\r\n   */\n\n\n  async mutate(index, mutator, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);\n  }\n  /**\r\n   * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\r\n   * This is equivalent to\r\n   * <pre>\r\n   * list.mutate(42, function(currentValue) {\r\n   *   return Object.assign(currentValue, obj));\r\n   * });\r\n   * </pre>\r\n   * @param {Number} index Index of an item to be changed.\r\n   * @param {Object} obj Set of fields to update.\r\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n   * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\r\n   * The promise will be rejected if an item was not found.\r\n   * @public\r\n   * @example\r\n   * // Say, the List Item (index: 42) value is { name: 'John Smith' }\r\n   * list.update(42, { age: 34 }, { ttl: 86400 })\r\n   *   .then(function(item) {\r\n   *     // Now the List Item value is { name: 'John Smith', age: 34 }\r\n   *     console.log('List Item update() successful, new value:', item.value);\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List Item update() failed', error);\r\n   *   });\r\n   */\n\n\n  async update(index, obj, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncListImpl.update(index, obj, itemMetadataUpdates);\n  }\n  /**\r\n   * Delete an item, given its index.\r\n   * @param {Number} index Index of an item to be removed.\r\n   * @returns {Promise<void>} A promise to remove an item.\r\n   * A promise will be rejected if an item was not found.\r\n   * @public\r\n   * @example\r\n   * list.remove(42)\r\n   *   .then(function() {\r\n   *     console.log('List Item remove() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List Item remove() failed', error);\r\n   *   });\r\n   */\n\n\n  async remove(index) {\n    this.ensureNotClosed();\n    return this.syncListImpl.remove(index);\n  }\n  /**\r\n   * Retrieve an item by List index.\r\n   * @param {Number} index Item index in a List.\r\n   * @returns {Promise<ListItem>} A promise with an item containing latest known value.\r\n   * A promise will be rejected if an item was not found.\r\n   * @public\r\n   * @example\r\n   * list.get(42)\r\n   *   .then(function(item) {\r\n   *     console.log('List Item get() successful, item value:', item.value)\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List Item get() failed', error);\r\n   *   });\r\n   */\n\n\n  async get(index) {\n    this.ensureNotClosed();\n    return this.syncListImpl.get(index);\n  }\n  /**\r\n   * Retrieve a List context\r\n   * @returns {Promise<Object>} A promise with a List's context\r\n   * @ignore\r\n   */\n\n\n  async getContext() {\n    this.ensureNotClosed();\n    return this.syncListImpl.getContext();\n  }\n  /**\r\n   * Query a list of items from collection.\r\n   * @param {Object} [args] Arguments for query\r\n   * @param {Number} [args.from] Item index, which should be used as the offset.\r\n   * If undefined, starts from the beginning or end depending on args.order.\r\n   * @param {Number} [args.pageSize=50] Results page size.\r\n   * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\r\n   * @returns {Promise<Paginator<ListItem>>}\r\n   * @public\r\n   * @example\r\n   * var pageHandler = function(paginator) {\r\n   *   paginator.items.forEach(function(item) {\r\n   *     console.log('Item ' + item.index + ': ', item.value);\r\n   *   });\r\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\r\n   *                                : null;\r\n   * };\r\n   * list.getItems({ from: 0, order: 'asc' })\r\n   *   .then(pageHandler)\r\n   *   .catch(function(error) {\r\n   *     console.error('List getItems() failed', error);\r\n   *   });\r\n   */\n\n\n  async getItems(args) {\n    this.ensureNotClosed();\n    return this.syncListImpl.getItems(args);\n  }\n  /**\r\n   * Update the time-to-live of the list.\r\n   * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\r\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n   * @public\r\n   * @example\r\n   * list.setTtl(3600)\r\n   *   .then(function() {\r\n   *     console.log('List setTtl() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List setTtl() failed', error);\r\n   *   });\r\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncListImpl.setTtl(ttl);\n  }\n  /**\r\n   * Update the time-to-live of a list item.\r\n   * @param {Number} index Item index.\r\n   * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\r\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n   * @public\r\n   * @example\r\n   * list.setItemTtl(42, 86400)\r\n   *   .then(function() {\r\n   *     console.log('List setItemTtl() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List setItemTtl() failed', error);\r\n   *   });\r\n   */\n\n\n  async setItemTtl(index, ttl) {\n    this.ensureNotClosed();\n    return this.syncListImpl.setItemTtl(index, ttl);\n  }\n  /**\r\n   * Delete this list. It will be impossible to restore it.\r\n   * @return {Promise<void>} A promise that resolves when the list has been deleted.\r\n   * @public\r\n   * @example\r\n   * list.removeList()\r\n   *   .then(function() {\r\n   *     console.log('List removeList() successful');\r\n   *   })\r\n   *   .catch(function(error) {\r\n   *     console.error('List removeList() failed', error);\r\n   *   });\r\n   */\n\n\n  async removeList() {\n    this.ensureNotClosed();\n    return this.syncListImpl.removeList();\n  }\n  /**\r\n   * Conclude work with the list instance and remove all event listeners attached to it.\r\n   * Any subsequent operation on this object will be rejected with error.\r\n   * Other local copies of this list will continue operating and receiving events normally.\r\n   * @public\r\n   * @example\r\n   * list.close();\r\n   */\n\n\n  close() {\n    super.close();\n    this.syncListImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncList = SyncList;\nexports.default = SyncList;\n/**\r\n * Contains List Item metadata.\r\n * @typedef {Object} List#ItemMetadata\r\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\r\n * The value 0 means infinity.\r\n */\n\n/**\r\n * Applies a transformation to the item value. May be called multiple times on the\r\n * same datum in case of collisions with remote code.\r\n * @callback List~Mutator\r\n * @param {Object} currentValue The current value of the item in the cloud.\r\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\r\n */\n\n/**\r\n * Fired when a new item appears in the list, whether its creator was local or remote.\r\n * @event List#itemAdded\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {ListItem} args.item Added item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\r\n * @example\r\n * list.on('itemAdded', function(args) {\r\n *   console.log('List item ' + args.item.index + ' was added');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\r\n * @event List#itemUpdated\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {ListItem} args.item Updated item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\r\n * @example\r\n * list.on('itemUpdated', function(args) {\r\n *   console.log('List item ' + args.item.index + ' was updated');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a list item is removed, whether the remover was local or remote.\r\n * @event List#itemRemoved\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Number} args.index The index of the removed item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\r\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\r\n * @example\r\n * list.on('itemRemoved', function(args) {\r\n *   console.log('List item ' + args.index + ' was removed');\r\n *   console.log('args.value:', args.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\n\n/**\r\n * Fired when a list is deleted entirely, by any actor local or remote.\r\n * @event List#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\r\n * @example\r\n * list.on('removed', function(args) {\r\n *   console.log('List ' + list.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */","map":{"version":3,"sources":["C:/Users/USER/Desktop/ARSW III/Twilio/node_modules/twilio-sync/lib/synclist.js"],"names":["Object","defineProperty","exports","value","SyncListImpl","SyncList","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","listitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","SyncEntity","constructor","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","uri","url","revision","lastEventId","last_event_id","links","dateExpires","date_expires","type","indexName","undefined","queryString","sid","uniqueName","unique_name","dateUpdated","_addOrUpdateItemOnServer","data","ifMatch","requestBody","response","network","post","body","push","itemMetadata","validateOptionalTtl","item","items","index","Number","_handleItemMutated","get","set","itemMetadataUpdates","squashAndAdd","_updateItemUnconditionally","existingItem","itemDescriptor","_updateItemWithIfMatch","mutatorFunction","deepClone","error","status","_getItemFromServer","mutate","mutator","add","update","obj","remote","assign","remove","delete","_handleItemRemoved","cachedItem","result","queryItems","length","SyncError","arg","UriBuilder","queryParam","from","limit","pageToken","order","build","map","el","itemInCache","store","ListItem","meta","Paginator","previous_token","next_token","getItems","args","validatePageSize","pageSize","getContext","context","_updateContextIfRequired","setTtl","validateMandatoryTtl","onRemoved","setItemTtl","updateDateExpires","removeList","locally","_unsubscribe","broadcastEventToListeners","isLocal","shouldIgnoreEvent","key","eventId","isKnown","_update","isStrictlyOrdered","itemIndex","item_index","date_created","item_url","id","item_revision","item_data","_handleContextUpdate","context_data","_advanceLastEventId","list_revision","_updateRootDateUpdated","getTime","storage","added","default","trace","emitItemMutationEvent","eventName","oldData","contextEventId","syncListImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANkB,MAAM,CAACvB,KAAD,EAAQ;AAChB,SAAK8F,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkBrE,MAAlB,CAAyBvB,KAAzB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACa,QAAHG,GAAG,CAACH,KAAD,EAAQ;AACb,SAAK8F,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkBzF,GAAlB,CAAsBH,KAAtB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACoB,QAAVoD,UAAU,GAAG;AACf,SAAK0C,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkBxC,UAAlB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,QAARJ,QAAQ,CAACC,IAAD,EAAO;AACjB,SAAK6C,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkB5C,QAAlB,CAA2BC,IAA3B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANM,MAAM,CAAC3F,GAAD,EAAM;AACd,SAAKkI,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkBrC,MAAlB,CAAyB3F,GAAzB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,QAAV8F,UAAU,CAAC1D,KAAD,EAAQpC,GAAR,EAAa;AACzB,SAAKkI,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkBlC,UAAlB,CAA6B1D,KAA7B,EAAoCpC,GAApC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,QAAVgG,UAAU,GAAG;AACf,SAAKkC,eAAL;AACA,WAAO,KAAKF,YAAL,CAAkBhC,UAAlB,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACImC,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKH,YAAL,CAAkBI,MAAlB,CAAyB,KAAKC,YAA9B;AACH;;AAhRsC;;AAkR3C5J,OAAO,CAACG,QAAR,GAAmBA,QAAnB;AACAH,OAAO,CAACiJ,OAAR,GAAkB9I,QAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SyncListImpl = exports.SyncList = void 0;\r\nconst sanitize_1 = require(\"./utils/sanitize\");\r\nconst uri_1 = require(\"./utils/uri\");\r\nconst syncerror_1 = require(\"./utils/syncerror\");\r\nconst logger_1 = require(\"./utils/logger\");\r\nconst entity_1 = require(\"./entity\");\r\nconst listitem_1 = require(\"./listitem\");\r\nconst paginator_1 = require(\"./paginator\");\r\nconst cache_1 = require(\"./cache\");\r\nconst mergingqueue_1 = require(\"./mergingqueue\");\r\nconst closeable_1 = require(\"./closeable\");\r\nclass SyncListImpl extends entity_1.SyncEntity {\r\n    /**\r\n     * @private\r\n     */\r\n    constructor(services, descriptor, removalHandler) {\r\n        super(services, removalHandler);\r\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\r\n            : acc;\r\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\r\n        this.cache = new cache_1.Cache();\r\n        this.descriptor = descriptor;\r\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.descriptor.url;\r\n    }\r\n    get revision() {\r\n        return this.descriptor.revision;\r\n    }\r\n    get lastEventId() {\r\n        return this.descriptor.last_event_id;\r\n    }\r\n    get links() {\r\n        return this.descriptor.links;\r\n    }\r\n    get dateExpires() {\r\n        return this.descriptor.date_expires;\r\n    }\r\n    static get type() {\r\n        return 'list';\r\n    }\r\n    get type() {\r\n        return 'list';\r\n    }\r\n    // below properties are specific to Insights only\r\n    get indexName() {\r\n        return undefined;\r\n    }\r\n    get queryString() {\r\n        return undefined;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.descriptor.sid;\r\n    }\r\n    get uniqueName() {\r\n        return this.descriptor.unique_name || null;\r\n    }\r\n    get dateUpdated() {\r\n        return this.descriptor.date_updated;\r\n    }\r\n    async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {\r\n        const requestBody = { data };\r\n        if (ttl !== undefined) {\r\n            requestBody.ttl = ttl;\r\n        }\r\n        const response = await this.services.network.post(url, requestBody, ifMatch);\r\n        response.body.data = data;\r\n        response.body.date_updated = new Date(response.body.date_updated);\r\n        return response.body;\r\n    }\r\n    async push(value, itemMetadata) {\r\n        let ttl = (itemMetadata || {}).ttl;\r\n        sanitize_1.validateOptionalTtl(ttl);\r\n        let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);\r\n        let index = Number(item.index);\r\n        this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\r\n        return this.cache.get(index);\r\n    }\r\n    async set(index, value, itemMetadataUpdates) {\r\n        const input = itemMetadataUpdates || {};\r\n        sanitize_1.validateOptionalTtl(input.ttl);\r\n        return this.updateMergingQueue.squashAndAdd(index, input, (input) => this._updateItemUnconditionally(index, value, input.ttl));\r\n    }\r\n    async _updateItemUnconditionally(index, data, ttl) {\r\n        let existingItem = await this.get(index);\r\n        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\r\n        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\r\n        return this.cache.get(index);\r\n    }\r\n    async _updateItemWithIfMatch(index, mutatorFunction, ttl) {\r\n        const existingItem = await this.get(index);\r\n        const data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\r\n        if (data) {\r\n            const ifMatch = existingItem.revision;\r\n            try {\r\n                const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\r\n                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\r\n                return this.cache.get(index);\r\n            }\r\n            catch (error) {\r\n                if (error.status === 412) {\r\n                    await this._getItemFromServer(index);\r\n                    return this._updateItemWithIfMatch(index, mutatorFunction, ttl);\r\n                }\r\n                else {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return existingItem;\r\n        }\r\n    }\r\n    async mutate(index, mutator, itemMetadataUpdates) {\r\n        const input = itemMetadataUpdates || {};\r\n        sanitize_1.validateOptionalTtl(input.ttl);\r\n        return this.updateMergingQueue.add(index, input, (input) => this._updateItemWithIfMatch(index, mutator, input.ttl));\r\n    }\r\n    async update(index, obj, itemMetadataUpdates) {\r\n        return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);\r\n    }\r\n    async remove(index) {\r\n        let item = await this.get(index);\r\n        let response = await this.services.network.delete(item.uri);\r\n        this._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\r\n    }\r\n    async get(index) {\r\n        let cachedItem = this.cache.get(index);\r\n        if (cachedItem) {\r\n            return cachedItem;\r\n        }\r\n        else {\r\n            return this._getItemFromServer(index);\r\n        }\r\n    }\r\n    async _getItemFromServer(index) {\r\n        let result = await this.queryItems({ index });\r\n        if (result.items.length < 1) {\r\n            throw new syncerror_1.SyncError(`No item with index ${index} found`, 404, 54151);\r\n        }\r\n        else {\r\n            return result.items[0];\r\n        }\r\n    }\r\n    /**\r\n     * Query items from the List\r\n     * @private\r\n     */\r\n    async queryItems(arg) {\r\n        arg = arg || {};\r\n        const url = new uri_1.UriBuilder(this.links.items)\r\n            .queryParam('From', arg.from)\r\n            .queryParam('PageSize', arg.limit)\r\n            .queryParam('Index', arg.index)\r\n            .queryParam('PageToken', arg.pageToken)\r\n            .queryParam('Order', arg.order)\r\n            .build();\r\n        let response = await this.services.network.get(url);\r\n        let items = response.body.items.map(el => {\r\n            el.date_updated = new Date(el.date_updated);\r\n            let itemInCache = this.cache.get(el.index);\r\n            if (itemInCache) {\r\n                this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\r\n            }\r\n            else {\r\n                this.cache.store(Number(el.index), new listitem_1.ListItem({\r\n                    index: Number(el.index),\r\n                    uri: el.url,\r\n                    revision: el.revision,\r\n                    lastEventId: el.last_event_id,\r\n                    dateUpdated: el.date_updated,\r\n                    dateExpires: el.date_expires,\r\n                    value: el.data\r\n                }), el.last_event_id);\r\n            }\r\n            return this.cache.get(el.index);\r\n        });\r\n        let meta = response.body.meta;\r\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\r\n    }\r\n    async getItems(args) {\r\n        args = args || {};\r\n        sanitize_1.validatePageSize(args.pageSize);\r\n        args.limit = args.pageSize || args.limit || 50;\r\n        args.order = args.order || 'asc';\r\n        return this.queryItems(args);\r\n    }\r\n    /**\r\n     * @return {Promise<Object>} Context of List\r\n     * @private\r\n     */\r\n    async getContext() {\r\n        if (!this.context) {\r\n            let response = await this.services.network.get(this.links.context);\r\n            // store fetched context if we have't received any newer update\r\n            this._updateContextIfRequired(response.body.data, response.body.last_event_id);\r\n        }\r\n        return this.context;\r\n    }\r\n    async setTtl(ttl) {\r\n        sanitize_1.validateMandatoryTtl(ttl);\r\n        try {\r\n            const requestBody = { ttl };\r\n            const response = await this.services.network.post(this.uri, requestBody);\r\n            this.descriptor.date_expires = response.body.date_expires;\r\n        }\r\n        catch (error) {\r\n            if (error.status === 404) {\r\n                this.onRemoved(false);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    async setItemTtl(index, ttl) {\r\n        sanitize_1.validateMandatoryTtl(ttl);\r\n        let existingItem = await this.get(index);\r\n        const requestBody = { ttl };\r\n        const response = await this.services.network.post(existingItem.uri, requestBody);\r\n        existingItem.updateDateExpires(response.body.date_expires);\r\n    }\r\n    async removeList() {\r\n        await this.services.network.delete(this.uri);\r\n        this.onRemoved(true);\r\n    }\r\n    onRemoved(locally) {\r\n        this._unsubscribe();\r\n        this.removalHandler(this.type, this.sid, this.uniqueName);\r\n        this.broadcastEventToListeners('removed', { isLocal: locally });\r\n    }\r\n    shouldIgnoreEvent(key, eventId) {\r\n        return this.cache.isKnown(key, eventId);\r\n    }\r\n    /**\r\n     * Handle update, which came from the server.\r\n     * @private\r\n     */\r\n    _update(update, isStrictlyOrdered) {\r\n        const itemIndex = Number(update.item_index);\r\n        update.date_created = new Date(update.date_created);\r\n        switch (update.type) {\r\n            case 'list_item_added':\r\n            case 'list_item_updated':\r\n                {\r\n                    this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\r\n                    update.type === 'list_item_added', true);\r\n                }\r\n                break;\r\n            case 'list_item_removed':\r\n                {\r\n                    this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\r\n                }\r\n                break;\r\n            case 'list_context_updated':\r\n                {\r\n                    this._handleContextUpdate(update.context_data, update.id, update.date_created);\r\n                }\r\n                break;\r\n            case 'list_removed':\r\n                {\r\n                    this.onRemoved(false);\r\n                }\r\n                break;\r\n        }\r\n        if (isStrictlyOrdered) {\r\n            this._advanceLastEventId(update.id, update.list_revision);\r\n        }\r\n    }\r\n    _advanceLastEventId(eventId, revision) {\r\n        if (this.lastEventId < eventId) {\r\n            this.descriptor.last_event_id = eventId;\r\n            if (revision) {\r\n                this.descriptor.revision = revision;\r\n            }\r\n        }\r\n    }\r\n    _updateRootDateUpdated(dateUpdated) {\r\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\r\n            this.descriptor.date_updated = dateUpdated;\r\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\r\n        }\r\n    }\r\n    _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\r\n        if (this.shouldIgnoreEvent(index, lastEventId)) {\r\n            logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\r\n            return;\r\n        }\r\n        else {\r\n            this._updateRootDateUpdated(dateUpdated);\r\n            let item = this.cache.get(index);\r\n            if (!item) {\r\n                let item = new listitem_1.ListItem({ index, uri, lastEventId, revision, value, dateUpdated, dateExpires });\r\n                this.cache.store(index, item, lastEventId);\r\n                this.emitItemMutationEvent(item, remote, added);\r\n            }\r\n            else {\r\n                item.update(lastEventId, revision, value, dateUpdated);\r\n                this.cache.store(index, item, lastEventId);\r\n                if (dateExpires !== undefined) {\r\n                    item.updateDateExpires(dateExpires);\r\n                }\r\n                this.emitItemMutationEvent(item, remote, false);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    emitItemMutationEvent(item, remote, added) {\r\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\r\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\r\n        this._updateRootDateUpdated(dateUpdated);\r\n        this.cache.delete(index, eventId);\r\n        this.broadcastEventToListeners('itemRemoved', { index: index, isLocal: !remote, value: oldData });\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _handleContextUpdate(data, eventId, dateUpdated) {\r\n        this._updateRootDateUpdated(dateUpdated);\r\n        if (this._updateContextIfRequired(data, eventId)) {\r\n            this.broadcastEventToListeners('contextUpdated', { context: data, isLocal: false });\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _updateContextIfRequired(data, eventId) {\r\n        if (!this.contextEventId || eventId > this.contextEventId) {\r\n            this.context = data;\r\n            this.contextEventId = eventId;\r\n            return true;\r\n        }\r\n        else {\r\n            logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\r\n            return false;\r\n        }\r\n    }\r\n}\r\nexports.SyncListImpl = SyncListImpl;\r\n/**\r\n * @class\r\n * @alias List\r\n * @classdesc Represents a Sync List, which stores an ordered list of values.\r\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\r\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\r\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\r\n * @property {Date} dateUpdated Date when the List was last updated.\r\n *\r\n * @fires List#removed\r\n * @fires List#itemAdded\r\n * @fires List#itemRemoved\r\n * @fires List#itemUpdated\r\n */\r\nclass SyncList extends closeable_1.default {\r\n    constructor(syncListImpl) {\r\n        super();\r\n        this.syncListImpl = syncListImpl;\r\n        this.syncListImpl.attach(this);\r\n    }\r\n    // private props\r\n    get uri() {\r\n        return this.syncListImpl.uri;\r\n    }\r\n    get revision() {\r\n        return this.syncListImpl.revision;\r\n    }\r\n    get lastEventId() {\r\n        return this.syncListImpl.lastEventId;\r\n    }\r\n    get links() {\r\n        return this.syncListImpl.links;\r\n    }\r\n    get dateExpires() {\r\n        return this.syncListImpl.dateExpires;\r\n    }\r\n    static get type() {\r\n        return SyncListImpl.type;\r\n    }\r\n    get type() {\r\n        return SyncListImpl.type;\r\n    }\r\n    // public props, documented along with class description\r\n    get sid() {\r\n        return this.syncListImpl.sid;\r\n    }\r\n    get uniqueName() {\r\n        return this.syncListImpl.uniqueName;\r\n    }\r\n    get dateUpdated() {\r\n        return this.syncListImpl.dateUpdated;\r\n    }\r\n    /**\r\n     * Add a new item to the list.\r\n     * @param {Object} value Value to be added.\r\n     * @param {List#ItemMetadata} [itemMetadata] Item metadata.\r\n     * @returns {Promise<ListItem>} A newly added item.\r\n     * @public\r\n     * @example\r\n     * list.push({ name: 'John Smith' }, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List Item push() failed', error);\r\n     *   });\r\n     */\r\n    async push(value, itemMetadata) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.push(value, itemMetadata);\r\n    }\r\n    /**\r\n     * Assign new value to an existing item, given its index.\r\n     * @param {Number} index Index of the item to be updated.\r\n     * @param {Object} value New value to be assigned to an item.\r\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n     * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\r\n     * The promise will be rejected if the item does not exist.\r\n     * @public\r\n     * @example\r\n     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     console.log('List Item set() successful, item value:', item.value)\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List Item set() failed', error);\r\n     *   });\r\n     */\r\n    async set(index, value, itemMetadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.set(index, value, itemMetadataUpdates);\r\n    }\r\n    /**\r\n     * Modify an existing item by applying a mutation function to it.\r\n     * @param {Number} index Index of an item to be changed.\r\n     * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\r\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n     * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\r\n     *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\r\n     *    will be rejected if the indicated item does not already exist.\r\n     * @public\r\n     * @example\r\n     * var mutatorFunction = function(currentValue) {\r\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\r\n     *     return currentValue;\r\n     * };\r\n     * list.mutate(42, mutatorFunction, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     console.log('List Item mutate() successful, new value:', item.value)\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List Item mutate() failed', error);\r\n     *   });\r\n     */\r\n    async mutate(index, mutator, itemMetadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);\r\n    }\r\n    /**\r\n     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\r\n     * This is equivalent to\r\n     * <pre>\r\n     * list.mutate(42, function(currentValue) {\r\n     *   return Object.assign(currentValue, obj));\r\n     * });\r\n     * </pre>\r\n     * @param {Number} index Index of an item to be changed.\r\n     * @param {Object} obj Set of fields to update.\r\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\r\n     * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\r\n     * The promise will be rejected if an item was not found.\r\n     * @public\r\n     * @example\r\n     * // Say, the List Item (index: 42) value is { name: 'John Smith' }\r\n     * list.update(42, { age: 34 }, { ttl: 86400 })\r\n     *   .then(function(item) {\r\n     *     // Now the List Item value is { name: 'John Smith', age: 34 }\r\n     *     console.log('List Item update() successful, new value:', item.value);\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List Item update() failed', error);\r\n     *   });\r\n     */\r\n    async update(index, obj, itemMetadataUpdates) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.update(index, obj, itemMetadataUpdates);\r\n    }\r\n    /**\r\n     * Delete an item, given its index.\r\n     * @param {Number} index Index of an item to be removed.\r\n     * @returns {Promise<void>} A promise to remove an item.\r\n     * A promise will be rejected if an item was not found.\r\n     * @public\r\n     * @example\r\n     * list.remove(42)\r\n     *   .then(function() {\r\n     *     console.log('List Item remove() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List Item remove() failed', error);\r\n     *   });\r\n     */\r\n    async remove(index) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.remove(index);\r\n    }\r\n    /**\r\n     * Retrieve an item by List index.\r\n     * @param {Number} index Item index in a List.\r\n     * @returns {Promise<ListItem>} A promise with an item containing latest known value.\r\n     * A promise will be rejected if an item was not found.\r\n     * @public\r\n     * @example\r\n     * list.get(42)\r\n     *   .then(function(item) {\r\n     *     console.log('List Item get() successful, item value:', item.value)\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List Item get() failed', error);\r\n     *   });\r\n     */\r\n    async get(index) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.get(index);\r\n    }\r\n    /**\r\n     * Retrieve a List context\r\n     * @returns {Promise<Object>} A promise with a List's context\r\n     * @ignore\r\n     */\r\n    async getContext() {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.getContext();\r\n    }\r\n    /**\r\n     * Query a list of items from collection.\r\n     * @param {Object} [args] Arguments for query\r\n     * @param {Number} [args.from] Item index, which should be used as the offset.\r\n     * If undefined, starts from the beginning or end depending on args.order.\r\n     * @param {Number} [args.pageSize=50] Results page size.\r\n     * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\r\n     * @returns {Promise<Paginator<ListItem>>}\r\n     * @public\r\n     * @example\r\n     * var pageHandler = function(paginator) {\r\n     *   paginator.items.forEach(function(item) {\r\n     *     console.log('Item ' + item.index + ': ', item.value);\r\n     *   });\r\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\r\n     *                                : null;\r\n     * };\r\n     * list.getItems({ from: 0, order: 'asc' })\r\n     *   .then(pageHandler)\r\n     *   .catch(function(error) {\r\n     *     console.error('List getItems() failed', error);\r\n     *   });\r\n     */\r\n    async getItems(args) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.getItems(args);\r\n    }\r\n    /**\r\n     * Update the time-to-live of the list.\r\n     * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\r\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n     * @public\r\n     * @example\r\n     * list.setTtl(3600)\r\n     *   .then(function() {\r\n     *     console.log('List setTtl() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List setTtl() failed', error);\r\n     *   });\r\n     */\r\n    async setTtl(ttl) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.setTtl(ttl);\r\n    }\r\n    /**\r\n     * Update the time-to-live of a list item.\r\n     * @param {Number} index Item index.\r\n     * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\r\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\r\n     * @public\r\n     * @example\r\n     * list.setItemTtl(42, 86400)\r\n     *   .then(function() {\r\n     *     console.log('List setItemTtl() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List setItemTtl() failed', error);\r\n     *   });\r\n     */\r\n    async setItemTtl(index, ttl) {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.setItemTtl(index, ttl);\r\n    }\r\n    /**\r\n     * Delete this list. It will be impossible to restore it.\r\n     * @return {Promise<void>} A promise that resolves when the list has been deleted.\r\n     * @public\r\n     * @example\r\n     * list.removeList()\r\n     *   .then(function() {\r\n     *     console.log('List removeList() successful');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.error('List removeList() failed', error);\r\n     *   });\r\n     */\r\n    async removeList() {\r\n        this.ensureNotClosed();\r\n        return this.syncListImpl.removeList();\r\n    }\r\n    /**\r\n     * Conclude work with the list instance and remove all event listeners attached to it.\r\n     * Any subsequent operation on this object will be rejected with error.\r\n     * Other local copies of this list will continue operating and receiving events normally.\r\n     * @public\r\n     * @example\r\n     * list.close();\r\n     */\r\n    close() {\r\n        super.close();\r\n        this.syncListImpl.detach(this.listenerUuid);\r\n    }\r\n}\r\nexports.SyncList = SyncList;\r\nexports.default = SyncList;\r\n/**\r\n * Contains List Item metadata.\r\n * @typedef {Object} List#ItemMetadata\r\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\r\n * The value 0 means infinity.\r\n */\r\n/**\r\n * Applies a transformation to the item value. May be called multiple times on the\r\n * same datum in case of collisions with remote code.\r\n * @callback List~Mutator\r\n * @param {Object} currentValue The current value of the item in the cloud.\r\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\r\n */\r\n/**\r\n * Fired when a new item appears in the list, whether its creator was local or remote.\r\n * @event List#itemAdded\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {ListItem} args.item Added item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\r\n * @example\r\n * list.on('itemAdded', function(args) {\r\n *   console.log('List item ' + args.item.index + ' was added');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\r\n * @event List#itemUpdated\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {ListItem} args.item Updated item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\r\n * @example\r\n * list.on('itemUpdated', function(args) {\r\n *   console.log('List item ' + args.item.index + ' was updated');\r\n *   console.log('args.item.value:', args.item.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a list item is removed, whether the remover was local or remote.\r\n * @event List#itemRemoved\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Number} args.index The index of the removed item.\r\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\r\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\r\n * @example\r\n * list.on('itemRemoved', function(args) {\r\n *   console.log('List item ' + args.index + ' was removed');\r\n *   console.log('args.value:', args.value);\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n/**\r\n * Fired when a list is deleted entirely, by any actor local or remote.\r\n * @event List#removed\r\n * @param {Object} args Arguments provided with the event.\r\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\r\n * @example\r\n * list.on('removed', function(args) {\r\n *   console.log('List ' + list.sid + ' was removed');\r\n *   console.log('args.isLocal:', args.isLocal);\r\n * });\r\n */\r\n"]},"metadata":{},"sourceType":"script"}