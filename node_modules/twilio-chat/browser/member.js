"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _isInteger = require("babel-runtime/core-js/number/is-integer");

var _isInteger2 = _interopRequireDefault(_isInteger);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _metadata = require("babel-runtime/core-js/reflect/metadata");

var _metadata2 = _interopRequireDefault(_metadata);

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getOwnPropertyDescriptor = require("babel-runtime/core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = (0, _getOwnPropertyDescriptor2.default)(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof3.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && (0, _defineProperty2.default)(target, key, r), r;
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof3.default)(Reflect)) === "object" && typeof _metadata2.default === "function") return (0, _metadata2.default)(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Member = void 0;
var events_1 = require("events");
var util_1 = require("./util");
var logger_1 = require("./logger");
var typecheck_1 = require("./util/typecheck");
var log = logger_1.Logger.scope('Member');
/**
 * @classdesc A Member represents a remote Client in a Channel.
 * @property {any} attributes - Object with custom attributes for Member
 * @property {Channel} channel - The Channel the remote Client is a Member of
 * @property {Date} dateCreated - The Date this Member was created
 * @property {Date} dateUpdated - The Date this Member was last updated
 * @property {String} identity - The identity of the remote Client
 * @property {Boolean} isTyping - Whether or not this Member is currently typing
 * @property {Number} lastConsumedMessageIndex - Latest consumed Message index by this Member.
 * Note that just retrieving messages on a client endpoint does not mean that messages are consumed/read,
 * please consider reading about [Consumption Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}
 * to find out how to mark messages as consumed.
 * @property {Date} lastConsumptionTimestamp - Date when Member has updated their consumption horizon
 * @property {String} sid - The server-assigned unique identifier for the Member
 * @property {Member#Type} type - The type of Member
 * @fires Member#typingEnded
 * @fires Member#typingStarted
 * @fires Member#updated
 */

var Member = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Member, _events_1$EventEmitte);

    /**
     * The update reason for <code>updated</code> event emitted on Member
     * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |
      'lastConsumedMessageIndex' | 'lastConsumptionTimestamp')} Member#UpdateReason
     */
    /**
     * The type of Member
     * @typedef {('chat' | 'sms' | 'whatsapp')} Member#Type
     */
    function Member(services, channel, data, sid) {
        (0, _classCallCheck3.default)(this, Member);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Member.__proto__ || (0, _getPrototypeOf2.default)(Member)).call(this));

        _this.channel = channel;
        _this.services = services;
        _this.state = {
            attributes: util_1.parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for member: ' + sid, log),
            dateCreated: data.dateCreated ? util_1.parseTime(data.dateCreated) : null,
            dateUpdated: data.dateCreated ? util_1.parseTime(data.dateUpdated) : null,
            sid: sid,
            typingTimeout: null,
            isTyping: false,
            identity: data.identity || null,
            roleSid: data.roleSid || null,
            lastConsumedMessageIndex: (0, _isInteger2.default)(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,
            lastConsumptionTimestamp: data.lastConsumptionTimestamp ? util_1.parseTime(data.lastConsumptionTimestamp) : null,
            type: data.type || 'chat',
            userInfo: data.userInfo
        };
        if (!data.identity && !data.type) {
            throw new Error('Received invalid Member object from server: Missing identity or type of Member.');
        }
        return _this;
    }

    (0, _createClass3.default)(Member, [{
        key: "_startTyping",

        /**
         * Private method used to start or reset the typing indicator timeout (with event emitting)
         * @private
         */
        value: function _startTyping(timeout) {
            var _this2 = this;

            clearTimeout(this.state.typingTimeout);
            this.state.isTyping = true;
            this.emit('typingStarted', this);
            this.channel.emit('typingStarted', this);
            this.state.typingTimeout = setTimeout(function () {
                return _this2._endTyping();
            }, timeout);
            return this;
        }
        /**
         * Private method function used to stop typing indicator (with event emitting)
         * @private
         */

    }, {
        key: "_endTyping",
        value: function _endTyping() {
            if (!this.state.typingTimeout) {
                return;
            }
            this.state.isTyping = false;
            this.emit('typingEnded', this);
            this.channel.emit('typingEnded', this);
            clearInterval(this.state.typingTimeout);
            this.state.typingTimeout = null;
        }
        /**
         * Private method function used update local object's property roleSid with new value
         * @private
         */

    }, {
        key: "_update",
        value: function _update(data) {
            var updateReasons = [];
            var updateAttributes = util_1.parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for member: ' + this.state.sid, log);
            if (data.attributes && !util_1.isDeepEqual(this.state.attributes, updateAttributes)) {
                this.state.attributes = updateAttributes;
                updateReasons.push('attributes');
            }
            var updatedDateUpdated = util_1.parseTime(data.dateUpdated);
            if (data.dateUpdated && updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
                this.state.dateUpdated = updatedDateUpdated;
                updateReasons.push('dateUpdated');
            }
            var updatedDateCreated = util_1.parseTime(data.dateCreated);
            if (data.dateCreated && updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {
                this.state.dateCreated = updatedDateCreated;
                updateReasons.push('dateCreated');
            }
            if (data.roleSid && this.state.roleSid !== data.roleSid) {
                this.state.roleSid = data.roleSid;
                updateReasons.push('roleSid');
            }
            if (((0, _isInteger2.default)(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null) && this.state.lastConsumedMessageIndex !== data.lastConsumedMessageIndex) {
                this.state.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                updateReasons.push('lastConsumedMessageIndex');
            }
            if (data.lastConsumptionTimestamp) {
                var lastConsumptionTimestamp = new Date(data.lastConsumptionTimestamp);
                if (!this.state.lastConsumptionTimestamp || this.state.lastConsumptionTimestamp.getTime() !== lastConsumptionTimestamp.getTime()) {
                    this.state.lastConsumptionTimestamp = lastConsumptionTimestamp;
                    updateReasons.push('lastConsumptionTimestamp');
                }
            }
            if (updateReasons.length > 0) {
                this.emit('updated', { member: this, updateReasons: updateReasons });
            }
            return this;
        }
        /**
         * Gets User Descriptor for this member. Supported only for <code>chat</code> type of Members
         * @returns {Promise<UserDescriptor>}
         */

    }, {
        key: "getUserDescriptor",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (!(this.type != 'chat')) {
                                    _context.next = 2;
                                    break;
                                }

                                throw new Error('Getting User Descriptor is not supported for this Member type: ' + this.type);

                            case 2:
                                return _context.abrupt("return", this.services.users.getUserDescriptor(this.state.identity));

                            case 3:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function getUserDescriptor() {
                return _ref.apply(this, arguments);
            }

            return getUserDescriptor;
        }()
        /**
         * Gets User for this member and subscribes to it. Supported only for <code>chat</code> type of Members
         * @returns {Promise<User>}
         */

    }, {
        key: "getUser",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!(this.type != 'chat')) {
                                    _context2.next = 2;
                                    break;
                                }

                                throw new Error('Getting User is not supported for this Member type: ' + this.type);

                            case 2:
                                return _context2.abrupt("return", this.services.users.getUser(this.state.identity, this.state.userInfo));

                            case 3:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function getUser() {
                return _ref2.apply(this, arguments);
            }

            return getUser;
        }()
        /**
         * Remove Member from the Channel.
         * @returns {Promise<void>}
         */

    }, {
        key: "remove",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                return _context3.abrupt("return", this.channel.removeMember(this));

                            case 1:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function remove() {
                return _ref3.apply(this, arguments);
            }

            return remove;
        }()
        /**
         * Edit member attributes.
         * @param {any} attributes new attributes for Member.
         * @returns {Promise<Member>}
         */

    }, {
        key: "updateAttributes",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(attributes) {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                _context4.next = 2;
                                return this.services.session.addCommand('editMemberAttributes', {
                                    channelSid: this.channel.sid,
                                    memberSid: this.sid,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 2:
                                return _context4.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function updateAttributes(_x) {
                return _ref4.apply(this, arguments);
            }

            return updateAttributes;
        }()
    }, {
        key: "sid",
        get: function get() {
            return this.state.sid;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this.state.attributes;
        }
    }, {
        key: "dateCreated",
        get: function get() {
            return this.state.dateCreated;
        }
    }, {
        key: "dateUpdated",
        get: function get() {
            return this.state.dateUpdated;
        }
    }, {
        key: "identity",
        get: function get() {
            return this.state.identity;
        }
    }, {
        key: "isTyping",
        get: function get() {
            return this.state.isTyping;
        }
    }, {
        key: "lastConsumedMessageIndex",
        get: function get() {
            return this.state.lastConsumedMessageIndex;
        }
    }, {
        key: "lastConsumptionTimestamp",
        get: function get() {
            return this.state.lastConsumptionTimestamp;
        }
    }, {
        key: "roleSid",
        get: function get() {
            return this.state.roleSid;
        }
    }, {
        key: "type",
        get: function get() {
            return this.state.type;
        }
    }]);
    return Member;
}(events_1.EventEmitter);

__decorate([typecheck_1.asyncTypeCheck(['string', 'number', 'boolean', 'object', typecheck_1.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", _promise2.default)], Member.prototype, "updateAttributes", null);
exports.Member = Member;
/**
 * Fired when Member started to type.
 * @event Member#typingStarted
 * @type {Member}
 */
/**
 * Fired when Member ended to type.
 * @event Member#typingEnded
 * @type {Member}
 */
/**
 * Fired when Member's fields has been updated.
 * @event Member#updated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */