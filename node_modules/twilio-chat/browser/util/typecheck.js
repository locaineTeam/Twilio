"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _isInteger = require("babel-runtime/core-js/number/is-integer");

var _isInteger2 = _interopRequireDefault(_isInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.pureObject = exports.nonNegativeInteger = exports.nonEmptyString = exports.stringifyReceivedType = exports.custom = exports.literal = exports.type = exports.asyncTypeCheck = exports.typeCheck = exports.runtimeTypeCheck = void 0;
var type = function type() {
    for (var _len = arguments.length, checks = Array(_len), _key = 0; _key < _len; _key++) {
        checks[_key] = arguments[_key];
    }

    return {
        mode: 'type',
        checks: checks
    };
};
exports.type = type;
var literal = function literal() {
    for (var _len2 = arguments.length, checks = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        checks[_key2] = arguments[_key2];
    }

    return {
        mode: 'literal',
        checks: checks
    };
};
exports.literal = literal;
var custom = function custom() {
    for (var _len3 = arguments.length, checks = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        checks[_key3] = arguments[_key3];
    }

    return {
        mode: 'custom',
        checks: checks
    };
};
exports.custom = custom;
var nonEmptyString = custom(function (value) {
    return [typeof value === 'string' && value.length > 0, 'a non-empty string'];
});
exports.nonEmptyString = nonEmptyString;
var nonNegativeInteger = custom(function (value) {
    return [(0, _isInteger2.default)(value) && value >= 0, 'a non-negative integer'];
});
exports.nonNegativeInteger = nonNegativeInteger;
var pureObject = custom(function (value) {
    return [(typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === 'object' && value !== null && !Array.isArray(value), 'a pure object (non-null and non-array)'];
});
exports.pureObject = pureObject;
var runtimeTypeCheck = function runtimeTypeCheck(rules, values, methodName) {
    if (values.length > rules.length) {
        throw new Error("Expected at most " + rules.length + " argument(s), but got " + values.length);
    }
    while (values.length < rules.length) {
        values.push(undefined);
    }
    values.forEach(function (value, index) {
        var ruleDefinitions = rules[index];
        var expectedTypes = [];
        var customReceivedType = void 0;
        var isValid = false;
        ruleDefinitions.forEach(function (definition) {
            switch (definition.mode) {
                case 'type':
                    definition.checks.forEach(function (type) {
                        if (typeof type === 'string') {
                            isValid = isValid || (typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === type;
                            expectedTypes.push("of type " + type);
                            return;
                        }
                        isValid = isValid || value instanceof type;
                        expectedTypes.push("an instance of " + type.name);
                    });
                    break;
                case 'literal':
                    definition.checks.forEach(function (type) {
                        isValid = isValid || value === type;
                        expectedTypes.push(typeof type === 'string' ? "\"" + type + "\"" : "" + type);
                    });
                    break;
                case 'custom':
                    definition.checks.forEach(function (check) {
                        var _check = check(value),
                            _check2 = (0, _slicedToArray3.default)(_check, 3),
                            checkPassed = _check2[0],
                            typeDescription = _check2[1],
                            receivedType = _check2[2];

                        isValid = isValid || checkPassed;
                        if (!customReceivedType && receivedType) {
                            customReceivedType = receivedType;
                        }
                        expectedTypes.push(typeDescription);
                    });
                    break;
            }
        });
        if (isValid) {
            return;
        }
        var receivedType = customReceivedType || stringifyReceivedType(value);
        var methodNameNotice = methodName ? " of " + methodName : '';
        var lastIndex = expectedTypes.length - 1;
        var expectedTypesString = lastIndex > 0 ? expectedTypes.slice(0, lastIndex).join(', ') + " or " + expectedTypes[lastIndex] : expectedTypes.join(', ');
        var delimiter = lastIndex > 1 ? ';' : ',';
        throw new Error("Argument " + (index + 1) + methodNameNotice + " is expected to be " + expectedTypesString + delimiter + " but got " + receivedType);
    });
};
exports.runtimeTypeCheck = runtimeTypeCheck;
var stringifyReceivedType = function stringifyReceivedType(value) {
    var _a;
    var receivedType = void 0;
    if (['undefined', 'boolean', 'number', 'bigint', 'string'].includes(typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value))) {
        receivedType = typeof value === 'string' ? "\"" + value + "\"" : "" + value;
    }
    var constructorName = (_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name;
    if ((typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === 'object' && constructorName !== 'Object') {
        receivedType = value === null ? 'null' : "instance of " + constructorName;
    }
    if (!receivedType) {
        receivedType = typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value);
    }
    return receivedType;
};
exports.stringifyReceivedType = stringifyReceivedType;
var typeCheck = function typeCheck() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
    }

    var finalRuleSet = _getRuleSet(args);
    return function (target, propertyKey, descriptor) {
        if (typeof descriptor.value !== 'function') {
            throw new Error('The typeCheck decorator can only be applied to methods');
        }
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
            }

            runtimeTypeCheck(finalRuleSet, args, originalMethod.name);
            return originalMethod.apply(this, arguments);
        };
    };
};
exports.typeCheck = typeCheck;
var asyncTypeCheck = function asyncTypeCheck() {
    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
    }

    var finalRuleSet = _getRuleSet(args);
    return function (target, propertyKey, descriptor) {
        if (typeof descriptor.value !== 'function') {
            throw new Error('The asyncTypeCheck decorator can only be applied to methods');
        }
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                args[_key7] = arguments[_key7];
            }

            try {
                runtimeTypeCheck(finalRuleSet, args, originalMethod.name);
            } catch (e) {
                return _promise2.default.reject(e);
            }
            return originalMethod.apply(this, arguments);
        };
    };
};
exports.asyncTypeCheck = asyncTypeCheck;
var _getRuleSet = function _getRuleSet(args) {
    var finalRuleSet = [];
    args.forEach(function (arg) {
        var finalArgumentRules = [];
        var declaredRules = Array.isArray(arg) ? arg : [arg];
        declaredRules.forEach(function (rule) {
            if (['string', 'function'].includes(typeof rule === "undefined" ? "undefined" : (0, _typeof3.default)(rule))) {
                finalArgumentRules.push(type(rule));
                return;
            }
            finalArgumentRules.push(rule);
        });
        finalRuleSet.push(finalArgumentRules);
    });
    return finalRuleSet;
};