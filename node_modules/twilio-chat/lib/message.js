"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const events_1 = require("events");
const util_1 = require("./util");
const logger_1 = require("./logger");
const media_1 = require("./media");
const typecheck_1 = require("./util/typecheck");
const log = logger_1.Logger.scope('Message');
/**
 * @classdesc A Message represents a Message in a Channel.
 * @property {String} author - The name of the user that sent Message
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {any} attributes - Message custom attributes
 * @property {Channel} channel - Channel Message belongs to
 * @property {Date} dateCreated - When Message was created
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Channel's messages list
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} memberSid - Authoring Member's server-assigned unique identifier
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {'text' | 'media' } type - Type of message: 'text' or 'media'
 * @fires Message#updated
 */
class Message extends events_1.EventEmitter {
    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author')} Message#UpdateReason
     */
    constructor(channel, services, index, data) {
        super();
        this.channel = channel;
        this.services = services;
        this.state = {
            sid: data.sid,
            index: index,
            author: data.author == null ? null : data.author,
            body: data.text,
            timestamp: data.timestamp ? new Date(data.timestamp) : null,
            dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
            lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,
            attributes: util_1.parseAttributes(data.attributes, `Got malformed attributes for the message ${data.sid}`, log),
            type: data.type ? data.type : 'text',
            media: (data.type && data.type === 'media' && data.media)
                ? new media_1.Media(data.media, this.services) : null,
            memberSid: data.memberSid == null ? null : data.memberSid
        };
    }
    get sid() { return this.state.sid; }
    get author() { return this.state.author; }
    get body() {
        if (this.type === 'media') {
            return null;
        }
        return this.state.body;
    }
    get dateUpdated() { return this.state.dateUpdated; }
    get index() { return this.state.index; }
    get lastUpdatedBy() { return this.state.lastUpdatedBy; }
    get dateCreated() { return this.state.timestamp; }
    get attributes() { return this.state.attributes; }
    get type() { return this.state.type; }
    get media() { return this.state.media; }
    get memberSid() { return this.state.memberSid; }
    _update(data) {
        let updateReasons = [];
        if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {
            this.state.body = data.text;
            updateReasons.push('body');
        }
        if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
            this.state.lastUpdatedBy = data.lastUpdatedBy;
            updateReasons.push('lastUpdatedBy');
        }
        if (data.author && data.author !== this.state.author) {
            this.state.author = data.author;
            updateReasons.push('author');
        }
        if (data.dateUpdated &&
            new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = new Date(data.dateUpdated);
            updateReasons.push('dateUpdated');
        }
        if (data.timestamp &&
            new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
            this.state.timestamp = new Date(data.timestamp);
            updateReasons.push('dateCreated');
        }
        let updatedAttributes = util_1.parseAttributes(data.attributes, `Got malformed attributes for the message ${this.sid}`, log);
        if (!util_1.isDeepEqual(this.state.attributes, updatedAttributes)) {
            this.state.attributes = updatedAttributes;
            updateReasons.push('attributes');
        }
        if (updateReasons.length > 0) {
            this.emit('updated', { message: this, updateReasons: updateReasons });
        }
    }
    /**
     * Get Member who is author of the Message
     * @returns {Promise<Member>}
     */
    async getMember() {
        let member = null;
        if (this.state.memberSid) {
            member = await this.channel.getMemberBySid(this.memberSid)
                .catch(() => {
                log.debug('Member with sid "' + this.memberSid + '" not found for message ' + this.sid);
                return null;
            });
        }
        if (!member && this.state.author) {
            member = await this.channel.getMemberByIdentity(this.state.author)
                .catch(() => {
                log.debug('Member with identity "' + this.author + '" not found for message ' + this.sid);
                return null;
            });
        }
        if (member) {
            return member;
        }
        let errorMesage = 'Member with ';
        if (this.state.memberSid) {
            errorMesage += 'SID \'' + this.state.memberSid + '\' ';
        }
        if (this.state.author) {
            if (this.state.memberSid) {
                errorMesage += 'or ';
            }
            errorMesage += 'identity \'' + this.state.author + '\' ';
        }
        if (errorMesage === 'Member with ') {
            errorMesage = 'Member ';
        }
        errorMesage += 'was not found';
        throw new Error(errorMesage);
    }
    /**
     * Remove the Message.
     * @returns {Promise<Message>}
     */
    async remove() {
        await this.services.session.addCommand('deleteMessage', {
            channelSid: this.channel.sid,
            messageIdx: this.index.toString()
        });
        return this;
    }
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message>}
     */
    async updateBody(body) {
        await this.services.session.addCommand('editMessage', {
            channelSid: this.channel.sid,
            messageIdx: this.index.toString(),
            text: body
        });
        return this;
    }
    /**
     * Edit message attributes.
     * @param {any} attributes new attributes for Message.
     * @returns {Promise<Message>}
     */
    async updateAttributes(attributes) {
        await this.services.session.addCommand('editMessageAttributes', {
            channelSid: this.channel.sid,
            messageIdx: this.index,
            attributes: JSON.stringify(attributes)
        });
        return this;
    }
}
__decorate([
    typecheck_1.asyncTypeCheck('string'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Message.prototype, "updateBody", null);
__decorate([
    typecheck_1.asyncTypeCheck(['string', 'number', 'boolean', 'object', typecheck_1.literal(null)]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Message.prototype, "updateAttributes", null);
exports.Message = Message;
/**
 * Fired when the Message's properties or body has been updated.
 * @event Message#updated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
