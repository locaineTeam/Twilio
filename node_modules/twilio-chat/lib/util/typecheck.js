"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pureObject = exports.nonNegativeInteger = exports.nonEmptyString = exports.stringifyReceivedType = exports.custom = exports.literal = exports.type = exports.asyncTypeCheck = exports.typeCheck = exports.runtimeTypeCheck = void 0;
const type = (...checks) => ({
    mode: 'type',
    checks
});
exports.type = type;
const literal = (...checks) => ({
    mode: 'literal',
    checks
});
exports.literal = literal;
const custom = (...checks) => ({
    mode: 'custom',
    checks
});
exports.custom = custom;
const nonEmptyString = custom((value) => [
    typeof value === 'string' && value.length > 0,
    'a non-empty string'
]);
exports.nonEmptyString = nonEmptyString;
const nonNegativeInteger = custom((value) => [
    Number.isInteger(value) && value >= 0,
    'a non-negative integer'
]);
exports.nonNegativeInteger = nonNegativeInteger;
const pureObject = custom((value) => [
    typeof value === 'object' && value !== null && !Array.isArray(value),
    'a pure object (non-null and non-array)'
]);
exports.pureObject = pureObject;
const runtimeTypeCheck = (rules, values, methodName) => {
    if (values.length > rules.length) {
        throw new Error(`Expected at most ${rules.length} argument(s), but got ${values.length}`);
    }
    while (values.length < rules.length) {
        values.push(undefined);
    }
    values.forEach((value, index) => {
        const ruleDefinitions = rules[index];
        const expectedTypes = [];
        let customReceivedType;
        let isValid = false;
        ruleDefinitions.forEach((definition) => {
            switch (definition.mode) {
                case 'type':
                    definition.checks.forEach((type) => {
                        if (typeof type === 'string') {
                            isValid = isValid || typeof value === type;
                            expectedTypes.push(`of type ${type}`);
                            return;
                        }
                        isValid = isValid || value instanceof type;
                        expectedTypes.push(`an instance of ${type.name}`);
                    });
                    break;
                case 'literal':
                    definition.checks.forEach((type) => {
                        isValid = isValid || value === type;
                        expectedTypes.push(typeof type === 'string' ? `"${type}"` : `${type}`);
                    });
                    break;
                case 'custom':
                    definition.checks.forEach((check) => {
                        const [checkPassed, typeDescription, receivedType] = check(value);
                        isValid = isValid || checkPassed;
                        if (!customReceivedType && receivedType) {
                            customReceivedType = receivedType;
                        }
                        expectedTypes.push(typeDescription);
                    });
                    break;
            }
        });
        if (isValid) {
            return;
        }
        const receivedType = customReceivedType || stringifyReceivedType(value);
        const methodNameNotice = methodName ? ` of ${methodName}` : '';
        const lastIndex = expectedTypes.length - 1;
        const expectedTypesString = lastIndex > 0
            ? `${expectedTypes.slice(0, lastIndex).join(', ')} or ${expectedTypes[lastIndex]}`
            : expectedTypes.join(', ');
        const delimiter = lastIndex > 1
            ? ';'
            : ',';
        throw new Error(`Argument ${index + 1}${methodNameNotice} is expected to be ${expectedTypesString}${delimiter} but got ${receivedType}`);
    });
};
exports.runtimeTypeCheck = runtimeTypeCheck;
const stringifyReceivedType = (value) => {
    var _a;
    let receivedType;
    if (['undefined', 'boolean', 'number', 'bigint', 'string'].includes(typeof value)) {
        receivedType = typeof value === 'string' ? `"${value}"` : `${value}`;
    }
    const constructorName = (_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name;
    if (typeof value === 'object' && constructorName !== 'Object') {
        receivedType = value === null ? 'null' : `instance of ${constructorName}`;
    }
    if (!receivedType) {
        receivedType = typeof value;
    }
    return receivedType;
};
exports.stringifyReceivedType = stringifyReceivedType;
const typeCheck = (...args) => {
    const finalRuleSet = _getRuleSet(args);
    return (target, propertyKey, descriptor) => {
        if (typeof descriptor.value !== 'function') {
            throw new Error('The typeCheck decorator can only be applied to methods');
        }
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            runtimeTypeCheck(finalRuleSet, args, originalMethod.name);
            return originalMethod.apply(this, arguments);
        };
    };
};
exports.typeCheck = typeCheck;
const asyncTypeCheck = (...args) => {
    const finalRuleSet = _getRuleSet(args);
    return (target, propertyKey, descriptor) => {
        if (typeof descriptor.value !== 'function') {
            throw new Error('The asyncTypeCheck decorator can only be applied to methods');
        }
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            try {
                runtimeTypeCheck(finalRuleSet, args, originalMethod.name);
            }
            catch (e) {
                return Promise.reject(e);
            }
            return originalMethod.apply(this, arguments);
        };
    };
};
exports.asyncTypeCheck = asyncTypeCheck;
const _getRuleSet = (args) => {
    const finalRuleSet = [];
    args.forEach((arg) => {
        let finalArgumentRules = [];
        let declaredRules = Array.isArray(arg) ? arg : [arg];
        declaredRules.forEach((rule) => {
            if (['string', 'function'].includes(typeof rule)) {
                finalArgumentRules.push(type(rule));
                return;
            }
            finalArgumentRules.push(rule);
        });
        finalRuleSet.push(finalArgumentRules);
    });
    return finalRuleSet;
};
